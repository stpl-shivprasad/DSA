const graphData = {
  "meta": {
    "description": "Comprehensive Conceptual Dependency Graph of Data Structures & Algorithms",
    "root": "Computer Memory",
    "philosophy": "From hardware reality to abstract problem solving",
    "completeness": "High - covers foundations, patterns, and advanced topics"
  },
  "nodes": [
    {
      "id": "memory",
      "label": "Computer Memory (RAM)",
      "type": "root",
      "description": "The physical canvas where data lives.",
      "references": {
        "official": [
          {
            "title": "MDN: Memory Management",
            "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_management"
          }
        ],
        "community": [
          {
            "title": "What Every Programmer Should Know About Memory",
            "url": "https://people.freebsd.org/~lstewart/articles/cpumemory.pdf"
          },
          {
            "title": "YouTube: Memory & Storage - Crash Course",
            "url": "https://www.youtube.com/watch?v=TQCr9RV7twk"
          }
        ]
      },
      "difficulty": 1,
      "timeEstimate": "30 min",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Foundation",
      "categoryIcon": "üèõÔ∏è",
      "content": {
        "definition": {
          "simple": "RAM (Random Access Memory) is where your program's data lives while running. Think of it as a giant array of bytes.",
          "technical": "Linear address space where each byte has a unique address. O(1) access to any address."
        },
        "keyTakeaways": [
          "RAM = giant array of bytes",
          "O(1) access by address",
          "Stack: local vars, Heap: dynamic data",
          "Contiguous = cache-friendly"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "binary",
              "label": "Binary",
              "why": "Addresses are numbers"
            }
          ],
          "nextTopics": [
            {
              "id": "array",
              "label": "Arrays",
              "why": "Contiguous memory"
            }
          ]
        }
      }
    },
    {
      "id": "bits",
      "label": "Bits & Bytes",
      "type": "primitive",
      "description": "Fundamental units of data.",
      "references": {
        "official": [
          {
            "title": "MDN: Bitwise Operators",
            "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/bit-manipulation/"
          },
          {
            "title": "Bit Twiddling Hacks",
            "url": "https://graphics.stanford.edu/~seander/bithacks.html"
          }
        ]
      },
      "difficulty": 2,
      "timeEstimate": "1 hour",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Foundation",
      "categoryIcon": "üß±",
      "content": {
        "definition": {
          "simple": "Bit manipulation uses binary operators to work directly with bits (0s and 1s). It's like having superpowers for certain problems - what takes O(n) with arrays can often be O(1) with bits.",
          "technical": "Bit manipulation involves using bitwise operators (AND, OR, XOR, NOT, shifts) to perform operations at the binary level. It enables efficient solutions for problems involving sets, flags, parity, and mathematical operations that map naturally to binary representation."
        },
        "howItWorks": {
          "explanation": "Computers store everything in binary. When you manipulate bits directly, you're working at the lowest level - no loops, no extra space. Common operations: AND (&) to check/clear bits, OR (|) to set bits, XOR (^) to toggle/compare, shifts (<<, >>) to multiply/divide by 2.",
          "steps": [
            {
              "step": 1,
              "title": "Understand Binary",
              "description": "5 = 101, 7 = 111, 8 = 1000.",
              "why": "Each position is a power of 2."
            },
            {
              "step": 2,
              "title": "Learn Operators",
              "description": "& (AND), | (OR), ^ (XOR), ~ (NOT), << (left shift), >> (right shift).",
              "why": "These are the building blocks."
            },
            {
              "step": 3,
              "title": "Common Patterns",
              "description": "n & (n-1) clears lowest bit, n & -n isolates lowest bit, XOR for finding unique.",
              "why": "Memorize these tricks."
            },
            {
              "step": 4,
              "title": "Apply to Problem",
              "description": "Represent sets, flags, states with bits.",
              "why": "O(1) operations on entire sets."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph TB\n    subgraph \"Bitwise Operations\"\n        A[\"5 & 3 = 101 & 011 = 001 = 1\"]\n        B[\"5 | 3 = 101 | 011 = 111 = 7\"]\n        C[\"5 ^ 3 = 101 ^ 011 = 110 = 6\"]\n        D[\"~5 = ...11111010 (in 2's complement)\"]\n    end\n    \n    style A fill:#98c1d9\n    style C fill:#ee6c4d",
            "caption": "AND: both 1, OR: either 1, XOR: exactly one 1, NOT: flip all"
          }
        },
        "whenToUse": {
          "summary": "Use when problem involves sets, finding unique elements, power of 2, or when you need O(1) space/time for subset operations.",
          "patterns": [
            {
              "pattern": "Single Number",
              "signal": "Find element appearing odd times",
              "example": "All elements appear twice except one",
              "withoutIt": "HashMap counting - O(n) space",
              "withIt": "XOR all elements - O(1) space"
            },
            {
              "pattern": "Power of Two",
              "signal": "Check if n is power of 2",
              "example": "n = 16 (true), n = 18 (false)",
              "withoutIt": "Loop dividing by 2",
              "withIt": "n & (n-1) == 0 in O(1)"
            },
            {
              "pattern": "Counting Bits",
              "signal": "Count 1s in binary representation",
              "example": "Number of set bits (Hamming weight)",
              "withoutIt": "Loop through 32 bits",
              "withIt": "n & (n-1) iterates only set bits"
            },
            {
              "pattern": "Subsets with Bitmask",
              "signal": "Enumerate all subsets efficiently",
              "example": "DP with bitmask state",
              "withoutIt": "Recursive enumeration",
              "withIt": "Loop i from 0 to 2^n - 1"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Bit manipulation is tricky and error-prone. Avoid when readability matters more than micro-optimization.",
          "antiPatterns": [
            {
              "situation": "Large Numbers",
              "why": "JavaScript numbers are 64-bit floats, bitwise ops work on 32 bits",
              "useInstead": "BigInt or standard arithmetic",
              "example": "Numbers > 2^31"
            },
            {
              "situation": "Readability Critical",
              "why": "Bit tricks are hard to understand",
              "useInstead": "Clear loops with comments",
              "example": "Team code review"
            },
            {
              "situation": "Negative Numbers",
              "why": "Two's complement can be confusing",
              "useInstead": "Regular arithmetic",
              "example": "Mixing signed and unsigned"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "Light Switches",
            "story": "Imagine 8 light switches in a row. Each switch is a bit (on=1, off=0). AND is 'both must be on'. OR is 'either can be on'. XOR is 'toggle if the other is on'. Shifting left is like moving all switches one position left, adding a new 'off' switch on the right.",
            "connection": "Each integer IS a row of switches. Bitwise operations manipulate all switches simultaneously - that's why they're so fast."
          },
          "keyInsight": "XOR has magic properties: a ^ a = 0, a ^ 0 = a. This lets you 'cancel out' pairs, finding the unpaired element. AND with (n-1) removes the lowest set bit - useful for counting bits.",
          "commonConfusion": [
            {
              "confusion": "What does n & (n-1) do?",
              "clarification": "Clears the lowest set bit. 12 (1100) & 11 (1011) = 8 (1000). n-1 flips bits from lowest 1 to the right."
            },
            {
              "confusion": "What's n & -n?",
              "clarification": "Isolates the lowest set bit. 12 (1100) & -12 (...0100) = 4 (0100). Uses two's complement property."
            },
            {
              "confusion": "Why XOR for 'single number'?",
              "clarification": "XOR is commutative and self-canceling. a^b^a = b. All pairs cancel, leaving the single."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Bitwise AND/OR/XOR/NOT",
                "average": "O(1)",
                "worst": "O(1)",
                "note": "Single CPU instruction"
              },
              {
                "operation": "Left/Right Shift",
                "average": "O(1)",
                "worst": "O(1)",
                "note": "Single CPU instruction"
              },
              {
                "operation": "Count set bits (n&(n-1) loop)",
                "average": "O(k)",
                "worst": "O(log n)",
                "note": "k = number of 1s"
              },
              {
                "operation": "Enumerate subsets",
                "average": "O(2^n)",
                "worst": "O(2^n)",
                "note": "2^n subsets to enumerate"
              }
            ],
            "explanation": "Individual bit ops are O(1). Complexity comes from loops using them."
          },
          "space": {
            "complexity": "O(1) typically",
            "explanation": "Bits are stored in existing integers, no extra space."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Integers are stored in binary. 32-bit integers have 32 bits; operations work on all bits simultaneously.",
            "keyPoints": [
              "JavaScript: bitwise ops convert to 32-bit signed integer",
              "Python: integers have arbitrary precision, bitwise works but be careful",
              "Two's complement: -1 is all 1s (...11111)",
              "Sign bit is leftmost bit in signed integers"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Bitwise ops work on 32-bit signed integers. >>> is zero-fill right shift.",
              "gotchas": [
                "Numbers are 64-bit floats, converted to 32-bit for bitwise ops",
                ">>> treats as unsigned, >> preserves sign",
                "x | 0 converts to integer (truncates)",
                "Maximum safe integer for bitwise: 2^31 - 1"
              ]
            },
            "python": {
              "implementation": "Integers have arbitrary precision. Negative numbers use conceptual infinite 1s prefix.",
              "gotchas": [
                "~x returns -(x+1) due to two's complement",
                "bin(x) shows binary string",
                "Use & 0xFFFFFFFF to simulate 32-bit",
                "Negative numbers: bin(-1) shows '-0b1', not two's complement"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "XOR finds single non-duplicate in O(n) time O(1) space",
            "proof": {
              "step1": {
                "action": "XOR is associative and commutative",
                "cost": "Order doesn't matter"
              },
              "step2": {
                "action": "a ^ a = 0 for any a",
                "cost": "Pairs cancel"
              },
              "step3": {
                "action": "a ^ 0 = a",
                "cost": "Zero is identity"
              },
              "step4": {
                "action": "XOR all elements: duplicates cancel, single remains",
                "cost": "O(n) XORs, O(1) space"
              }
            },
            "totalCost": "O(n) time, O(1) space"
          }
        },
        "codeTemplates": [
          {
            "name": "Essential Bit Tricks",
            "description": "The most important bit manipulation patterns",
            "javascript": {
              "code": "// Check if bit is set at position i\nfunction getBit(n, i) {\n  return (n >> i) & 1;  // or: (n & (1 << i)) !== 0\n}\n\n// Set bit at position i\nfunction setBit(n, i) {\n  return n | (1 << i);\n}\n\n// Clear bit at position i\nfunction clearBit(n, i) {\n  return n & ~(1 << i);\n}\n\n// Toggle bit at position i\nfunction toggleBit(n, i) {\n  return n ^ (1 << i);\n}\n\n// Check if power of 2\nfunction isPowerOfTwo(n) {\n  return n > 0 && (n & (n - 1)) === 0;\n}\n\n// Count set bits (Hamming weight)\nfunction countBits(n) {\n  let count = 0;\n  while (n) {\n    n &= (n - 1);  // Clear lowest set bit\n    count++;\n  }\n  return count;\n}\n\n// Get lowest set bit\nfunction lowestSetBit(n) {\n  return n & (-n);  // Returns the bit, not position\n}\n\n// Clear lowest set bit\nfunction clearLowestBit(n) {\n  return n & (n - 1);\n}\n\n// Swap without temp variable\nfunction swap(a, b) {\n  a ^= b;\n  b ^= a;\n  a ^= b;\n  return [a, b];\n}",
              "notes": "Positions are 0-indexed from the right (LSB)."
            },
            "python": {
              "code": "def get_bit(n, i):\n    return (n >> i) & 1\n\ndef set_bit(n, i):\n    return n | (1 << i)\n\ndef clear_bit(n, i):\n    return n & ~(1 << i)\n\ndef toggle_bit(n, i):\n    return n ^ (1 << i)\n\ndef is_power_of_two(n):\n    return n > 0 and (n & (n - 1)) == 0\n\ndef count_bits(n):\n    count = 0\n    while n:\n        n &= (n - 1)\n        count += 1\n    return count\n    # Or: return bin(n).count('1')\n\ndef lowest_set_bit(n):\n    return n & (-n)\n\ndef clear_lowest_bit(n):\n    return n & (n - 1)",
              "notes": "bin(n).count('1') is Pythonic alternative for counting bits."
            }
          },
          {
            "name": "Single Number Variants",
            "description": "XOR tricks for finding unique elements",
            "javascript": {
              "code": "// Single Number I: One element appears once, others twice\nfunction singleNumber(nums) {\n  return nums.reduce((xor, num) => xor ^ num, 0);\n}\n\n// Single Number II: One element once, others THREE times\nfunction singleNumberII(nums) {\n  let ones = 0, twos = 0;\n  \n  for (const num of nums) {\n    // ones: bits that have appeared 1 mod 3 times\n    // twos: bits that have appeared 2 mod 3 times\n    ones = (ones ^ num) & ~twos;\n    twos = (twos ^ num) & ~ones;\n  }\n  \n  return ones;\n}\n\n// Single Number III: TWO elements appear once, others twice\nfunction singleNumberIII(nums) {\n  // XOR all ‚Üí gives xorAll = a ^ b\n  let xorAll = nums.reduce((x, n) => x ^ n, 0);\n  \n  // Find any bit where a and b differ\n  const diffBit = xorAll & (-xorAll);  // Lowest set bit\n  \n  // Partition by that bit and XOR separately\n  let a = 0, b = 0;\n  for (const num of nums) {\n    if (num & diffBit) {\n      a ^= num;\n    } else {\n      b ^= num;\n    }\n  }\n  \n  return [a, b];\n}\n\n// Key insight for III:\n// a and b differ in at least one bit\n// That bit will be SET in xorAll\n// Use it to partition into two groups:\n// Group 1: all numbers with that bit set (includes a or b)\n// Group 2: all numbers without (includes the other)\n// XOR each group ‚Üí get a and b separately",
              "notes": "Single Number II uses state machine logic. III uses bit partitioning."
            },
            "python": {
              "code": "def single_number(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n    # Or: reduce(lambda x, y: x ^ y, nums)\n\ndef single_number_ii(nums):\n    ones, twos = 0, 0\n    \n    for num in nums:\n        ones = (ones ^ num) & ~twos\n        twos = (twos ^ num) & ~ones\n    \n    return ones\n\ndef single_number_iii(nums):\n    xor_all = 0\n    for num in nums:\n        xor_all ^= num\n    \n    diff_bit = xor_all & (-xor_all)\n    \n    a, b = 0, 0\n    for num in nums:\n        if num & diff_bit:\n            a ^= num\n        else:\n            b ^= num\n    \n    return [a, b]",
              "notes": "reduce() from functools for functional style."
            }
          },
          {
            "name": "Subset Enumeration with Bitmask",
            "description": "Represent and iterate subsets using bits",
            "javascript": {
              "code": "// Generate all subsets using bitmask\nfunction subsets(nums) {\n  const n = nums.length;\n  const result = [];\n  \n  // 2^n subsets: from 0 (empty) to 2^n - 1 (all)\n  for (let mask = 0; mask < (1 << n); mask++) {\n    const subset = [];\n    \n    for (let i = 0; i < n; i++) {\n      if (mask & (1 << i)) {  // Is bit i set?\n        subset.push(nums[i]);\n      }\n    }\n    \n    result.push(subset);\n  }\n  \n  return result;\n}\n\n// Iterate through all subsets of a given mask\nfunction subsetsOfMask(mask) {\n  const subsets = [];\n  \n  // Start with mask, decrement to 0\n  for (let sub = mask; sub > 0; sub = (sub - 1) & mask) {\n    subsets.push(sub);\n  }\n  subsets.push(0);  // Empty subset\n  \n  return subsets;\n}\n\n// Example: mask = 5 (101)\n// Subsets: 5 (101), 4 (100), 1 (001), 0 (000)\n// The trick (sub - 1) & mask ensures we only get valid subsets\n\n// Bitmask DP example: Traveling Salesman\n// State: (visited_mask, current_city)\n// dp[mask][i] = min cost to visit cities in mask, ending at i",
              "notes": "(sub - 1) & mask iterates only subsets of mask."
            },
            "python": {
              "code": "def subsets(nums):\n    n = len(nums)\n    result = []\n    \n    for mask in range(1 << n):\n        subset = []\n        for i in range(n):\n            if mask & (1 << i):\n                subset.append(nums[i])\n        result.append(subset)\n    \n    return result\n\ndef subsets_of_mask(mask):\n    subsets = []\n    sub = mask\n    while sub > 0:\n        subsets.append(sub)\n        sub = (sub - 1) & mask\n    subsets.append(0)\n    return subsets\n\n# Counting Bits for 0 to n\ndef count_bits_array(n):\n    # dp[i] = count of 1s in binary of i\n    dp = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        # i >> 1 removes last bit, (i & 1) is last bit\n        dp[i] = dp[i >> 1] + (i & 1)\n    \n    return dp\n\n# Example: count_bits_array(5) = [0, 1, 1, 2, 1, 2]\n# 0=0, 1=1, 2=10, 3=11, 4=100, 5=101",
              "notes": "DP recurrence: bits(n) = bits(n//2) + (n mod 2)."
            }
          }
        ],
        "visualTrace": {
          "title": "n & (n-1) Clears Lowest Bit",
          "input": {
            "n": 12
          },
          "steps": [
            {
              "step": 1,
              "n": 12,
              "binary": "1100",
              "action": "Start"
            },
            {
              "step": 2,
              "n_minus_1": 11,
              "binary": "1011",
              "action": "Subtract 1: flips bits from lowest 1 to right"
            },
            {
              "step": 3,
              "result": 8,
              "binary": "1000",
              "action": "AND: 1100 & 1011 = 1000"
            },
            {
              "step": 4,
              "n_minus_1": 7,
              "binary": "0111",
              "action": "8-1 = 7"
            },
            {
              "step": 5,
              "result": 0,
              "binary": "0000",
              "action": "AND: 1000 & 0111 = 0000. Done!"
            }
          ],
          "output": "12 has 2 set bits. Loop ran twice: 12‚Üí8‚Üí0. O(k) where k = number of 1s."
        },
        "commonMistakes": [
          {
            "mistake": "Operator precedence",
            "wrong": "if (n & 1 == 1)",
            "right": "if ((n & 1) == 1)",
            "explanation": "== has higher precedence than &. Always parenthesize bitwise ops."
          },
          {
            "mistake": "Signed vs unsigned shift",
            "wrong": "n >> 1 for negative numbers in JS",
            "right": "n >>> 1 for zero-fill shift",
            "explanation": ">> preserves sign bit, >>> fills with 0."
          },
          {
            "mistake": "JavaScript 32-bit limitation",
            "wrong": "Bitwise on numbers > 2^31",
            "right": "Use BigInt for large numbers",
            "explanation": "Bitwise ops convert to 32-bit signed int."
          }
        ],
        "keyTakeaways": [
          "XOR: a^a=0, a^0=a ‚Äî perfect for finding unpaired elements",
          "n & (n-1) clears lowest set bit ‚Äî use for counting bits",
          "n & -n isolates lowest set bit ‚Äî use for bit tricks",
          "Power of 2: exactly one bit set ‚Üí n & (n-1) == 0",
          "Bitmask: use integers to represent sets, O(1) operations",
          "Watch for: operator precedence, 32-bit limits, signed vs unsigned"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "binary",
              "label": "Binary Numbers",
              "why": "Understanding base-2 representation"
            },
            {
              "id": "math",
              "label": "Basic Math",
              "why": "Powers of 2, modular arithmetic"
            }
          ],
          "nextTopics": [
            {
              "id": "bitmask_dp",
              "label": "Bitmask DP",
              "why": "DP with subset states"
            },
            {
              "id": "subset_sum",
              "label": "Subset Problems",
              "why": "Subset enumeration applications"
            },
            {
              "id": "xor_tricks",
              "label": "Advanced XOR",
              "why": "More XOR-based algorithms"
            }
          ]
        },
        "patternChain": {
          "description": "Bit manipulation is foundational for optimization tricks",
          "buildsOn": [
            {
              "id": "binary",
              "relationship": "Understanding binary representation",
              "whatToKnow": "How integers are stored"
            },
            {
              "id": "math",
              "relationship": "Powers of 2, modular arithmetic",
              "whatToKnow": "Basic number theory"
            }
          ],
          "enables": [
            {
              "id": "single_number",
              "relationship": "XOR cancellation",
              "patternName": "Single Number",
              "interviewFrequency": "Very High"
            },
            {
              "id": "bitmask_dp",
              "relationship": "Subset states in DP",
              "patternName": "Bitmask DP",
              "interviewFrequency": "Medium"
            },
            {
              "id": "power_of_two",
              "relationship": "n & (n-1) trick",
              "patternName": "Power of 2 Check",
              "interviewFrequency": "High"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    BIN[Binary Numbers] --> BITS[Bit Manipulation]\n    MATH[Math] --> BITS\n    BITS --> SINGLE[Single Number]\n    BITS --> BMDP[Bitmask DP]\n    BITS --> POW2[Power of 2]\n    \n    style BITS fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "pointers",
      "label": "Pointers / References",
      "type": "primitive",
      "description": "Addresses pointing to memory locations.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Pointer_(computer_programming)"
          }
        ],
        "community": [
          {
            "title": "YouTube: Pointers in C - CS50",
            "url": "https://www.youtube.com/watch?v=XISnO2YhnsY"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Foundation",
      "categoryIcon": "üß±",
      "content": {
        "definition": {
          "simple": "A pointer stores a memory address. It points to where data lives instead of holding the data itself.",
          "technical": "In JS/Python, objects are accessed via references. Understanding this explains pass-by-reference behavior."
        },
        "howItWorks": {
          "explanation": "Multiple variables can point to the same object. This is fundamental to linked structures.",
          "steps": [
            {
              "step": 1,
              "title": "Reference vs Value",
              "description": "Primitives copied, objects referenced",
              "why": "Both point to same object"
            },
            {
              "step": 2,
              "title": "Null Reference",
              "description": "null means points to nothing",
              "why": "End of linked list"
            }
          ]
        },
        "keyTakeaways": [
          "Primitives copied, objects referenced",
          "Multiple vars can share one object",
          "Mutation affects all references",
          "null = points to nothing"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "memory_model",
              "label": "Memory Model",
              "why": "What addresses are"
            }
          ],
          "nextTopics": [
            {
              "id": "linked_list",
              "label": "Linked Lists",
              "why": "Apply pointers"
            }
          ]
        }
      }
    },
    {
      "id": "array",
      "label": "Array",
      "type": "ds-linear",
      "description": "Contiguous memory blocks.",
      "references": {
        "official": [
          {
            "title": "MDN Web Docs",
            "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/array"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/array/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/array-data-structure/"
          }
        ]
      },
      "difficulty": 1,
      "timeEstimate": "1 hour",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft",
        "Apple"
      ],
      "interviewFrequency": "high",
      "category": "Linear DS",
      "categoryIcon": "üìä",
      "interviewQuestions": [
        {
          "name": "Two Sum",
          "leetcode": "https://leetcode.com/problems/two-sum/",
          "difficulty": "Easy",
          "companies": [
            "Google",
            "Amazon",
            "Meta",
            "Apple",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Tests hash map usage for O(n) lookup, basic problem-solving approach",
          "approach": "Use hash map to store complement. For each num, check if target-num exists. O(n) time, O(n) space",
          "followUps": [
            {
              "question": "What if array is sorted? (Two pointers)",
              "answer": "Use two pointers at start and end. If sum < target, move left pointer right. If sum > target, move right pointer left. O(n) time, O(1) space."
            },
            {
              "question": "Return all pairs?",
              "answer": "Use hash map, but store all indices for each value. For each number, check if complement exists and collect all valid pairs. Handle duplicates carefully."
            },
            {
              "question": "What about duplicates?",
              "answer": "Hash map still works - store first occurrence index. For all pairs with duplicates, track seen numbers in a set to avoid duplicate pairs."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "Best Time to Buy and Sell Stock",
          "leetcode": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
          "difficulty": "Easy",
          "companies": [
            "Amazon",
            "Meta",
            "Google",
            "Goldman Sachs"
          ],
          "frequency": "Very High",
          "whyAsked": "Tests ability to track running minimum and max profit in single pass",
          "approach": "Track minPrice so far, calculate profit at each step, keep maxProfit. O(n) time, O(1) space",
          "followUps": [
            {
              "question": "Multiple transactions allowed?",
              "answer": "Sum all positive differences: profit += max(0, prices[i] - prices[i-1]). Buy and sell on same day effectively."
            },
            {
              "question": "With cooldown?",
              "answer": "State machine DP: hold[i], sold[i], rest[i]. Transitions between states based on action."
            },
            {
              "question": "With transaction fee?",
              "answer": "Same as multiple transactions but subtract fee when selling: profit += max(0, prices[i] - prices[i-1] - fee)."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "Product of Array Except Self",
          "leetcode": "https://leetcode.com/problems/product-of-array-except-self/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Apple",
            "Microsoft"
          ],
          "frequency": "High",
          "whyAsked": "Tests prefix/suffix product technique without division",
          "approach": "Two passes: left products, then right products. Combine for result. O(n) time, O(1) extra space",
          "followUps": [
            {
              "question": "Can you do it in O(1) space?",
              "answer": "Use output array for left products, then single pass from right multiplying in place. Only output array (doesn't count as extra)."
            },
            {
              "question": "What if zeros exist?",
              "answer": "Track count and position of zeros. If >1 zero, all products are 0. If exactly 1 zero, only that position has non-zero product."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Maximum Subarray (Kadane's)",
          "leetcode": "https://leetcode.com/problems/maximum-subarray/",
          "difficulty": "Medium",
          "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "LinkedIn",
            "Flipkart",
            "Paytm"
          ],
          "frequency": "Very High",
          "whyAsked": "Classic DP problem, tests understanding of local vs global optimum",
          "approach": "Kadane's Algorithm: maxEndingHere = max(num, maxEndingHere + num). Track global max. O(n)",
          "followUps": [
            {
              "question": "Return the subarray indices?",
              "answer": "Track start index. When resetting maxEndingHere, update start. When updating global max, record start and end indices."
            },
            {
              "question": "Circular array variant?",
              "answer": "Answer is max of: (1) normal Kadane's, or (2) total sum - minimum subarray sum (wrap-around case)."
            },
            {
              "question": "2D matrix version?",
              "answer": "For each pair of rows, compress to 1D array and apply Kadane's. O(n¬≤m) for n√óm matrix."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "Container With Most Water",
          "leetcode": "https://leetcode.com/problems/container-with-most-water/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Goldman Sachs"
          ],
          "frequency": "High",
          "whyAsked": "Tests two-pointer technique and greedy reasoning",
          "approach": "Two pointers from ends. Move the shorter one inward (can only improve). O(n) time",
          "followUps": [
            {
              "question": "Prove why greedy works",
              "answer": "Moving shorter line can only potentially improve area. Moving taller line can only decrease area (width decreases, height can't increase beyond shorter)."
            },
            {
              "question": "What about trapping rain water?",
              "answer": "Different problem: for each position, water = min(maxLeft, maxRight) - height. Use two pointers or precompute maxLeft/maxRight arrays."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Majority Element",
          "leetcode": "https://leetcode.com/problems/majority-element/",
          "difficulty": "Easy",
          "companies": [
            "Flipkart",
            "Amazon",
            "Google",
            "Microsoft"
          ],
          "frequency": "High",
          "whyAsked": "Tests Boyer-Moore Voting Algorithm - O(1) space counting",
          "approach": "Boyer-Moore: maintain candidate and count. If count=0, new candidate. If same, count++, else count--",
          "followUps": [
            {
              "question": "Majority Element II (> n/3)?",
              "answer": "At most 2 elements can appear > n/3 times. Use two candidates and two counts. Verify at end."
            },
            {
              "question": "Prove Boyer-Moore works",
              "answer": "Majority element appears > n/2 times. Even if all others cancel it, count remains positive."
            }
          ],
          "sources": [
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Count Inversions",
          "gfg": "https://www.geeksforgeeks.org/problems/inversion-of-array-1587115620/1",
          "difficulty": "Medium",
          "companies": [
            "Flipkart",
            "Amazon",
            "Microsoft",
            "Goldman Sachs"
          ],
          "frequency": "High",
          "whyAsked": "Modified merge sort - counting while merging",
          "approach": "During merge sort, when right element < left element, count += (mid - leftIdx + 1). O(n log n)",
          "followUps": [
            {
              "question": "Count smaller numbers after self?",
              "answer": "Similar merge sort approach or use BST/BIT. Track count of smaller elements during insertion."
            }
          ],
          "sources": [
            "gfg"
          ],
          "sourceDetails": [
            {
              "name": "GeeksforGeeks",
              "url": "https://www.geeksforgeeks.org/explore?company=Flipkart",
              "note": "Top Flipkart problem"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based problem categorization"
        },
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with video explanations"
        }
      ],
      "content": {
        "definition": {
          "simple": "An array is a list of items stored in a row, where each item has a numbered position (index) starting from 0.",
          "technical": "An array is a contiguous block of memory that stores elements of the same type. Each element is accessible in O(1) time via its index, which is calculated as: address = baseAddress + (index √ó elementSize)."
        },
        "howItWorks": {
          "explanation": "Imagine a row of numbered mailboxes. Each mailbox (index) holds one letter (value). To get letter #5, you walk directly to mailbox 5 - you don't check boxes 0-4. That's O(1) access. But if you want to insert a new mailbox in the middle, everyone after it has to shift down - that's O(n).",
          "steps": [
            {
              "step": 1,
              "title": "Memory Allocation",
              "description": "When you create an array, a contiguous block of memory is reserved. For 5 integers (4 bytes each), you get 20 bytes in a row.",
              "why": "Contiguous memory enables O(1) access - we can calculate any element's address instantly."
            },
            {
              "step": 2,
              "title": "Index Calculation",
              "description": "To access arr[i], the CPU calculates: address = baseAddress + (i √ó elementSize). No searching required.",
              "why": "This arithmetic is constant time, regardless of array size."
            },
            {
              "step": 3,
              "title": "Insertion/Deletion",
              "description": "To insert at index i, all elements from i onward must shift right. To delete, they shift left.",
              "why": "This is why insertion/deletion is O(n) - we may need to move n elements."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff', 'primaryBorderColor': '#3d5a80', 'lineColor': '#3d5a80', 'secondaryColor': '#ee6c4d', 'tertiaryColor': '#98c1d9'}}}%%\nflowchart LR\n    subgraph Memory[\"Contiguous Memory Block\"]\n        A0[\"[0]: 10\\n0x100\"]\n        A1[\"[1]: 20\\n0x104\"]\n        A2[\"[2]: 30\\n0x108\"]\n        A3[\"[3]: 40\\n0x10C\"]\n        A4[\"[4]: 50\\n0x110\"]\n    end\n    \n    IDX[\"arr[2]\"] -->|\"0x100 + 2√ó4 = 0x108\"| A2\n    \n    style A2 fill:#ee6c4d",
            "caption": "Array elements stored contiguously. arr[2] found instantly via address calculation."
          }
        },
        "whenToUse": {
          "summary": "Use arrays when you need fast access by index and know the size upfront (or dynamic arrays when size changes).",
          "patterns": [
            {
              "pattern": "Random Access",
              "signal": "Need to access elements by position frequently",
              "example": "Get the 5th highest score",
              "withoutIt": "O(n) with linked list - must traverse from head",
              "withIt": "O(1) - direct index access"
            },
            {
              "pattern": "Iteration",
              "signal": "Process all elements in order",
              "example": "Sum all values, find max/min",
              "withoutIt": "Same O(n), but arrays have better cache locality",
              "withIt": "O(n) with CPU cache benefits"
            },
            {
              "pattern": "Stack/Queue Base",
              "signal": "Need LIFO or FIFO with fast operations",
              "example": "Function call stack, BFS queue",
              "withoutIt": "Linked list works but more memory overhead",
              "withIt": "Arrays are often used internally for efficiency"
            },
            {
              "pattern": "Sorting & Searching",
              "signal": "Need to sort data or binary search",
              "example": "Sort leaderboard, find value in sorted data",
              "withoutIt": "Linked lists can't binary search efficiently",
              "withIt": "O(n log n) sort, O(log n) binary search"
            },
            {
              "pattern": "Two Pointers / Sliding Window",
              "signal": "Process array with multiple indices",
              "example": "Find pair with sum, longest substring",
              "withoutIt": "These patterns don't work well with linked lists",
              "withIt": "O(1) access at any pointer position"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Arrays struggle with frequent insertions/deletions in the middle and unknown sizes.",
          "antiPatterns": [
            {
              "situation": "Frequent Middle Insertions/Deletions",
              "why": "Each operation is O(n) due to shifting",
              "useInstead": "Linked List (O(1) insert/delete with pointer)",
              "example": "Text editor with cursor in middle of document"
            },
            {
              "situation": "Unknown or Highly Variable Size",
              "why": "Static arrays can't grow; dynamic arrays have resize overhead",
              "useInstead": "Linked List or allocate with buffer",
              "example": "Stream of unknown length"
            },
            {
              "situation": "Need Fast Lookup by Value (not index)",
              "why": "Finding a value requires O(n) scan",
              "useInstead": "Hash Map for O(1) lookup by key",
              "example": "Check if username exists"
            },
            {
              "situation": "Sparse Data with Gaps",
              "why": "Arrays waste memory for unused indices",
              "useInstead": "Hash Map with only present keys",
              "example": "Store data for years 1900, 1950, 2000 (not 1901-1999)"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Train Analogy",
            "story": "An array is like a train with numbered cars. Car 0, Car 1, Car 2... To find someone in Car 7, you don't walk through Cars 0-6 - you just go directly to Car 7. That's O(1) access! But if you want to add a new car between Car 3 and Car 4, you have to renumber Cars 4, 5, 6... all the way to the end. That's O(n) insertion.",
            "connection": "The train cars are memory slots. The numbers are indices. Direct access = O(1). Renumbering = shifting = O(n)."
          },
          "keyInsight": "Arrays trade insertion flexibility for access speed. The contiguous memory layout means instant access but painful rearrangement.",
          "commonConfusion": [
            {
              "confusion": "Why is accessing arr[1000000] still O(1)?",
              "clarification": "Because it's just arithmetic: baseAddress + 1000000 √ó elementSize. The CPU doesn't 'walk' through a million elements - it calculates the address directly."
            },
            {
              "confusion": "Why do we say arrays are 'fixed size' when JavaScript arrays grow?",
              "clarification": "JavaScript 'arrays' are actually objects (hash maps). True arrays in lower-level languages (C, Java primitives) have fixed size. Dynamic arrays (ArrayList, vector) resize by creating a new larger array and copying - that's O(n) but amortized O(1) per insert."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Access by index",
                "average": "O(1)",
                "worst": "O(1)",
                "note": "Direct address calculation"
              },
              {
                "operation": "Search by value",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Must scan all elements"
              },
              {
                "operation": "Insert at end",
                "average": "O(1)*",
                "worst": "O(n)",
                "note": "*Amortized for dynamic arrays"
              },
              {
                "operation": "Insert at beginning",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Shift all elements right"
              },
              {
                "operation": "Insert at middle",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Shift elements after index"
              },
              {
                "operation": "Delete at end",
                "average": "O(1)",
                "worst": "O(1)",
                "note": "Just decrement length"
              },
              {
                "operation": "Delete at beginning",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Shift all elements left"
              },
              {
                "operation": "Delete at middle",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Shift elements after index"
              }
            ],
            "explanation": "Access is O(1) due to index arithmetic. Insertions/deletions are O(n) because elements must shift to maintain contiguity."
          },
          "space": {
            "complexity": "O(n)",
            "explanation": "Need space for n elements. Dynamic arrays may have unused capacity (typically 2x current size)."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Arrays allocate a contiguous block of memory. Each element occupies a fixed size (4 bytes for int32, 8 bytes for int64/pointers). The array variable stores the base address.",
            "diagram": {
              "type": "mermaid",
              "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TB\n    subgraph STACK[\"Stack Memory\"]\n        ARR[\"arr: 0x1000\\n(base address)\"]\n        LEN[\"length: 5\"]\n    end\n    \n    subgraph HEAP[\"Heap Memory (contiguous block)\"]\n        M0[\"0x1000: 10\"]\n        M1[\"0x1004: 20\"]\n        M2[\"0x1008: 30\"]\n        M3[\"0x100C: 40\"]\n        M4[\"0x1010: 50\"]\n    end\n    \n    ARR --> M0\n    \n    style M0 fill:#ee6c4d\n    style M1 fill:#ee6c4d\n    style M2 fill:#ee6c4d\n    style M3 fill:#ee6c4d\n    style M4 fill:#ee6c4d",
              "caption": "Array variable on stack holds pointer to contiguous heap block. Each element is 4 bytes apart."
            },
            "keyPoints": [
              "Array variable on STACK holds base address (pointer to first element)",
              "Actual elements stored in CONTIGUOUS block on HEAP",
              "Index math: arr[i] = *(baseAddress + i √ó sizeof(element))",
              "Dynamic arrays track capacity separately from length",
              "Resize creates NEW array and copies - O(n) operation"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "JavaScript 'arrays' are actually objects with integer keys. V8 optimizes dense arrays (no holes) with true array storage, but sparse arrays become hash maps.",
              "gotchas": [
                "arr.length can be set manually (creates sparse array)",
                "Arrays can hold mixed types (less efficient)",
                "delete arr[i] creates a hole, doesn't shift elements",
                "Use arr.splice(i, 1) to actually remove and shift"
              ],
              "memoryTip": "Keep arrays dense and same-type for V8 optimization. Avoid holes."
            },
            "python": {
              "implementation": "Python lists are dynamic arrays of PyObject pointers. Each element is a pointer (8 bytes) to an object elsewhere in memory.",
              "gotchas": [
                "Lists can hold mixed types (all are object pointers)",
                "list.append() is amortized O(1) due to over-allocation",
                "list.insert(0, x) is O(n) - shifts everything",
                "Use collections.deque for O(1) insert at both ends"
              ],
              "memoryTip": "For numeric data, use numpy arrays for true contiguous memory and 10-100x speedup."
            }
          },
          "dynamicArrayResize": {
            "explanation": "When a dynamic array is full, it allocates a new array (usually 2x size) and copies all elements.",
            "steps": [
              "Array has capacity 4, length 4 (full)",
              "Push new element ‚Üí no room!",
              "Allocate new array with capacity 8",
              "Copy all 4 elements to new array: O(n)",
              "Add new element at index 4",
              "Old array is garbage collected",
              "Most pushes are O(1), occasional resize is O(n)",
              "Amortized analysis: O(1) per push on average"
            ]
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Array access is O(1)",
            "proof": {
              "step1": {
                "action": "Know base address (stored in variable)",
                "cost": "O(1)",
                "note": "Just reading a variable"
              },
              "step2": {
                "action": "Calculate offset: index √ó elementSize",
                "cost": "O(1)",
                "note": "Single multiplication"
              },
              "step3": {
                "action": "Add offset to base: baseAddress + offset",
                "cost": "O(1)",
                "note": "Single addition"
              },
              "step4": {
                "action": "Dereference pointer to get value",
                "cost": "O(1)",
                "note": "Direct memory access"
              }
            },
            "totalCost": "O(1) + O(1) + O(1) + O(1) = O(1)"
          },
          "whyInsertionIsOn": {
            "scenario": "Insert at index 0 in array of n elements",
            "trace": [
              {
                "step": 1,
                "action": "Move arr[n-1] to arr[n]",
                "cost": "1 operation"
              },
              {
                "step": 2,
                "action": "Move arr[n-2] to arr[n-1]",
                "cost": "1 operation"
              },
              {
                "step": "...",
                "action": "Continue shifting...",
                "cost": "..."
              },
              {
                "step": "n",
                "action": "Move arr[0] to arr[1]",
                "cost": "1 operation"
              },
              {
                "step": "n+1",
                "action": "Write new value to arr[0]",
                "cost": "1 operation"
              }
            ],
            "total": "n shifts + 1 write = O(n)"
          },
          "traceProof": {
            "title": "Visual: Insert 5 at index 0 in [10, 20, 30]",
            "before": "[10, 20, 30, _]",
            "steps": [
              {
                "step": 1,
                "state": "[10, 20, _, 30]",
                "action": "Shift 30 right"
              },
              {
                "step": 2,
                "state": "[10, _, 20, 30]",
                "action": "Shift 20 right"
              },
              {
                "step": 3,
                "state": "[_, 10, 20, 30]",
                "action": "Shift 10 right"
              },
              {
                "step": 4,
                "state": "[5, 10, 20, 30]",
                "action": "Insert 5 at [0]"
              }
            ],
            "after": "[5, 10, 20, 30]",
            "operations": "3 shifts + 1 insert = 4 operations = O(n)"
          }
        },
        "codeTemplates": [
          {
            "name": "Basic Operations",
            "description": "Create, access, modify, iterate",
            "javascript": {
              "code": "// Create arrays\nconst arr = [1, 2, 3, 4, 5];\nconst empty = new Array(10);  // 10 empty slots\nconst filled = new Array(10).fill(0);  // 10 zeros\n\n// Access & Modify\nconst first = arr[0];         // O(1)\nconst last = arr[arr.length - 1];  // O(1)\narr[2] = 99;                  // O(1)\n\n// Add elements\narr.push(6);                  // O(1) amortized - add to end\narr.unshift(0);               // O(n) - add to start, shifts all\n\n// Remove elements  \narr.pop();                    // O(1) - remove from end\narr.shift();                  // O(n) - remove from start, shifts all\narr.splice(2, 1);             // O(n) - remove at index 2, shifts rest\n\n// Iterate\nfor (let i = 0; i < arr.length; i++) {\n  console.log(arr[i]);\n}\n// or\nfor (const val of arr) {\n  console.log(val);\n}\n// or with index\narr.forEach((val, i) => console.log(i, val));",
              "notes": "push/pop are O(1), shift/unshift/splice are O(n) due to shifting."
            },
            "python": {
              "code": "# Create lists (Python's dynamic arrays)\narr = [1, 2, 3, 4, 5]\nempty = [None] * 10          # 10 None values\nzeros = [0] * 10             # 10 zeros\nmatrix = [[0] * 3 for _ in range(3)]  # 3x3 matrix (use list comp!)\n\n# Access & Modify\nfirst = arr[0]               # O(1)\nlast = arr[-1]               # O(1) - Python supports negative indices!\narr[2] = 99                  # O(1)\n\n# Add elements\narr.append(6)                # O(1) amortized - add to end\narr.insert(0, 0)             # O(n) - add to start, shifts all\n\n# Remove elements\narr.pop()                    # O(1) - remove from end\narr.pop(0)                   # O(n) - remove from start, shifts all\ndel arr[2]                   # O(n) - remove at index 2\n\n# Iterate\nfor val in arr:\n    print(val)\n    \nfor i, val in enumerate(arr):\n    print(i, val)",
              "notes": "Python lists support negative indexing. arr[-1] is last element, arr[-2] is second-to-last."
            }
          },
          {
            "name": "Two Pointers Pattern",
            "description": "Use two indices to solve problems in O(n)",
            "javascript": {
              "code": "// Reverse array in-place\nfunction reverse(arr) {\n  let left = 0, right = arr.length - 1;\n  while (left < right) {\n    [arr[left], arr[right]] = [arr[right], arr[left]];  // swap\n    left++;\n    right--;\n  }\n  return arr;\n}\n\n// Two Sum on SORTED array\nfunction twoSumSorted(nums, target) {\n  let left = 0, right = nums.length - 1;\n  while (left < right) {\n    const sum = nums[left] + nums[right];\n    if (sum === target) return [left, right];\n    if (sum < target) left++;\n    else right--;\n  }\n  return [-1, -1];\n}",
              "notes": "Two pointers works on sorted arrays. Each pointer moves one direction only ‚Üí O(n) total."
            },
            "python": {
              "code": "# Reverse array in-place\ndef reverse(arr):\n    left, right = 0, len(arr) - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    return arr\n\n# Two Sum on SORTED array\ndef two_sum_sorted(nums, target):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        total = nums[left] + nums[right]\n        if total == target:\n            return [left, right]\n        elif total < target:\n            left += 1\n        else:\n            right -= 1\n    return [-1, -1]",
              "notes": "Python tuple swap is clean: a, b = b, a"
            }
          },
          {
            "name": "Prefix Sum Pattern",
            "description": "Precompute cumulative sums for O(1) range queries",
            "javascript": {
              "code": "// Build prefix sum array\nfunction buildPrefixSum(arr) {\n  const prefix = [0];  // prefix[0] = 0 for easier math\n  for (const num of arr) {\n    prefix.push(prefix[prefix.length - 1] + num);\n  }\n  return prefix;\n}\n\n// Get sum of range [left, right] in O(1)\nfunction rangeSum(prefix, left, right) {\n  return prefix[right + 1] - prefix[left];\n}\n\n// Example\nconst arr = [1, 2, 3, 4, 5];\nconst prefix = buildPrefixSum(arr);  // [0, 1, 3, 6, 10, 15]\nconsole.log(rangeSum(prefix, 1, 3)); // sum of [2,3,4] = 9",
              "notes": "Prefix[i] = sum of arr[0..i-1]. Range sum = prefix[right+1] - prefix[left]."
            },
            "python": {
              "code": "from itertools import accumulate\n\n# Build prefix sum\ndef build_prefix_sum(arr):\n    return [0] + list(accumulate(arr))\n\n# Get sum of range [left, right] in O(1)\ndef range_sum(prefix, left, right):\n    return prefix[right + 1] - prefix[left]\n\n# Example\narr = [1, 2, 3, 4, 5]\nprefix = build_prefix_sum(arr)  # [0, 1, 3, 6, 10, 15]\nprint(range_sum(prefix, 1, 3))  # sum of [2,3,4] = 9",
              "notes": "itertools.accumulate is built-in for cumulative operations."
            }
          }
        ],
        "visualTrace": {
          "title": "Two Pointers: Reverse [1, 2, 3, 4, 5]",
          "input": {
            "array": [
              1,
              2,
              3,
              4,
              5
            ]
          },
          "memoryTrace": {
            "description": "Watch pointers move and values swap",
            "execution": [
              {
                "line": "let left = 0, right = 4",
                "memory": {
                  "left": 0,
                  "right": 4,
                  "arr": "[1,2,3,4,5]"
                },
                "visual": "[1, 2, 3, 4, 5]\n L           R",
                "note": "Pointers at opposite ends"
              },
              {
                "line": "swap arr[0], arr[4]",
                "memory": {
                  "left": 0,
                  "right": 4,
                  "arr": "[5,2,3,4,1]"
                },
                "visual": "[5, 2, 3, 4, 1]\n L           R",
                "note": "Swap 1 and 5"
              },
              {
                "line": "left++, right--",
                "memory": {
                  "left": 1,
                  "right": 3,
                  "arr": "[5,2,3,4,1]"
                },
                "visual": "[5, 2, 3, 4, 1]\n    L     R",
                "note": "Move pointers inward"
              },
              {
                "line": "swap arr[1], arr[3]",
                "memory": {
                  "left": 1,
                  "right": 3,
                  "arr": "[5,4,3,2,1]"
                },
                "visual": "[5, 4, 3, 2, 1]\n    L     R",
                "note": "Swap 2 and 4"
              },
              {
                "line": "left++, right--",
                "memory": {
                  "left": 2,
                  "right": 2,
                  "arr": "[5,4,3,2,1]"
                },
                "visual": "[5, 4, 3, 2, 1]\n       LR",
                "note": "Pointers meet at middle - done!"
              }
            ]
          },
          "steps": [
            {
              "step": 1,
              "left": 0,
              "right": 4,
              "array": "[1,2,3,4,5]",
              "action": "Swap 1‚Üî5"
            },
            {
              "step": 2,
              "left": 1,
              "right": 3,
              "array": "[5,2,3,4,1]",
              "action": "Swap 2‚Üî4"
            },
            {
              "step": 3,
              "left": 2,
              "right": 2,
              "array": "[5,4,3,2,1]",
              "action": "Done (left >= right)"
            }
          ],
          "output": "[5, 4, 3, 2, 1]"
        },
        "commonMistakes": [
          {
            "mistake": "Off-by-one error with array length",
            "wrong": "for (let i = 0; i <= arr.length; i++) // Accesses arr[length] = undefined!",
            "right": "for (let i = 0; i < arr.length; i++) // Stops at length - 1",
            "explanation": "Array indices go from 0 to length-1. Using <= includes the invalid index."
          },
          {
            "mistake": "Modifying array while iterating (index issues)",
            "wrong": "for (let i = 0; i < arr.length; i++) { if (cond) arr.splice(i, 1); } // Skips elements!",
            "right": "for (let i = arr.length - 1; i >= 0; i--) { if (cond) arr.splice(i, 1); } // Iterate backwards",
            "explanation": "splice shifts elements left, so next iteration skips an element. Iterate backwards to avoid this."
          },
          {
            "mistake": "Copying array reference instead of values",
            "wrong": "const copy = arr; copy[0] = 99; // Also changes arr[0]!",
            "right": "const copy = [...arr]; // or arr.slice() - creates new array",
            "explanation": "Arrays are reference types. Assignment copies the pointer, not the data."
          },
          {
            "mistake": "Using delete instead of splice",
            "wrong": "delete arr[2]; // Creates hole: [1, 2, empty, 4]",
            "right": "arr.splice(2, 1); // Actually removes: [1, 2, 4]",
            "explanation": "delete removes the value but keeps the slot (creates sparse array). splice shifts elements."
          },
          {
            "mistake": "Creating 2D array incorrectly in Python",
            "wrong": "matrix = [[0] * 3] * 3  // All rows reference SAME list!",
            "right": "matrix = [[0] * 3 for _ in range(3)]  // Independent rows",
            "explanation": "* on a list copies references, not values. Use list comprehension for independent copies."
          }
        ],
        "keyTakeaways": [
          "Arrays give O(1) access because of contiguous memory + index arithmetic",
          "Insertion/deletion is O(n) because elements must shift to stay contiguous",
          "Use arrays for random access, iteration, sorting, two-pointer patterns",
          "Avoid arrays when you need frequent insertions/deletions in the middle",
          "Dynamic arrays (ArrayList, list, Array) resize automatically but have occasional O(n) resize cost",
          "JavaScript 'arrays' are actually objects - keep them dense and same-type for optimization"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "big_o",
              "label": "Big O Notation",
              "why": "Need to understand O(1) vs O(n) trade-offs"
            },
            {
              "id": "memory_model",
              "label": "Memory Model",
              "why": "Understanding stack vs heap helps explain array behavior"
            }
          ],
          "nextTopics": [
            {
              "id": "two_pointers",
              "label": "Two Pointers",
              "why": "Classic pattern that requires O(1) array access"
            },
            {
              "id": "sliding_window",
              "label": "Sliding Window",
              "why": "Another pattern leveraging array indices"
            },
            {
              "id": "binary_search",
              "label": "Binary Search",
              "why": "O(log n) search in sorted arrays"
            },
            {
              "id": "prefix_sum",
              "label": "Prefix Sum",
              "why": "Precomputation pattern for range queries"
            },
            {
              "id": "ll",
              "label": "Linked List",
              "why": "Contrast: O(1) insert but O(n) access"
            }
          ]
        },
        "patternChain": {
          "description": "How Array connects to other patterns in the DSA graph",
          "buildsOn": [
            {
              "id": "memory_model",
              "relationship": "Arrays rely on contiguous memory allocation",
              "whatToKnow": "Understand stack vs heap, pointers, address arithmetic"
            }
          ],
          "enables": [
            {
              "id": "two_pointers",
              "relationship": "Two pointers requires O(1) random access",
              "patternName": "Opposite Direction Pointers",
              "interviewFrequency": "Very High"
            },
            {
              "id": "sliding_window",
              "relationship": "Window boundaries are array indices",
              "patternName": "Fixed/Variable Window",
              "interviewFrequency": "Very High"
            },
            {
              "id": "binary_search",
              "relationship": "Divide and conquer on sorted array",
              "patternName": "Binary Search",
              "interviewFrequency": "Very High"
            },
            {
              "id": "prefix_sum",
              "relationship": "Precompute cumulative sums for O(1) range queries",
              "patternName": "Prefix Sum Array",
              "interviewFrequency": "High"
            },
            {
              "id": "kadane",
              "relationship": "Maximum subarray sum using running sum",
              "patternName": "Kadane's Algorithm",
              "interviewFrequency": "High"
            },
            {
              "id": "sorting",
              "relationship": "Most sorting algorithms operate on arrays",
              "patternName": "Comparison Sorts",
              "interviewFrequency": "Medium"
            }
          ],
          "lineagePath": {
            "description": "Array is the foundation for most sequential data patterns",
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart LR\n    MEM[Memory Model] --> ARR[Array]\n    ARR --> TP[Two Pointers]\n    ARR --> SW[Sliding Window]\n    ARR --> BS[Binary Search]\n    ARR --> PS[Prefix Sum]\n    ARR --> SORT[Sorting]\n    \n    style ARR fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          },
          "relatedPatterns": [
            {
              "id": "ll",
              "relationship": "Opposite trade-off: O(1) insert, O(n) access"
            },
            {
              "id": "stack",
              "relationship": "Often implemented with array (push/pop at end)"
            },
            {
              "id": "queue",
              "relationship": "Can use array but circular buffer is better for dequeue"
            }
          ]
        }
      }
    },
    {
      "id": "ll",
      "label": "Linked List",
      "type": "ds-linear",
      "description": "Nodes connected by pointers.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Linked_list"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/list"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/linked-list/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/data-structures/linked-list/"
          }
        ]
      },
      "difficulty": 2,
      "timeEstimate": "2 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft"
      ],
      "interviewFrequency": "high",
      "category": "Linear DS",
      "categoryIcon": "üìä",
      "interviewQuestions": [
        {
          "name": "Reverse Linked List",
          "leetcode": "https://leetcode.com/problems/reverse-linked-list/",
          "difficulty": "Easy",
          "companies": [
            "Amazon",
            "Microsoft",
            "Apple",
            "Google",
            "Meta"
          ],
          "frequency": "Very High",
          "whyAsked": "Fundamental pointer manipulation, building block for harder problems",
          "approach": "Iterative: prev, curr, next pointers. Or recursive. O(n) time, O(1) space iterative",
          "followUps": [
            {
              "question": "Reverse in groups of k?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Reverse between positions m and n?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "Reverse Nodes in k-Group",
          "leetcode": "https://leetcode.com/problems/reverse-nodes-in-k-group/",
          "difficulty": "Hard",
          "companies": [
            "Paytm",
            "Flipkart",
            "Amazon",
            "Microsoft",
            "Google"
          ],
          "frequency": "High",
          "whyAsked": "Tests ability to combine reversal logic with group management",
          "approach": "Count k nodes ahead. Reverse k nodes iteratively. Connect groups. Handle remaining nodes (<k).",
          "followUps": [
            {
              "question": "Reverse alternating k groups?",
              "answer": "Skip every other group by not reversing it, just moving pointers forward."
            },
            {
              "question": "Reverse last group even if < k?",
              "answer": "Track if last group, then reverse regardless of size."
            }
          ],
          "sources": [
            "neetcode150",
            "gfg"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "GeeksforGeeks",
              "url": "https://www.geeksforgeeks.org/reverse-a-linked-list-in-groups-of-given-size/",
              "note": "Top Paytm problem"
            }
          ]
        },
        {
          "name": "Merge Two Sorted Lists",
          "leetcode": "https://leetcode.com/problems/merge-two-sorted-lists/",
          "difficulty": "Easy",
          "companies": [
            "Amazon",
            "Microsoft",
            "Google",
            "Meta"
          ],
          "frequency": "Very High",
          "whyAsked": "Tests pointer manipulation and merge logic (also used in merge sort)",
          "approach": "Dummy head, compare and link smaller node. O(n + m) time, O(1) space",
          "followUps": [
            {
              "question": "Merge k sorted lists?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "In-place merge?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "Linked List Cycle",
          "leetcode": "https://leetcode.com/problems/linked-list-cycle/",
          "difficulty": "Easy",
          "companies": [
            "Amazon",
            "Microsoft",
            "Apple",
            "Google"
          ],
          "frequency": "High",
          "whyAsked": "Floyd's cycle detection (slow/fast pointers)",
          "approach": "Slow pointer moves 1 step, fast moves 2. If they meet, cycle exists. O(n) time, O(1) space",
          "followUps": [
            {
              "question": "Find cycle start?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Find cycle length?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "Merge K Sorted Lists",
          "leetcode": "https://leetcode.com/problems/merge-k-sorted-lists/",
          "difficulty": "Hard",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Microsoft",
            "Uber"
          ],
          "frequency": "Very High",
          "whyAsked": "Tests min-heap usage OR divide & conquer merge",
          "approach": "Min-heap with k elements, always pop smallest. O(n log k). Or D&C merge pairs",
          "followUps": [
            {
              "question": "External merge sort for files?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Parallelize?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Reorder List",
          "leetcode": "https://leetcode.com/problems/reorder-list/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Meta",
            "Microsoft"
          ],
          "frequency": "Medium",
          "whyAsked": "Combines find middle, reverse, and merge - tests multiple techniques",
          "approach": "Find middle (slow/fast), reverse second half, merge alternating. O(n) time, O(1) space",
          "followUps": [
            {
              "question": "Different reorder pattern?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based problem categorization"
        },
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with video explanations"
        }
      ],
      "content": {
        "definition": {
          "simple": "A linked list is like a treasure hunt - each clue (node) has data plus directions to the next clue. You follow the chain from start to end.",
          "technical": "A linked list is a linear data structure where elements (nodes) are stored in non-contiguous memory. Each node contains data and a pointer (reference) to the next node. This enables O(1) insertion/deletion but O(n) access."
        },
        "howItWorks": {
          "explanation": "Imagine a scavenger hunt where each clue tells you where to find the next clue. You can't jump to clue #5 directly - you must follow clues 1‚Üí2‚Üí3‚Üí4‚Üí5. But if you want to add a new clue between #3 and #4, you just update clue #3 to point to the new one. No need to renumber anything!",
          "steps": [
            {
              "step": 1,
              "title": "Node Structure",
              "description": "Each node contains: (1) data/value and (2) pointer to next node. The last node points to null.",
              "why": "This self-referential structure allows nodes to live anywhere in memory."
            },
            {
              "step": 2,
              "title": "Head Pointer",
              "description": "We keep a pointer to the first node (head). This is our entry point to the list.",
              "why": "Without the head, we'd lose access to the entire list."
            },
            {
              "step": 3,
              "title": "Traversal",
              "description": "To find element #n, start at head and follow 'next' pointers n times.",
              "why": "No index arithmetic like arrays - we must walk the chain. That's O(n)."
            },
            {
              "step": 4,
              "title": "Insertion/Deletion",
              "description": "To insert: create node, set its next to target's next, update target's next to new node. Just pointer changes!",
              "why": "No shifting elements - only 2-3 pointer updates. That's O(1) if you have the position."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff', 'primaryBorderColor': '#3d5a80', 'lineColor': '#3d5a80', 'secondaryColor': '#ee6c4d', 'tertiaryColor': '#98c1d9'}}}%%\nflowchart LR\n    HEAD[\"head\"] --> N1\n    N1[\"10 | next\"] --> N2[\"20 | next\"] --> N3[\"30 | next\"] --> NULL[\"null\"]\n    \n    style N1 fill:#1e3a5f,color:#fff\n    style N2 fill:#1e3a5f,color:#fff\n    style N3 fill:#1e3a5f,color:#fff",
            "caption": "Singly linked list: head points to first node, each node points to next, last points to null"
          }
        },
        "whenToUse": {
          "summary": "Use linked lists when you need frequent insertions/deletions at known positions, or when memory can't be contiguous.",
          "patterns": [
            {
              "pattern": "Frequent Insertions/Deletions in Middle",
              "signal": "Adding/removing elements at arbitrary positions often",
              "example": "Text editor cursor operations, undo/redo history",
              "withoutIt": "Array: O(n) shift on every insert/delete",
              "withIt": "O(1) pointer update (if you have the node reference)"
            },
            {
              "pattern": "Unknown or Highly Variable Size",
              "signal": "Can't predict how large the data will grow",
              "example": "Memory allocator free list, dynamic task queue",
              "withoutIt": "Array: resize copies all elements O(n)",
              "withIt": "Just create new node and link it O(1)"
            },
            {
              "pattern": "Implementation of Other DS",
              "signal": "Building stacks, queues, or hash map chains",
              "example": "Hash map collision chaining, LRU cache",
              "withoutIt": "Array-based alternatives exist but trade-offs differ",
              "withIt": "Natural fit for chained structures"
            },
            {
              "pattern": "Two-Pointer Linked List Problems",
              "signal": "Detect cycle, find middle, reverse list",
              "example": "Floyd's cycle detection, merge two sorted lists",
              "withoutIt": "N/A - these are linked list specific patterns",
              "withIt": "Classic interview patterns"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Linked lists have poor cache locality and no random access. Avoid when you need fast lookups.",
          "antiPatterns": [
            {
              "situation": "Need Random Access by Index",
              "why": "Must traverse from head - O(n) for every access",
              "useInstead": "Array for O(1) index access",
              "example": "Accessing player scores by rank"
            },
            {
              "situation": "Need Binary Search",
              "why": "Can't jump to middle in O(1)",
              "useInstead": "Sorted array for O(log n) binary search",
              "example": "Searching sorted data frequently"
            },
            {
              "situation": "Memory/Cache Efficiency Matters",
              "why": "Nodes scattered in memory = cache misses = slow",
              "useInstead": "Array (contiguous memory = cache-friendly)",
              "example": "High-performance number crunching"
            },
            {
              "situation": "Simple Stack/Queue Operations",
              "why": "Array-based implementations are often faster in practice",
              "useInstead": "Array with push/pop at end (stack) or circular buffer (queue)",
              "example": "Modern JS uses arrays for stack/queue"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Train Cars Analogy",
            "story": "A linked list is like a train where each car knows only about the car behind it. The engine (head) connects to the first car, that car connects to the second, and so on. To find car #5, the conductor walks from engine through cars 1-4. But if you want to add a new car between #3 and #4, you just unhook #3 from #4, hook the new car to both - no renumbering needed!",
            "connection": "Unlike arrays (numbered parking spots), linked lists use physical connections (pointers). This makes rearranging easy but random access slow."
          },
          "keyInsight": "Linked lists trade ACCESS SPEED for INSERTION/DELETION SPEED. Arrays: O(1) access, O(n) insert. Linked lists: O(n) access, O(1) insert (at known position).",
          "commonConfusion": [
            {
              "confusion": "Why O(1) insert when you still need O(n) to find the position?",
              "clarification": "O(1) insert assumes you ALREADY HAVE a pointer to the node. Finding that node is O(n). In patterns like 'delete node given pointer to it', you don't need to traverse first."
            },
            {
              "confusion": "Why use linked lists when arrays exist?",
              "clarification": "1) Frequent mid-list insertions (text editors). 2) Building other DS (hash chains, LRU cache). 3) Memory fragmentation (can use scattered blocks). 4) Interview patterns!"
            },
            {
              "confusion": "What's the difference between singly and doubly linked?",
              "clarification": "Singly: each node has 'next' only. Can only traverse forward. Doubly: each node has 'next' AND 'prev'. Can traverse both ways. Doubly uses more memory but enables O(1) delete if you have the node."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Access by index",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Must traverse from head"
              },
              {
                "operation": "Search by value",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Must traverse until found"
              },
              {
                "operation": "Insert at head",
                "average": "O(1)",
                "worst": "O(1)",
                "note": "Just update head pointer"
              },
              {
                "operation": "Insert at tail",
                "average": "O(1)*",
                "worst": "O(n)",
                "note": "*O(1) if tail pointer maintained"
              },
              {
                "operation": "Insert at middle",
                "average": "O(1)*",
                "worst": "O(1)*",
                "note": "*O(1) if have node reference, else O(n) to find"
              },
              {
                "operation": "Delete at head",
                "average": "O(1)",
                "worst": "O(1)",
                "note": "Just update head pointer"
              },
              {
                "operation": "Delete at tail",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Need to find second-to-last (singly linked)"
              },
              {
                "operation": "Delete at middle",
                "average": "O(1)*",
                "worst": "O(1)*",
                "note": "*If have node reference; else O(n) to find"
              }
            ],
            "explanation": "Access is O(n) because we must traverse. Insert/delete is O(1) IF we have the node pointer - no shifting needed, just pointer updates."
          },
          "space": {
            "complexity": "O(n)",
            "explanation": "n nodes, each with data + pointer(s). Extra overhead: 4-8 bytes per node for next pointer, another 4-8 for prev in doubly linked."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Unlike arrays, linked list nodes are scattered in memory. Each node stores data + pointer to next. The 'next' pointer holds the memory address of the next node.",
            "diagram": {
              "type": "mermaid",
              "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TB\n    subgraph STACK[\"Stack Memory\"]\n        HEAD[\"head: 0x1000\"]\n    end\n    \n    subgraph HEAP[\"Heap Memory (scattered)\"]\n        N1[\"0x1000:\\ndata: 10\\nnext: 0x2048\"]\n        N2[\"0x2048:\\ndata: 20\\nnext: 0x1500\"]\n        N3[\"0x1500:\\ndata: 30\\nnext: null\"]\n    end\n    \n    HEAD --> N1\n    N1 --> N2\n    N2 --> N3\n    \n    style N1 fill:#ee6c4d\n    style N2 fill:#3d5a80\n    style N3 fill:#98c1d9",
              "caption": "Nodes at random memory addresses. Pointers (0x...) link them together. Not contiguous like arrays!"
            },
            "keyPoints": [
              "Each node is independently allocated on HEAP",
              "Nodes can be ANYWHERE in memory (not contiguous)",
              "'next' stores the ADDRESS of the next node",
              "Last node's 'next' is null (end of list)",
              "Losing the head pointer = losing entire list (memory leak)",
              "Cache unfriendly: following pointers causes cache misses"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "No built-in LinkedList class. Implement with plain objects: {val: 10, next: null}. Or use a class.",
              "gotchas": [
                "Objects are reference types - assignment copies pointer, not node",
                "Setting node = node.next doesn't modify original node",
                "Memory managed by garbage collector - no manual free needed",
                "Circular references are OK - GC handles them"
              ],
              "memoryTip": "Objects have overhead. For small data, array might be more memory efficient despite linked list semantics."
            },
            "python": {
              "implementation": "No built-in LinkedList. Use collections.deque for doubly-linked list behavior, or implement with classes.",
              "gotchas": [
                "Python's list is NOT a linked list - it's a dynamic array",
                "collections.deque is implemented as a doubly-linked list of blocks",
                "Class-based nodes: use __slots__ = ['val', 'next'] to save memory",
                "Circular references: handled by Python's cycle-detecting GC"
              ],
              "memoryTip": "collections.deque is optimized for append/popleft. Use it for queue, not list."
            }
          },
          "typesOfLinkedLists": {
            "singlyLinked": {
              "structure": "Node has: data, next",
              "pros": "Simple, less memory",
              "cons": "Can only traverse forward, O(n) delete at tail",
              "useFor": "Stacks, hash chains, simple traversal"
            },
            "doublyLinked": {
              "structure": "Node has: data, next, prev",
              "pros": "Bidirectional traversal, O(1) delete if have node",
              "cons": "More memory per node, more pointers to maintain",
              "useFor": "LRU cache, browser history, undo/redo"
            },
            "circular": {
              "structure": "Tail's next points to head (no null)",
              "pros": "Can traverse infinitely, useful for round-robin",
              "cons": "Need careful termination condition",
              "useFor": "Round-robin scheduling, circular buffers"
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Insert after a given node is O(1)",
            "proof": {
              "step1": {
                "action": "Create new node",
                "cost": "O(1)",
                "note": "Allocate memory, set data"
              },
              "step2": {
                "action": "newNode.next = current.next",
                "cost": "O(1)",
                "note": "One pointer assignment"
              },
              "step3": {
                "action": "current.next = newNode",
                "cost": "O(1)",
                "note": "One pointer assignment"
              }
            },
            "totalCost": "O(1) + O(1) + O(1) = O(1)"
          },
          "whyAccessIsOn": {
            "scenario": "Access element at index n in linked list",
            "trace": [
              {
                "step": 1,
                "action": "Start at head",
                "position": 0
              },
              {
                "step": 2,
                "action": "Follow next pointer",
                "position": 1
              },
              {
                "step": 3,
                "action": "Follow next pointer",
                "position": 2
              },
              {
                "step": "...",
                "action": "Continue n times...",
                "position": "..."
              },
              {
                "step": "n",
                "action": "Arrive at target",
                "position": "n"
              }
            ],
            "total": "n pointer traversals = O(n)"
          },
          "traceProof": {
            "title": "Insert 15 after node with value 10",
            "before": "10 ‚Üí 20 ‚Üí 30 ‚Üí null",
            "steps": [
              {
                "step": 1,
                "action": "Create new node with value 15",
                "state": "newNode(15)"
              },
              {
                "step": 2,
                "action": "newNode.next = node10.next (which is 20)",
                "state": "15 ‚Üí 20"
              },
              {
                "step": 3,
                "action": "node10.next = newNode",
                "state": "10 ‚Üí 15 ‚Üí 20 ‚Üí 30 ‚Üí null"
              }
            ],
            "after": "10 ‚Üí 15 ‚Üí 20 ‚Üí 30 ‚Üí null",
            "operations": "3 operations regardless of list size = O(1)"
          }
        },
        "codeTemplates": [
          {
            "name": "Node Class & Basic Operations",
            "description": "Define node structure, create list, traverse",
            "javascript": {
              "code": "// Node class\nclass ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\n// Create linked list from array\nfunction createList(arr) {\n  const dummy = new ListNode();\n  let curr = dummy;\n  for (const val of arr) {\n    curr.next = new ListNode(val);\n    curr = curr.next;\n  }\n  return dummy.next;\n}\n\n// Traverse and print\nfunction printList(head) {\n  const values = [];\n  while (head) {\n    values.push(head.val);\n    head = head.next;\n  }\n  console.log(values.join(' ‚Üí '));\n}\n\n// Example\nconst list = createList([1, 2, 3, 4, 5]);\nprintList(list);  // 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5",
              "notes": "Dummy node pattern: create temporary head to simplify edge cases."
            },
            "python": {
              "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n# Create linked list from array\ndef create_list(arr):\n    dummy = ListNode()\n    curr = dummy\n    for val in arr:\n        curr.next = ListNode(val)\n        curr = curr.next\n    return dummy.next\n\n# Traverse and print\ndef print_list(head):\n    values = []\n    while head:\n        values.append(str(head.val))\n        head = head.next\n    print(' ‚Üí '.join(values))\n\n# Example\nlst = create_list([1, 2, 3, 4, 5])\nprint_list(lst)  # 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5",
              "notes": "Python uses None instead of null. __init__ is the constructor."
            }
          },
          {
            "name": "Reverse Linked List",
            "description": "Classic interview problem - reverse in-place O(1) space",
            "javascript": {
              "code": "function reverseList(head) {\n  let prev = null;\n  let curr = head;\n  \n  while (curr) {\n    const next = curr.next;  // Save next before overwriting\n    curr.next = prev;        // Reverse the link\n    prev = curr;             // Move prev forward\n    curr = next;             // Move curr forward\n  }\n  \n  return prev;  // prev is new head\n}\n\n// Visual trace:\n// Initial: null  1 ‚Üí 2 ‚Üí 3 ‚Üí null\n//                ‚Üë\n//              prev curr\n//\n// Step 1:  null ‚Üê 1   2 ‚Üí 3 ‚Üí null\n//                 ‚Üë   ‚Üë\n//               prev curr\n//\n// Step 2:  null ‚Üê 1 ‚Üê 2   3 ‚Üí null\n//                     ‚Üë   ‚Üë\n//                   prev curr\n//\n// Step 3:  null ‚Üê 1 ‚Üê 2 ‚Üê 3   null\n//                         ‚Üë   ‚Üë\n//                       prev curr",
              "notes": "Key: save next before overwriting curr.next. Three pointers: prev, curr, next."
            },
            "python": {
              "code": "def reverse_list(head):\n    prev = None\n    curr = head\n    \n    while curr:\n        next_node = curr.next  # Save next\n        curr.next = prev       # Reverse link\n        prev = curr            # Move prev forward\n        curr = next_node       # Move curr forward\n    \n    return prev  # New head\n\n# Recursive version\ndef reverse_list_recursive(head):\n    if not head or not head.next:\n        return head\n    \n    new_head = reverse_list_recursive(head.next)\n    head.next.next = head  # Reverse the link\n    head.next = None       # Avoid cycle\n    \n    return new_head",
              "notes": "Iterative is O(1) space. Recursive is O(n) space due to call stack."
            }
          },
          {
            "name": "Detect Cycle (Floyd's Algorithm)",
            "description": "Use slow/fast pointers to detect cycle in O(1) space",
            "javascript": {
              "code": "function hasCycle(head) {\n  let slow = head;\n  let fast = head;\n  \n  while (fast && fast.next) {\n    slow = slow.next;       // Move 1 step\n    fast = fast.next.next;  // Move 2 steps\n    \n    if (slow === fast) {\n      return true;  // They met = cycle exists\n    }\n  }\n  \n  return false;  // Fast reached end = no cycle\n}\n\n// Find where cycle begins\nfunction detectCycle(head) {\n  let slow = head, fast = head;\n  \n  // First: detect if cycle exists\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow === fast) break;\n  }\n  \n  if (!fast || !fast.next) return null;  // No cycle\n  \n  // Second: find cycle start\n  slow = head;\n  while (slow !== fast) {\n    slow = slow.next;\n    fast = fast.next;  // Both move 1 step now\n  }\n  \n  return slow;  // Cycle starts here\n}",
              "notes": "Why it works: in a cycle, fast gains 1 step per iteration, so they must meet within cycle length iterations."
            },
            "python": {
              "code": "def has_cycle(head):\n    slow = fast = head\n    \n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    \n    return False\n\ndef detect_cycle(head):\n    slow = fast = head\n    \n    # Detect cycle\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            break\n    else:\n        return None  # No cycle\n    \n    # Find start of cycle\n    slow = head\n    while slow != fast:\n        slow = slow.next\n        fast = fast.next\n    \n    return slow",
              "notes": "Floyd's tortoise and hare. O(n) time, O(1) space."
            }
          },
          {
            "name": "Find Middle Node",
            "description": "Slow/fast pointer pattern - fast reaches end when slow is at middle",
            "javascript": {
              "code": "function findMiddle(head) {\n  let slow = head;\n  let fast = head;\n  \n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  \n  return slow;  // slow is at middle\n}\n\n// For even length: returns second middle\n// 1 ‚Üí 2 ‚Üí 3 ‚Üí 4: returns 3\n// For first middle, use: while (fast.next && fast.next.next)\n\n// Useful for merge sort on linked lists\nfunction sortList(head) {\n  if (!head || !head.next) return head;\n  \n  // Find middle and split\n  let slow = head, fast = head, prev = null;\n  while (fast && fast.next) {\n    prev = slow;\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  prev.next = null;  // Split the list\n  \n  // Recursively sort both halves\n  const left = sortList(head);\n  const right = sortList(slow);\n  \n  // Merge sorted halves\n  return mergeTwoLists(left, right);\n}",
              "notes": "When fast reaches end, slow is at middle (fast travels 2x speed)."
            },
            "python": {
              "code": "def find_middle(head):\n    slow = fast = head\n    \n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    return slow\n\n# Merge two sorted lists (useful pattern)\ndef merge_two_lists(l1, l2):\n    dummy = ListNode()\n    curr = dummy\n    \n    while l1 and l2:\n        if l1.val <= l2.val:\n            curr.next = l1\n            l1 = l1.next\n        else:\n            curr.next = l2\n            l2 = l2.next\n        curr = curr.next\n    \n    curr.next = l1 or l2  # Append remaining\n    return dummy.next",
              "notes": "Merge pattern uses dummy head. curr.next = l1 or l2 appends whichever isn't None."
            }
          }
        ],
        "visualTrace": {
          "title": "Reverse: 1 ‚Üí 2 ‚Üí 3 ‚Üí null",
          "input": {
            "list": "1 ‚Üí 2 ‚Üí 3 ‚Üí null"
          },
          "memoryTrace": {
            "description": "Watch three pointers dance through the reversal",
            "execution": [
              {
                "line": "prev = null, curr = head",
                "memory": {
                  "prev": "null",
                  "curr": "node(1)"
                },
                "visual": "null   1 ‚Üí 2 ‚Üí 3 ‚Üí null\n ‚Üë     ‚Üë\nprev  curr",
                "note": "Initialize pointers"
              },
              {
                "line": "next = curr.next",
                "memory": {
                  "prev": "null",
                  "curr": "node(1)",
                  "next": "node(2)"
                },
                "note": "Save reference to 2 before we break the link"
              },
              {
                "line": "curr.next = prev",
                "memory": {
                  "prev": "null",
                  "curr": "node(1)"
                },
                "visual": "null ‚Üê 1    2 ‚Üí 3 ‚Üí null",
                "note": "Reverse the link: 1 now points to null"
              },
              {
                "line": "prev = curr, curr = next",
                "memory": {
                  "prev": "node(1)",
                  "curr": "node(2)"
                },
                "visual": "null ‚Üê 1    2 ‚Üí 3 ‚Üí null\n       ‚Üë    ‚Üë\n     prev  curr",
                "note": "Advance both pointers"
              },
              {
                "line": "// Repeat: next = curr.next, curr.next = prev",
                "memory": {
                  "prev": "node(2)",
                  "curr": "node(3)"
                },
                "visual": "null ‚Üê 1 ‚Üê 2    3 ‚Üí null\n           ‚Üë    ‚Üë\n         prev  curr",
                "note": "Link 2 ‚Üí 1, advance"
              },
              {
                "line": "// Final iteration",
                "memory": {
                  "prev": "node(3)",
                  "curr": "null"
                },
                "visual": "null ‚Üê 1 ‚Üê 2 ‚Üê 3    null\n               ‚Üë    ‚Üë\n             prev  curr",
                "note": "Link 3 ‚Üí 2, curr becomes null, loop ends"
              },
              {
                "line": "return prev",
                "memory": {
                  "result": "node(3)"
                },
                "visual": "3 ‚Üí 2 ‚Üí 1 ‚Üí null",
                "note": "prev is new head!"
              }
            ]
          },
          "steps": [
            {
              "step": 1,
              "prev": "null",
              "curr": "1",
              "next": "2",
              "action": "Reverse 1‚Üínull"
            },
            {
              "step": 2,
              "prev": "1",
              "curr": "2",
              "next": "3",
              "action": "Reverse 2‚Üí1"
            },
            {
              "step": 3,
              "prev": "2",
              "curr": "3",
              "next": "null",
              "action": "Reverse 3‚Üí2"
            },
            {
              "step": 4,
              "prev": "3",
              "curr": "null",
              "next": "-",
              "action": "Done, return 3"
            }
          ],
          "output": "3 ‚Üí 2 ‚Üí 1 ‚Üí null"
        },
        "commonMistakes": [
          {
            "mistake": "Losing reference to rest of list when reversing",
            "wrong": "curr.next = prev;  // Lost reference to what was curr.next!",
            "right": "const next = curr.next; curr.next = prev; curr = next;",
            "explanation": "Always save curr.next BEFORE overwriting it."
          },
          {
            "mistake": "Not handling empty list or single node",
            "wrong": "function reverse(head) { let curr = head.next; ... } // Crashes if head is null!",
            "right": "if (!head || !head.next) return head;  // Handle edge cases first",
            "explanation": "Always check for null/undefined before accessing .next property."
          },
          {
            "mistake": "Infinite loop in cycle detection",
            "wrong": "while (fast.next) { fast = fast.next.next; }  // Null pointer if odd length!",
            "right": "while (fast && fast.next) { fast = fast.next.next; }",
            "explanation": "Check BOTH fast AND fast.next to avoid null pointer exception."
          },
          {
            "mistake": "Not updating prev when deleting",
            "wrong": "// To delete curr: prev.next = curr.next; prev = curr; // Wrong!",
            "right": "prev.next = curr.next; curr = curr.next;  // Don't move prev",
            "explanation": "When deleting, prev stays in place - only curr advances."
          },
          {
            "mistake": "Forgetting the dummy node pattern",
            "wrong": "// Special case for deleting head, special case for empty list...",
            "right": "const dummy = new ListNode(0, head); // Now head deletion is just like any other",
            "explanation": "Dummy node eliminates edge cases for operations at head."
          }
        ],
        "keyTakeaways": [
          "Linked lists trade access speed (O(n)) for insert/delete speed (O(1) at known position)",
          "Singly linked: one direction. Doubly linked: both directions + O(1) delete with node reference",
          "Key patterns: slow/fast pointers (cycle, middle), dummy head (edge cases), in-place reversal",
          "Not cache-friendly: scattered memory = cache misses. Arrays often faster in practice for small data",
          "Interview essentials: reverse list, detect cycle, find middle, merge two sorted lists",
          "Use collections.deque in Python, implement with class in JavaScript (no built-in)"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "big_o",
              "label": "Big O Notation",
              "why": "Understand O(1) vs O(n) trade-offs"
            },
            {
              "id": "pointers",
              "label": "Pointers/References",
              "why": "Linked lists are all about pointer manipulation"
            }
          ],
          "nextTopics": [
            {
              "id": "stack",
              "label": "Stack",
              "why": "Often implemented with linked list"
            },
            {
              "id": "queue",
              "label": "Queue",
              "why": "Linked list enables O(1) dequeue"
            },
            {
              "id": "dll",
              "label": "Doubly Linked List",
              "why": "Bidirectional traversal, O(1) delete"
            },
            {
              "id": "lru_cache",
              "label": "LRU Cache",
              "why": "Classic problem: hash map + doubly linked list"
            },
            {
              "id": "tree",
              "label": "Binary Tree",
              "why": "Trees are linked lists with two children per node"
            }
          ]
        },
        "patternChain": {
          "description": "Linked List connections in DSA graph",
          "buildsOn": [
            {
              "id": "pointers",
              "relationship": "Linked lists are pointer-based data structures",
              "whatToKnow": "Understand references, memory addresses, dereferencing"
            }
          ],
          "enables": [
            {
              "id": "stack",
              "relationship": "Stack can be implemented with linked list (push/pop at head)",
              "patternName": "Linked Stack",
              "interviewFrequency": "Medium"
            },
            {
              "id": "queue",
              "relationship": "Queue with linked list enables O(1) enqueue and dequeue",
              "patternName": "Linked Queue",
              "interviewFrequency": "Medium"
            },
            {
              "id": "lru_cache",
              "relationship": "Doubly linked list + hash map for O(1) get/put/evict",
              "patternName": "LRU Cache",
              "interviewFrequency": "Very High"
            },
            {
              "id": "merge_sort_list",
              "relationship": "Merge sort on linked list uses find-middle + merge",
              "patternName": "Divide & Conquer on List",
              "interviewFrequency": "Medium"
            },
            {
              "id": "tree",
              "relationship": "Trees are linked structures with multiple children",
              "patternName": "Hierarchical Linked Structure",
              "interviewFrequency": "High"
            }
          ],
          "lineagePath": {
            "description": "Linked List skill tree",
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart LR\n    PTR[Pointers] --> LL[Linked List]\n    LL --> STACK[Stack]\n    LL --> QUEUE[Queue]\n    LL --> DLL[Doubly Linked]\n    DLL --> LRU[LRU Cache]\n    LL --> TREE[Binary Tree]\n    \n    style LL fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          },
          "relatedPatterns": [
            {
              "id": "array",
              "relationship": "Opposite trade-offs: O(1) access vs O(1) insert"
            },
            {
              "id": "slow_fast",
              "relationship": "Two-pointer technique for cycle/middle detection"
            },
            {
              "id": "dummy_head",
              "relationship": "Pattern to simplify head operations"
            }
          ]
        }
      }
    },
    {
      "id": "string",
      "label": "String",
      "type": "ds-linear",
      "description": "Array of characters.",
      "references": {
        "official": [
          {
            "title": "MDN Web Docs",
            "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/string/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/string-data-structure/"
          }
        ]
      },
      "difficulty": 1,
      "timeEstimate": "1 hour",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft",
        "Apple"
      ],
      "interviewFrequency": "high",
      "category": "Linear DS",
      "categoryIcon": "üìä",
      "interviewQuestions": [
        {
          "name": "Longest Substring Without Repeating Characters",
          "leetcode": "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Microsoft",
            "Bloomberg"
          ],
          "frequency": "Very High",
          "whyAsked": "Classic sliding window problem with hash set/map",
          "approach": "Sliding window with hash set. Expand right, shrink left when duplicate found. O(n)",
          "followUps": [
            {
              "question": "At most k distinct characters?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Minimum window containing all chars?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "Valid Parentheses",
          "leetcode": "https://leetcode.com/problems/valid-parentheses/",
          "difficulty": "Easy",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Bloomberg"
          ],
          "frequency": "Very High",
          "whyAsked": "Classic stack problem for matching pairs",
          "approach": "Push opening brackets to stack. For closing, check if matches top. Stack empty at end = valid",
          "followUps": [
            {
              "question": "Longest valid parentheses?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Remove minimum to make valid?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Generate all valid?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "Longest Palindromic Substring",
          "leetcode": "https://leetcode.com/problems/longest-palindromic-substring/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Microsoft",
            "Meta",
            "Google"
          ],
          "frequency": "High",
          "whyAsked": "Tests expand-around-center technique or DP approach",
          "approach": "Expand around each center (2n-1 centers for odd/even). O(n¬≤) time. Or Manacher's O(n)",
          "followUps": [
            {
              "question": "Count all palindromic substrings?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Longest palindromic subsequence?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Minimum Window Substring",
          "leetcode": "https://leetcode.com/problems/minimum-window-substring/",
          "difficulty": "Hard",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Uber",
            "LinkedIn"
          ],
          "frequency": "High",
          "whyAsked": "Advanced sliding window with character frequency tracking",
          "approach": "Sliding window with two pointers. Expand to include all chars, contract to minimize. O(n)",
          "followUps": [
            {
              "question": "All starting indices?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Smallest window with k distinct?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Encode and Decode Strings",
          "leetcode": "https://leetcode.com/problems/encode-and-decode-strings/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Google"
          ],
          "frequency": "Medium",
          "whyAsked": "Tests string manipulation and delimiter design (length prefix or escape chars)",
          "approach": "Length-prefix encoding: '5#hello4#test'. On decode, read length, extract substring",
          "followUps": [
            {
              "question": "Handle any character including delimiter?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Compression?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based problem categorization"
        },
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with video explanations"
        }
      ],
      "content": {
        "definition": {
          "simple": "String pattern matching algorithms find where a pattern appears in a text. KMP (Knuth-Morris-Pratt) does this in O(n+m) by precomputing a 'failure function' that tells us where to continue after a mismatch.",
          "technical": "The KMP algorithm performs pattern matching in O(n+m) time by preprocessing the pattern into a failure/LPS (Longest Proper Prefix which is also Suffix) array. This array enables the algorithm to skip redundant comparisons after mismatches, avoiding the O(nm) worst case of naive search."
        },
        "howItWorks": {
          "explanation": "Imagine you're matching 'ABABC' in a text. You match ABAB but fail at C. Naive approach: start over at position 2. KMP insight: 'ABAB' ends with 'AB' which also starts 'ABABC'! Skip to position 3, continue matching from 'AB' onwards. The LPS array tells you exactly how many characters you can 'carry forward'.",
          "steps": [
            {
              "step": 1,
              "title": "Build LPS Array",
              "description": "For each position i in pattern, compute longest proper prefix that's also a suffix.",
              "why": "LPS[i] tells us where to resume after mismatch at i."
            },
            {
              "step": 2,
              "title": "Initialize Pointers",
              "description": "i = 0 (text pointer), j = 0 (pattern pointer)",
              "why": "Both start at beginning."
            },
            {
              "step": 3,
              "title": "Match Characters",
              "description": "If text[i] == pattern[j], advance both i and j",
              "why": "Continue matching."
            },
            {
              "step": 4,
              "title": "Handle Mismatch",
              "description": "If mismatch and j > 0, set j = LPS[j-1]. Don't move i!",
              "why": "Jump back in pattern using precomputed knowledge."
            },
            {
              "step": 5,
              "title": "Full Match Found",
              "description": "If j == pattern.length, record match, set j = LPS[j-1]",
              "why": "Pattern found! Resume for next match."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph TD\n    subgraph \"LPS Array for 'ABABC'\"\n        P[\"A B A B C\"]\n        L[\"0 0 1 2 0\"]\n    end\n    \n    subgraph \"Why LPS[3]=2?\"\n        W1[\"At position 3: pattern[0..3] = 'ABAB'\"]\n        W2[\"Longest prefix=suffix: 'AB' (length 2)\"]\n        W3[\"If mismatch at position 4, jump to position 2\"]\n    end",
            "caption": "LPS[i] = length of longest proper prefix that's also suffix at position i"
          }
        },
        "whenToUse": {
          "summary": "Use KMP when you need to find pattern occurrences efficiently, especially with patterns that have repeating substrings.",
          "patterns": [
            {
              "pattern": "Single Pattern Search",
              "signal": "Find all occurrences of pattern in text",
              "example": "Find 'needle' in 'haystack'",
              "withoutIt": "O(nm) naive search",
              "withIt": "O(n+m) guaranteed"
            },
            {
              "pattern": "Pattern with Repetition",
              "signal": "Pattern has repeated prefixes (ABABAB)",
              "example": "Find 'AAAA' in 'AAAAAAA'",
              "withoutIt": "O(nm) - worst case triggers often",
              "withIt": "O(n+m) - LPS captures repetition"
            },
            {
              "pattern": "String Periodicity",
              "signal": "Find if string has repeating pattern",
              "example": "'abcabcabc' has period 'abc'",
              "withoutIt": "Check all divisors O(n‚àön)",
              "withIt": "O(n) using LPS array properties"
            },
            {
              "pattern": "Shortest Palindrome",
              "signal": "Find shortest palindrome by adding prefix",
              "example": "Minimum chars to prepend for palindrome",
              "withoutIt": "O(n¬≤) checking each prefix",
              "withIt": "O(n) with KMP trick (reverse + original)"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "When simpler algorithms suffice or when you need multiple pattern matching.",
          "antiPatterns": [
            {
              "situation": "Short Patterns",
              "why": "Overhead of building LPS not worth it",
              "useInstead": "Naive search or built-in methods",
              "example": "Finding 'ab' in a string"
            },
            {
              "situation": "Multiple Patterns",
              "why": "KMP handles single pattern only",
              "useInstead": "Aho-Corasick or Rabin-Karp with rolling hash",
              "example": "Find any of 1000 patterns in text"
            },
            {
              "situation": "Approximate Matching",
              "why": "KMP is exact match only",
              "useInstead": "Edit distance, fuzzy matching",
              "example": "Allow 1 character difference"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Smart Bookmark",
            "story": "Imagine reading 'ABAB...' and you're matching pattern 'ABABC'. You matched 'ABAB' but the next char isn't 'C'. Naive: go back and start from position 2. KMP: you already know 'AB' matches because 'ABAB' ends with 'AB'. Your 'smart bookmark' (LPS) tells you to continue from pattern position 2, not 0!",
            "connection": "LPS is the bookmark - it remembers what you've already matched within the pattern itself."
          },
          "keyInsight": "The key insight is that the pattern contains information about itself. If 'ABAB' fails to match 'C', we know 'AB' at the end is also 'AB' at the start. We never need to re-examine text characters.",
          "commonConfusion": [
            {
              "confusion": "What exactly is LPS?",
              "clarification": "LPS[i] = length of longest PROPER (not entire string) prefix of pattern[0..i] that's also a suffix. For 'ABAB': the proper prefixes are '', 'A', 'AB', 'ABA'. Suffixes are '', 'B', 'AB', 'BAB'. Longest match: 'AB' (length 2)."
            },
            {
              "confusion": "Why not just use indexOf?",
              "clarification": "Built-in indexOf might be O(nm) worst case. KMP guarantees O(n+m). For interview, understanding WHY is crucial."
            },
            {
              "confusion": "Difference from Rabin-Karp?",
              "clarification": "Rabin-Karp uses hashing (fast average, can have collisions). KMP uses prefix structure (guaranteed O(n+m), no collisions)."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Build LPS Array",
                "average": "O(m)",
                "worst": "O(m)",
                "note": "Single pass through pattern"
              },
              {
                "operation": "Pattern Search",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Each text char examined once"
              },
              {
                "operation": "Total KMP",
                "average": "O(n+m)",
                "worst": "O(n+m)",
                "note": "Linear in total input size"
              }
            ],
            "explanation": "Key: text pointer never moves backward. Pattern pointer can jump back but total jumps ‚â§ n."
          },
          "space": {
            "complexity": "O(m)",
            "explanation": "LPS array of pattern length."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "LPS array stores jump positions for each pattern index.",
            "keyPoints": [
              "LPS[0] = 0 always (no proper prefix for single char)",
              "LPS[i] = length of longest proper prefix = suffix at i",
              "On mismatch at j, jump to LPS[j-1] (not LPS[j])",
              "LPS building uses the same logic as matching - elegant!"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Use arrays for LPS. String indexing is O(1).",
              "gotchas": [
                "JavaScript strings are immutable - no in-place modification",
                "charCodeAt() for numeric comparison if needed",
                "String.includes() uses native optimized search"
              ]
            },
            "python": {
              "implementation": "List for LPS. String slicing creates copies.",
              "gotchas": [
                "Python 'in' operator is optimized but not guaranteed O(n+m)",
                "Use list for mutable operations",
                "Consider memoryview for large strings"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "KMP pattern matching is O(n+m)",
            "proof": {
              "step1": {
                "action": "LPS building: O(m)",
                "cost": "j increases m times, decreases ‚â§ m times"
              },
              "step2": {
                "action": "Text pointer i only advances",
                "cost": "Exactly n increments"
              },
              "step3": {
                "action": "Pattern pointer j movements",
                "cost": "Advances ‚â§ n times, retreats ‚â§ n times (each retreat preceded by advance)"
              },
              "step4": {
                "action": "Total operations bounded",
                "cost": "O(n) for search + O(m) for LPS"
              }
            },
            "totalCost": "O(n + m)"
          }
        },
        "codeTemplates": [
          {
            "name": "Build LPS Array",
            "description": "Compute Longest Proper Prefix which is also Suffix",
            "javascript": {
              "code": "function buildLPS(pattern) {\n  const m = pattern.length;\n  const lps = new Array(m).fill(0);\n  \n  let len = 0;  // Length of previous longest prefix suffix\n  let i = 1;    // lps[0] is always 0\n  \n  while (i < m) {\n    if (pattern[i] === pattern[len]) {\n      len++;\n      lps[i] = len;\n      i++;\n    } else {\n      if (len > 0) {\n        // Don't increment i, try shorter prefix\n        len = lps[len - 1];\n      } else {\n        lps[i] = 0;\n        i++;\n      }\n    }\n  }\n  \n  return lps;\n}\n\n// Example: 'ABABCABAB'\n// i=1: B‚â†A, lps[1]=0\n// i=2: A=A, lps[2]=1, len=1\n// i=3: B=B (pattern[3] vs pattern[1]), lps[3]=2, len=2\n// i=4: C‚â†A, len=lps[1]=0, C‚â†A, lps[4]=0\n// ... continue\n// Result: [0, 0, 1, 2, 0, 1, 2, 3, 4]",
              "notes": "Same logic as KMP search - building LPS IS pattern matching itself!"
            },
            "python": {
              "code": "def build_lps(pattern):\n    m = len(pattern)\n    lps = [0] * m\n    \n    length = 0  # Length of previous longest prefix suffix\n    i = 1\n    \n    while i < m:\n        if pattern[i] == pattern[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length > 0:\n                length = lps[length - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    \n    return lps\n\n# LPS tells us: if we've matched pattern[0..i] and fail at i+1,\n# we can jump to position lps[i] and continue matching from there",
              "notes": "The beauty: LPS building and searching use identical logic."
            }
          },
          {
            "name": "KMP Pattern Search",
            "description": "Find all occurrences of pattern in text",
            "javascript": {
              "code": "function kmpSearch(text, pattern) {\n  const n = text.length;\n  const m = pattern.length;\n  const lps = buildLPS(pattern);\n  const result = [];\n  \n  let i = 0;  // Text pointer\n  let j = 0;  // Pattern pointer\n  \n  while (i < n) {\n    if (text[i] === pattern[j]) {\n      i++;\n      j++;\n    }\n    \n    if (j === m) {\n      // Full match found!\n      result.push(i - j);\n      j = lps[j - 1];  // Look for next match\n    } else if (i < n && text[i] !== pattern[j]) {\n      if (j > 0) {\n        j = lps[j - 1];  // Jump back in pattern\n      } else {\n        i++;  // No prefix to fall back to\n      }\n    }\n  }\n  \n  return result;\n}\n\n// Example: kmpSearch('ABABDABACDABABCABAB', 'ABABCABAB')\n// Returns: [10] (pattern found at index 10)",
              "notes": "i never decreases. j can decrease but total operations still O(n)."
            },
            "python": {
              "code": "def kmp_search(text, pattern):\n    n, m = len(text), len(pattern)\n    if m == 0:\n        return []\n    \n    lps = build_lps(pattern)\n    result = []\n    \n    i = j = 0\n    \n    while i < n:\n        if text[i] == pattern[j]:\n            i += 1\n            j += 1\n        \n        if j == m:\n            result.append(i - j)\n            j = lps[j - 1]\n        elif i < n and text[i] != pattern[j]:\n            if j > 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    \n    return result\n\n# Alternative: return first match only\ndef kmp_search_first(text, pattern):\n    n, m = len(text), len(pattern)\n    lps = build_lps(pattern)\n    \n    i = j = 0\n    while i < n:\n        if text[i] == pattern[j]:\n            i += 1\n            j += 1\n            if j == m:\n                return i - j\n        elif j > 0:\n            j = lps[j - 1]\n        else:\n            i += 1\n    \n    return -1  # Not found",
              "notes": "Clean version returning all match positions."
            }
          },
          {
            "name": "Repeated Substring Pattern",
            "description": "Check if string is repetition of a pattern",
            "javascript": {
              "code": "function repeatedSubstringPattern(s) {\n  const n = s.length;\n  const lps = buildLPS(s);\n  \n  // If lps[n-1] > 0 and (n - lps[n-1]) divides n,\n  // then s consists of repeated pattern of length (n - lps[n-1])\n  const patternLen = n - lps[n - 1];\n  \n  return lps[n - 1] > 0 && n % patternLen === 0;\n}\n\n// Why it works:\n// 'abcabcabc': lps = [0,0,0,1,2,3,4,5,6]\n// lps[8] = 6, patternLen = 9 - 6 = 3\n// 9 % 3 === 0, so 'abc' repeated 3 times ‚úì\n\n// 'abcabc': lps = [0,0,0,1,2,3]\n// lps[5] = 3, patternLen = 6 - 3 = 3\n// 6 % 3 === 0, so 'abc' repeated 2 times ‚úì\n\n// 'abcab': lps = [0,0,0,1,2]\n// lps[4] = 2, patternLen = 5 - 2 = 3\n// 5 % 3 !== 0, so NOT a repeated pattern ‚úó",
              "notes": "Beautiful application of LPS: last value reveals period length."
            },
            "python": {
              "code": "def repeated_substring_pattern(s):\n    n = len(s)\n    lps = build_lps(s)\n    \n    pattern_len = n - lps[-1]\n    \n    return lps[-1] > 0 and n % pattern_len == 0\n\n# Alternative: string concatenation trick (simpler but O(n) extra space)\ndef repeated_substring_pattern_v2(s):\n    # If s is a repeated pattern, it appears in (s+s)[1:-1]\n    return s in (s + s)[1:-1]\n\n# The trick explained:\n# s = 'abcabc', s+s = 'abcabcabcabc'\n# (s+s)[1:-1] = 'bcabcabcab' - contains 'abcabc'? YES\n# \n# s = 'abc', s+s = 'abcabc'\n# (s+s)[1:-1] = 'bcab' - contains 'abc'? NO",
              "notes": "Two approaches: KMP LPS analysis or string doubling trick."
            }
          }
        ],
        "visualTrace": {
          "title": "KMP Search for 'ABAB' in 'ABABCABABD'",
          "input": {
            "text": "ABABCABABD",
            "pattern": "ABAB",
            "lps": "[0,0,1,2]"
          },
          "steps": [
            {
              "i": 0,
              "j": 0,
              "match": "A=A",
              "action": "i++, j++",
              "state": "i=1, j=1"
            },
            {
              "i": 1,
              "j": 1,
              "match": "B=B",
              "action": "i++, j++",
              "state": "i=2, j=2"
            },
            {
              "i": 2,
              "j": 2,
              "match": "A=A",
              "action": "i++, j++",
              "state": "i=3, j=3"
            },
            {
              "i": 3,
              "j": 3,
              "match": "B=B",
              "action": "j==4! Match at 0",
              "state": "result=[0], j=lps[3]=2"
            },
            {
              "i": 4,
              "j": 2,
              "match": "C‚â†A",
              "action": "j=lps[1]=0",
              "state": "j=0"
            },
            {
              "i": 4,
              "j": 0,
              "match": "C‚â†A",
              "action": "i++",
              "state": "i=5, j=0"
            },
            {
              "i": 5,
              "j": 0,
              "match": "A=A",
              "action": "i++, j++",
              "state": "...continue"
            },
            {
              "i": "...",
              "j": "...",
              "match": "...",
              "action": "Match at 5",
              "state": "result=[0,5]"
            }
          ],
          "output": "Pattern 'ABAB' found at indices [0, 5]"
        },
        "commonMistakes": [
          {
            "mistake": "Using lps[j] instead of lps[j-1] on mismatch",
            "wrong": "j = lps[j]",
            "right": "j = lps[j-1]",
            "explanation": "We've matched j characters (0 to j-1), so use lps of last matched char."
          },
          {
            "mistake": "Not handling empty pattern",
            "wrong": "Crash on empty",
            "right": "Return empty result or all positions",
            "explanation": "Edge case: empty pattern 'matches' everywhere."
          },
          {
            "mistake": "Confusing proper prefix with prefix",
            "wrong": "'ABA' prefix of 'ABA' = 'ABA'",
            "right": "Proper prefix excludes whole string: '', 'A', 'AB'",
            "explanation": "LPS uses PROPER prefix - cannot equal entire string."
          }
        ],
        "keyTakeaways": [
          "KMP achieves O(n+m) by never backtracking in text",
          "LPS[i] = longest proper prefix that's also suffix at i",
          "On mismatch at j, jump to j = LPS[j-1]",
          "LPS building uses same logic as matching - elegant self-reference",
          "LPS[-1] reveals periodicity: if n % (n - LPS[-1]) == 0, string is periodic",
          "KMP vs Rabin-Karp: KMP is deterministic, RK uses hashing (probabilistic)"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Arrays",
              "why": "LPS is an array-based precomputation"
            },
            {
              "id": "string",
              "label": "String Basics",
              "why": "Fundamental string operations"
            }
          ],
          "nextTopics": [
            {
              "id": "rabin_karp",
              "label": "Rabin-Karp",
              "why": "Alternative pattern matching with hashing"
            },
            {
              "id": "trie",
              "label": "Trie",
              "why": "Multiple pattern prefix matching"
            },
            {
              "id": "suffix_array",
              "label": "Suffix Array",
              "why": "Advanced string structure"
            }
          ]
        },
        "patternChain": {
          "description": "KMP is the foundation of efficient single-pattern string matching",
          "buildsOn": [
            {
              "id": "array",
              "relationship": "LPS array precomputation",
              "whatToKnow": "Array construction"
            },
            {
              "id": "string",
              "relationship": "String comparison fundamentals",
              "whatToKnow": "Character access"
            }
          ],
          "enables": [
            {
              "id": "strstr",
              "relationship": "Efficient implementation of strStr()",
              "patternName": "Pattern Matching",
              "interviewFrequency": "High"
            },
            {
              "id": "repeated_pattern",
              "relationship": "String periodicity detection",
              "patternName": "LPS Analysis",
              "interviewFrequency": "Medium"
            },
            {
              "id": "shortest_palindrome",
              "relationship": "Minimum chars to prepend",
              "patternName": "KMP + Reverse",
              "interviewFrequency": "Medium"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    STR[String Basics] --> KMP[KMP Algorithm]\n    ARR[Arrays] --> KMP\n    KMP --> STRSTR[strStr / indexOf]\n    KMP --> PERIOD[Repeated Substring]\n    KMP --> PALIN[Shortest Palindrome]\n    KMP --> ZA[Z-Algorithm]\n    \n    style KMP fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "hashing",
      "label": "Hashing Function",
      "type": "concept",
      "description": "Mapping data to indices.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Hash_function"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/hashtable"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/hashing-data-structure/"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Concept",
      "categoryIcon": "üí°",
      "content": {
        "definition": {
          "simple": "A function that converts any input into a fixed-size number. Same input always gives same output.",
          "technical": "Maps arbitrary data to integers in range [0, m). Good hash functions distribute uniformly and minimize collisions."
        },
        "keyTakeaways": [
          "Deterministic: same input ‚Üí same output",
          "Fixed output size regardless of input",
          "Collisions are inevitable (pigeonhole)",
          "Used in hash maps, sets, checksums"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Arrays",
              "why": "Hash tables use arrays"
            }
          ],
          "nextTopics": [
            {
              "id": "hash_map",
              "label": "Hash Maps",
              "why": "Primary application"
            }
          ]
        }
      }
    },
    {
      "id": "hashmap",
      "label": "Hash Map",
      "type": "ds-hybrid",
      "description": "Key-value pairs with O(1) access.",
      "references": {
        "official": [
          {
            "title": "MDN Web Docs",
            "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/hashtable"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/hash-table/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/hashing-data-structure/"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2-3 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft",
        "Apple"
      ],
      "interviewFrequency": "high",
      "category": "Hybrid DS",
      "categoryIcon": "üîÄ",
      "interviewQuestions": [
        {
          "name": "Group Anagrams",
          "leetcode": "https://leetcode.com/problems/group-anagrams/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Tests hash map with custom key generation (sorted string or char count)",
          "approach": "Use sorted string or char frequency tuple as key. Group by key. O(n * k log k) or O(n * k)",
          "followUps": [
            {
              "question": "Optimize key generation",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Stream of words variant",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "Valid Anagram",
          "leetcode": "https://leetcode.com/problems/valid-anagram/",
          "difficulty": "Easy",
          "companies": [
            "Amazon",
            "Google",
            "Microsoft"
          ],
          "frequency": "High",
          "whyAsked": "Basic character counting with hash map",
          "approach": "Count chars in first string, decrement for second. All counts should be 0. O(n)",
          "followUps": [
            {
              "question": "Unicode characters?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Follow-up: what if inputs are streams?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "LRU Cache",
          "leetcode": "https://leetcode.com/problems/lru-cache/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Microsoft",
            "Google",
            "Apple",
            "Flipkart"
          ],
          "frequency": "Very High",
          "whyAsked": "Classic system design + DS combo. Tests HashMap + Doubly Linked List",
          "approach": "HashMap for O(1) lookup + Doubly Linked List for O(1) removal/insertion at ends",
          "followUps": [
            {
              "question": "LFU Cache?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Thread-safe version?",
              "answer": "Use lock for all operations, or lock-free with CAS for enqueue/dequeue. Producer-consumer patterns."
            },
            {
              "question": "Distributed cache?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "teamblind"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Blind (Teamblind)",
              "url": "https://www.teamblind.com/",
              "note": "Crowdsourced interview experiences from FAANG employees"
            }
          ]
        },
        {
          "name": "Subarray Sum Equals K",
          "leetcode": "https://leetcode.com/problems/subarray-sum-equals-k/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Google",
            "Amazon"
          ],
          "frequency": "High",
          "whyAsked": "Tests prefix sum + hash map technique for subarray problems",
          "approach": "Store prefix sum counts. For each prefix, check if (prefix - k) exists. O(n) time",
          "followUps": [
            {
              "question": "Count subarrays divisible by k?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Longest subarray with sum k?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "seanprashad"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Sean Prashad's Patterns",
              "url": "https://seanprashad.com/leetcode-patterns/",
              "note": "Pattern-based problem categorization"
            }
          ]
        },
        {
          "name": "Top K Frequent Elements",
          "leetcode": "https://leetcode.com/problems/top-k-frequent-elements/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Meta",
            "Google",
            "Apple"
          ],
          "frequency": "High",
          "whyAsked": "Tests HashMap + Heap or Bucket Sort for frequency problems",
          "approach": "Count frequencies, then use min-heap of size k OR bucket sort by frequency. O(n log k) or O(n)",
          "followUps": [
            {
              "question": "Stream of data?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Return in order?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based problem categorization"
        },
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with video explanations"
        }
      ],
      "content": {
        "definition": {
          "simple": "A hash map is like a dictionary - you look up a word (key) and get its meaning (value) instantly, without reading the whole book.",
          "technical": "A hash map is a data structure that stores key-value pairs. It uses a hash function to compute an index into an array of buckets, enabling O(1) average-case lookup, insertion, and deletion."
        },
        "howItWorks": {
          "explanation": "Imagine a coat check at a restaurant. You give them your coat (value), they give you a numbered ticket (key). When you want your coat back, you don't search through all coats - you just show your ticket number and they go directly to that spot. A hash map converts your key into a 'ticket number' (index) so it knows exactly where to store and find your value.",
          "steps": [
            {
              "step": 1,
              "title": "Hash the Key",
              "description": "The hash function takes your key (like 'username') and converts it into a number. For example, 'john' might become 1287364.",
              "why": "We need a number because arrays are indexed by numbers, not strings."
            },
            {
              "step": 2,
              "title": "Calculate Index",
              "description": "We use modulo to fit the hash into our array size: index = hashCode % arraySize. If hashCode is 1287364 and array size is 10, index = 4.",
              "why": "The hash could be huge, but our array has limited slots."
            },
            {
              "step": 3,
              "title": "Store or Retrieve",
              "description": "Go directly to that index. For insert: store the key-value pair. For lookup: return the value at that index.",
              "why": "Direct access is O(1) - we don't search, we jump."
            },
            {
              "step": 4,
              "title": "Handle Collisions",
              "description": "Sometimes different keys hash to the same index (collision). We handle this by storing multiple items at that index (chaining) or finding another slot (open addressing).",
              "why": "Collisions are inevitable - a good hash function minimizes them but can't eliminate them."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff', 'primaryBorderColor': '#3d5a80', 'lineColor': '#3d5a80', 'secondaryColor': '#ee6c4d', 'tertiaryColor': '#98c1d9'}}}%%\nflowchart LR\n    subgraph Input\n        K1[\"key: 'john'\"]\n        K2[\"key: 'jane'\"]\n    end\n    \n    subgraph HashFunction[\"Hash Function\"]\n        HF[\"hash()\"]\n    end\n    \n    subgraph Array[\"Bucket Array\"]\n        B0[\"[0]: empty\"]\n        B1[\"[1]: jane ‚Üí 28\"]\n        B2[\"[2]: empty\"]\n        B3[\"[3]: john ‚Üí 25\"]\n        B4[\"[4]: empty\"]\n    end\n    \n    K1 --> HF\n    K2 --> HF\n    HF -->|\"hash('john') % 5 = 3\"| B3\n    HF -->|\"hash('jane') % 5 = 1\"| B1\n    \n    style B1 fill:#ee6c4d\n    style B3 fill:#ee6c4d",
            "caption": "Hash function maps keys to array indices for O(1) access"
          }
        },
        "whenToUse": {
          "summary": "Use a hash map when you need to quickly look up, insert, or delete items by a unique key.",
          "patterns": [
            {
              "pattern": "Fast Lookup by Key",
              "signal": "You need to check if something exists or get a value in O(1)",
              "example": "Check if a username is taken",
              "withoutIt": "O(n) - scan through all usernames",
              "withIt": "O(1) - instant lookup"
            },
            {
              "pattern": "Counting Frequencies",
              "signal": "Count how many times each item appears",
              "example": "Count character frequencies in a string",
              "withoutIt": "O(n¬≤) - nested loops to count each unique item",
              "withIt": "O(n) - single pass, increment count for each key"
            },
            {
              "pattern": "Finding Pairs/Complements (Two Sum)",
              "signal": "Find two items that satisfy a condition (like sum = target)",
              "example": "Two Sum - find indices where nums[i] + nums[j] = target",
              "withoutIt": "O(n¬≤) - check every pair",
              "withIt": "O(n) - store seen values, check if complement exists"
            },
            {
              "pattern": "Grouping Items",
              "signal": "Group items by some property",
              "example": "Group anagrams together",
              "withoutIt": "O(n¬≤ √ó k) - compare every pair of strings",
              "withIt": "O(n √ó k) - use sorted string or char count as key"
            },
            {
              "pattern": "Caching / Memoization",
              "signal": "Avoid recomputing expensive results",
              "example": "Cache Fibonacci results to avoid exponential recursion",
              "withoutIt": "O(2^n) - recalculate same values repeatedly",
              "withIt": "O(n) - store and reuse computed values"
            },
            {
              "pattern": "Deduplication",
              "signal": "Remove or track duplicates",
              "example": "Find first non-repeating character",
              "withoutIt": "O(n¬≤) - check every other character",
              "withIt": "O(n) - count first, then find count=1"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Hash maps trade order and memory for speed. Avoid when these trade-offs hurt you.",
          "antiPatterns": [
            {
              "situation": "Need Ordered Data",
              "why": "Hash maps don't maintain insertion or sorted order",
              "useInstead": "Array (insertion order), TreeMap/BST (sorted order)",
              "example": "Leaderboard where you need rank 1-10"
            },
            {
              "situation": "Need Range Queries",
              "why": "Can't efficiently find all keys between A and B",
              "useInstead": "BST, Segment Tree, or sorted array with binary search",
              "example": "Find all users with age 20-30"
            },
            {
              "situation": "Memory is Critical",
              "why": "Hash maps use extra space for buckets + load factor overhead",
              "useInstead": "Sorted array with binary search (if lookups are less frequent)",
              "example": "Embedded systems with limited RAM"
            },
            {
              "situation": "Keys Can't Be Hashed Reliably",
              "why": "Mutable objects as keys break the hash contract",
              "useInstead": "Use immutable keys, or TreeMap with comparator",
              "example": "Don't use lists as dict keys in Python"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Library Analogy",
            "story": "Imagine a library with 1 million books. Without any system, finding a book means checking every shelf - that's O(n). But libraries use the Dewey Decimal System: History books go to the 900s section, Science to 500s. Now you don't search everything - you go directly to the right section. A hash function is like Dewey Decimal for data: it tells you exactly which 'section' (bucket) your item belongs to.",
            "connection": "The hash function is your Dewey Decimal number. The array is your library shelves. O(1) lookup happens because you COMPUTE the location instead of SEARCHING for it."
          },
          "keyInsight": "Hash maps trade SPACE for TIME. By using extra memory (the bucket array) and a clever function (the hash), we eliminate the need to search. We COMPUTE where something is instead of SEARCHING for it.",
          "commonConfusion": [
            {
              "confusion": "Why O(1) when collisions exist?",
              "clarification": "O(1) is the AVERAGE case. With a good hash function, collisions are rare (usually 0-2 items per bucket). We say 'amortized O(1)'. Worst case (all keys hash to same bucket) is O(n), but this almost never happens in practice."
            },
            {
              "confusion": "Why not just use an array?",
              "clarification": "Arrays need integer indices. If your key is a string like 'username', you can't use it as an array index. Hash maps let you use ANY hashable type as a key."
            },
            {
              "confusion": "What makes a good hash function?",
              "clarification": "A good hash function: (1) is deterministic (same input ‚Üí same output), (2) distributes outputs uniformly (minimizes collisions), (3) is fast to compute. Don't write your own - use the language's built-in!"
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Insert",
                "average": "O(1)",
                "worst": "O(n)",
                "note": "Worst when all keys collide"
              },
              {
                "operation": "Lookup",
                "average": "O(1)",
                "worst": "O(n)",
                "note": "Worst when all keys collide"
              },
              {
                "operation": "Delete",
                "average": "O(1)",
                "worst": "O(n)",
                "note": "Worst when all keys collide"
              },
              {
                "operation": "Iterate all",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Must visit every bucket"
              }
            ],
            "explanation": "Average O(1) because hash function distributes keys evenly. Worst O(n) only with pathological input (all keys hash to same bucket)."
          },
          "space": {
            "complexity": "O(n)",
            "explanation": "Need to store n key-value pairs. Extra overhead from bucket array (typically 1.5-2x the number of items due to load factor)."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "A hash map is an array of 'buckets'. Each bucket can hold one or more key-value pairs. When you insert, the hash function tells you WHICH bucket (array index) to use.",
            "diagram": {
              "type": "mermaid",
              "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TB\n    subgraph HEAP[\"HEAP MEMORY\"]\n        subgraph MAP[\"HashMap Object\"]\n            SIZE[\"size: 3\"]\n            CAPACITY[\"capacity: 8\"]\n            BUCKETS[\"buckets: ptr\"]\n        end\n        \n        subgraph ARR[\"Bucket Array\"]\n            B0[\"[0]: null\"]\n            B1[\"[1]: null\"]\n            B2[\"[2]: ‚Üí Node\"]\n            B5[\"[5]: ‚Üí Node\"]\n        end\n        \n        N1[\"Node{key:'john', val:25}\"]\n        N2[\"Node{key:'bob', val:30, next:‚Üí}\"]\n        N3[\"Node{key:'rob', val:22}\"]\n        \n        BUCKETS --> ARR\n        B2 --> N1\n        B5 --> N2\n        N2 --> N3\n    end\n    \n    subgraph STACK[\"STACK\"]\n        VAR[\"map: ptr\"]\n    end\n    \n    VAR --> MAP\n    \n    style N2 fill:#ee6c4d\n    style N3 fill:#ee6c4d",
              "caption": "Hash map memory: buckets point to linked lists. 'bob' and 'rob' collided at index 5 ‚Üí chained together."
            },
            "keyPoints": [
              "HashMap object on HEAP stores metadata (size, capacity) + pointer to bucket array",
              "Bucket array is separate heap allocation",
              "Each bucket points to a linked list (chaining) or stores inline (open addressing)",
              "Collisions create chains: 'bob' and 'rob' at same index ‚Üí linked list",
              "Load factor (size/capacity) triggers resize - usually at 0.75"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "V8 uses different strategies based on usage pattern. Map() is a true hash table. Plain objects {} are optimized for known shapes but work as hash tables for dynamic keys.",
              "gotchas": [
                "Object keys are ALWAYS strings (or Symbols) - numbers get converted",
                "Map preserves insertion order (ES2015+)",
                "Use Map for dynamic keys, {} for static known keys",
                "WeakMap keys must be objects, allows garbage collection"
              ],
              "memoryTip": "Map has ~20% overhead vs objects. Use {} for simple string keys."
            },
            "python": {
              "implementation": "CPython dict uses open addressing with pseudo-random probing (not chaining). Since 3.6, dicts maintain insertion order via separate indices array.",
              "gotchas": [
                "Keys must be HASHABLE (immutable): strings, numbers, tuples OK. Lists, dicts NOT OK.",
                "Python 3.7+ guarantees insertion order",
                "Use dict.get(key, default) to avoid KeyError",
                "collections.defaultdict auto-creates missing keys"
              ],
              "memoryTip": "Dicts over-allocate ~33% for performance. Consider __slots__ for objects with fixed attributes."
            }
          },
          "hashingDeepDive": {
            "whatIsHashing": "A hash function takes input of any size and produces a fixed-size integer. Good hash functions distribute outputs uniformly to minimize collisions.",
            "example": {
              "input": "'john'",
              "process": "Simple hash: sum ASCII values. j=106, o=111, h=104, n=110 ‚Üí sum=431",
              "modulo": "431 % 8 (bucket size) = 7",
              "result": "Store at bucket index 7"
            },
            "collisionHandling": {
              "chaining": "Each bucket holds a linked list. Colliding items append to the list. Lookup walks the list.",
              "openAddressing": "If bucket is full, probe next buckets (linear/quadratic/double hash) until empty slot found.",
              "tradeoff": "Chaining: simpler, handles high load. Open addressing: better cache locality, but degrades at high load."
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Hash map lookup is O(1) average case",
            "proof": {
              "step1": {
                "action": "Hash the key",
                "cost": "O(k)",
                "note": "k = key length, usually small constant"
              },
              "step2": {
                "action": "Compute index: hash % size",
                "cost": "O(1)",
                "note": "Simple modulo"
              },
              "step3": {
                "action": "Access bucket at index",
                "cost": "O(1)",
                "note": "Array random access"
              },
              "step4": {
                "action": "Search within bucket",
                "cost": "O(1) avg",
                "note": "With good hash, ~1-2 items per bucket"
              }
            },
            "totalCost": "O(1) + O(1) + O(1) + O(1) = O(1) average"
          },
          "worstCaseExplanation": {
            "scenario": "All n keys hash to the same bucket",
            "whatHappens": "Bucket becomes a linked list of n items",
            "lookup": "Must traverse entire list ‚Üí O(n)",
            "realWorld": "Rare with good hash function. Java 8+ converts long chains to BSTs for O(log n) worst case."
          },
          "traceProof": {
            "title": "Proving Two Sum is O(n) with Hash Map",
            "withoutHashMap": {
              "approach": "Check every pair with nested loops",
              "code": "for i in range(n):\n  for j in range(i+1, n):\n    if nums[i] + nums[j] == target",
              "operations": "n-1 + n-2 + ... + 1 = n(n-1)/2 = O(n¬≤)"
            },
            "withHashMap": {
              "approach": "Store seen values, check complement in O(1)",
              "trace": [
                {
                  "iteration": 1,
                  "operation": "lookup O(1) + insert O(1)",
                  "total": "2 ops"
                },
                {
                  "iteration": 2,
                  "operation": "lookup O(1) + maybe insert O(1)",
                  "total": "2 ops"
                },
                {
                  "iteration": "n",
                  "operation": "lookup O(1)",
                  "total": "1-2 ops"
                }
              ],
              "operations": "n iterations √ó 2 operations = O(2n) = O(n)"
            },
            "speedup": "O(n¬≤) ‚Üí O(n). For n=10,000: 100,000,000 ops ‚Üí 10,000 ops = 10,000x faster!"
          }
        },
        "codeTemplates": [
          {
            "name": "Basic Operations",
            "description": "Create, insert, lookup, delete, iterate",
            "javascript": {
              "code": "// Using Map (preferred for dynamic keys)\nconst map = new Map();\n\n// Insert key-value pairs\nmap.set('name', 'John');\nmap.set('age', 25);\nmap.set(123, 'numeric key works');  // Map allows non-string keys\n\n// Lookup\nconst name = map.get('name');       // 'John'\nconst missing = map.get('unknown'); // undefined\n\n// Check existence\nif (map.has('name')) {\n  console.log('Key exists');\n}\n\n// Delete\nmap.delete('age');\n\n// Size\nconsole.log(map.size);  // 2\n\n// Iterate\nfor (const [key, value] of map) {\n  console.log(key, value);\n}\n\n// Convert to array\nconst entries = [...map];  // [['name', 'John'], [123, 'numeric key works']]",
              "notes": "Use Map over {} when keys might not be strings, or when you need size property."
            },
            "python": {
              "code": "# Create dictionary\nd = {}\nd = dict()\nd = {'name': 'John', 'age': 25}\n\n# Insert / Update\nd['name'] = 'Jane'\nd['city'] = 'NYC'\n\n# Lookup\nname = d['name']              # 'Jane' (raises KeyError if missing)\nname = d.get('name')          # 'Jane' (returns None if missing)\nname = d.get('unknown', 'default')  # 'default'\n\n# Check existence\nif 'name' in d:\n    print('Key exists')\n\n# Delete\ndel d['age']                  # raises KeyError if missing\nremoved = d.pop('city', None) # returns value, or None if missing\n\n# Size\nprint(len(d))  # 1\n\n# Iterate\nfor key in d:\n    print(key, d[key])\n    \nfor key, value in d.items():\n    print(key, value)",
              "notes": "Use .get(key, default) to avoid KeyError. dict.items() for key-value iteration."
            }
          },
          {
            "name": "Two Sum Pattern",
            "description": "Find two numbers that sum to target - THE most common hash map problem",
            "javascript": {
              "code": "function twoSum(nums, target) {\n  const seen = new Map();  // value -> index\n  \n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    \n    // Have we seen the complement before?\n    if (seen.has(complement)) {\n      return [seen.get(complement), i];\n    }\n    \n    // Remember this number and its index\n    seen.set(nums[i], i);\n  }\n  \n  return [];  // No solution found\n}\n\n// Example: twoSum([2, 7, 11, 15], 9) ‚Üí [0, 1]\n// nums[0] + nums[1] = 2 + 7 = 9 ‚úì",
              "notes": "Key insight: Store what we've seen, look for complement. O(n¬≤) ‚Üí O(n)!"
            },
            "python": {
              "code": "def two_sum(nums, target):\n    seen = {}  # value -> index\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in seen:\n            return [seen[complement], i]\n        \n        seen[num] = i\n    \n    return []\n\n# Example: two_sum([2, 7, 11, 15], 9) ‚Üí [0, 1]",
              "notes": "enumerate(nums) gives both index and value. Pythonic!"
            }
          },
          {
            "name": "Frequency Counter Pattern",
            "description": "Count occurrences - used in anagrams, duplicates, majority element",
            "javascript": {
              "code": "// Count frequencies\nfunction countFreq(arr) {\n  const freq = new Map();\n  for (const item of arr) {\n    freq.set(item, (freq.get(item) || 0) + 1);\n  }\n  return freq;\n}\n\n// Find first non-repeating character\nfunction firstUnique(s) {\n  const freq = countFreq(s);\n  for (let i = 0; i < s.length; i++) {\n    if (freq.get(s[i]) === 1) return i;\n  }\n  return -1;\n}\n\n// Check if two strings are anagrams\nfunction isAnagram(s, t) {\n  if (s.length !== t.length) return false;\n  const freq = new Map();\n  for (const c of s) freq.set(c, (freq.get(c) || 0) + 1);\n  for (const c of t) {\n    if (!freq.has(c) || freq.get(c) === 0) return false;\n    freq.set(c, freq.get(c) - 1);\n  }\n  return true;\n}",
              "notes": "(map.get(key) || 0) + 1 handles missing keys elegantly."
            },
            "python": {
              "code": "from collections import Counter\n\n# Count frequencies\ndef count_freq(arr):\n    return Counter(arr)\n\n# Find first non-repeating character\ndef first_unique(s):\n    freq = Counter(s)\n    for i, c in enumerate(s):\n        if freq[c] == 1:\n            return i\n    return -1\n\n# Check anagrams\ndef is_anagram(s, t):\n    return Counter(s) == Counter(t)\n\n# Group anagrams\ndef group_anagrams(strs):\n    groups = {}\n    for s in strs:\n        key = tuple(sorted(s))  # or ''.join(sorted(s))\n        if key not in groups:\n            groups[key] = []\n        groups[key].append(s)\n    return list(groups.values())",
              "notes": "Counter is purpose-built for frequency counting. Counter('hello') ‚Üí Counter({'l': 2, ...})"
            }
          },
          {
            "name": "Prefix Sum with Hash Map",
            "description": "Find subarrays with target sum - combines prefix sum + hash map",
            "javascript": {
              "code": "// Count subarrays that sum to k\nfunction subarraySum(nums, k) {\n  const prefixCount = new Map([[0, 1]]);  // prefix sum 0 seen once\n  let sum = 0, count = 0;\n  \n  for (const num of nums) {\n    sum += num;\n    \n    // If (sum - k) exists as a prefix, we found subarrays\n    if (prefixCount.has(sum - k)) {\n      count += prefixCount.get(sum - k);\n    }\n    \n    prefixCount.set(sum, (prefixCount.get(sum) || 0) + 1);\n  }\n  \n  return count;\n}\n\n// subarraySum([1, 1, 1], 2) ‚Üí 2  (subarrays [1,1] at positions 0-1 and 1-2)",
              "notes": "If prefix[j] - prefix[i] = k, then subarray[i+1..j] sums to k."
            },
            "python": {
              "code": "def subarray_sum(nums, k):\n    prefix_count = {0: 1}  # prefix sum 0 seen once\n    total = 0\n    count = 0\n    \n    for num in nums:\n        total += num\n        \n        if total - k in prefix_count:\n            count += prefix_count[total - k]\n        \n        prefix_count[total] = prefix_count.get(total, 0) + 1\n    \n    return count\n\n# subarray_sum([1, 1, 1], 2) ‚Üí 2",
              "notes": "prefix_count stores how many times each prefix sum has occurred."
            }
          }
        ],
        "visualTrace": {
          "title": "Two Sum: nums=[2, 7, 11, 15], target=9",
          "input": {
            "array": [
              2,
              7,
              11,
              15
            ],
            "target": 9
          },
          "memoryTrace": {
            "description": "Watch hash map grow and complement check",
            "execution": [
              {
                "line": "const seen = new Map();",
                "memory": {
                  "seen": "{}"
                },
                "heap": {
                  "Map#1": "{}"
                },
                "note": "Empty map created"
              },
              {
                "line": "i=0: complement = 9 - 2 = 7",
                "memory": {
                  "i": 0,
                  "nums[i]": 2,
                  "complement": 7
                },
                "heap": {
                  "Map#1": "{}"
                },
                "note": "Looking for 7 in empty map..."
              },
              {
                "line": "seen.has(7)? NO",
                "memory": {
                  "i": 0
                },
                "heap": {
                  "Map#1": "{}"
                },
                "note": "7 not found. Store current value."
              },
              {
                "line": "seen.set(2, 0)",
                "memory": {
                  "i": 0
                },
                "heap": {
                  "Map#1": "{2 ‚Üí 0}"
                },
                "note": "Remember: value 2 is at index 0"
              },
              {
                "line": "i=1: complement = 9 - 7 = 2",
                "memory": {
                  "i": 1,
                  "nums[i]": 7,
                  "complement": 2
                },
                "heap": {
                  "Map#1": "{2 ‚Üí 0}"
                },
                "note": "Looking for 2..."
              },
              {
                "line": "seen.has(2)? YES! At index 0",
                "memory": {
                  "i": 1,
                  "complement": 2
                },
                "heap": {
                  "Map#1": "{2 ‚Üí 0}"
                },
                "note": "FOUND! 2 + 7 = 9 ‚úì"
              },
              {
                "line": "return [seen.get(2), i] = [0, 1]",
                "memory": {
                  "result": "[0, 1]"
                },
                "note": "nums[0] + nums[1] = 2 + 7 = 9"
              }
            ]
          },
          "steps": [
            {
              "step": 1,
              "i": 0,
              "value": 2,
              "complement": 7,
              "map": "{}",
              "found": false,
              "action": "Add 2‚Üí0"
            },
            {
              "step": 2,
              "i": 1,
              "value": 7,
              "complement": 2,
              "map": "{2:0}",
              "found": true,
              "action": "Return [0,1]"
            }
          ],
          "output": "[0, 1] because nums[0] + nums[1] = 2 + 7 = 9"
        },
        "commonMistakes": [
          {
            "mistake": "Object keys become strings in JavaScript",
            "wrong": "const obj = {}; obj[1] = 'one'; obj['1'] // 'one' - same key!",
            "right": "const map = new Map(); map.set(1, 'one'); map.set('1', 'str'); // different keys",
            "explanation": "Plain objects convert all keys to strings. Use Map for non-string keys."
          },
          {
            "mistake": "Missing key throws KeyError in Python",
            "wrong": "d = {}; val = d['missing']  # KeyError!",
            "right": "val = d.get('missing', default_value)  # Returns default",
            "explanation": "Always use .get() with a default, or check 'if key in d' first."
          },
          {
            "mistake": "Using mutable objects as dictionary keys",
            "wrong": "d = {}; d[[1,2,3]] = 'list'  # TypeError: unhashable type: 'list'",
            "right": "d = {}; d[(1,2,3)] = 'tuple'  # Tuples are immutable, OK as keys",
            "explanation": "Python dict keys must be hashable (immutable). Lists are mutable ‚Üí can't be keys."
          },
          {
            "mistake": "Forgetting to initialize counter for first occurrence",
            "wrong": "freq = {}; freq[char] += 1  # KeyError on first occurrence!",
            "right": "freq[char] = freq.get(char, 0) + 1  # or use defaultdict(int)",
            "explanation": "Key doesn't exist on first occurrence. Use .get(key, 0) or defaultdict."
          },
          {
            "mistake": "Map.get() returns undefined, not throwing error",
            "wrong": "const val = map.get(key) + 1;  // NaN if key missing (undefined + 1)",
            "right": "const val = (map.get(key) || 0) + 1;",
            "explanation": "Unlike Python, JS Map.get returns undefined silently. Always provide default."
          }
        ],
        "keyTakeaways": [
          "Hash maps give O(1) average lookup by COMPUTING location instead of SEARCHING",
          "Trade-off: Uses extra memory (bucket array), doesn't maintain order",
          "Two Sum pattern: Store seen values, look for complement ‚Üí O(n) instead of O(n¬≤)",
          "Frequency counter: Count occurrences in single pass, then query counts",
          "In JS: use Map over {} for non-string keys. In Python: use dict.get() to avoid KeyError",
          "Collisions are handled by chaining (linked list) or open addressing (probing)"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Array",
              "why": "Hash maps use arrays as bucket storage"
            },
            {
              "id": "big_o",
              "label": "Big O",
              "why": "Understanding O(1) vs O(n) is key to appreciating hash maps"
            }
          ],
          "nextTopics": [
            {
              "id": "two_pointers",
              "label": "Two Pointers",
              "why": "Alternative O(n) approach for sorted arrays (no extra space)"
            },
            {
              "id": "sliding_window",
              "label": "Sliding Window",
              "why": "Often combined with hash maps for substring problems"
            },
            {
              "id": "prefix_sum",
              "label": "Prefix Sum",
              "why": "Hash map stores prefix sums for subarray sum problems"
            },
            {
              "id": "lru_cache",
              "label": "LRU Cache",
              "why": "Classic problem combining hash map + doubly linked list"
            },
            {
              "id": "set",
              "label": "Hash Set",
              "why": "Hash map variant storing only keys (for membership testing)"
            }
          ]
        },
        "patternChain": {
          "description": "How Hash Map connects to patterns in the DSA graph",
          "buildsOn": [
            {
              "id": "array",
              "relationship": "Hash maps use arrays as the underlying bucket storage",
              "whatToKnow": "Understand array O(1) indexing to appreciate hash map O(1) lookup"
            },
            {
              "id": "hashing",
              "relationship": "Hash function converts keys to array indices",
              "whatToKnow": "Understand modulo arithmetic, collision handling"
            }
          ],
          "enables": [
            {
              "id": "two_sum",
              "relationship": "Complement lookup pattern: O(n¬≤) ‚Üí O(n)",
              "patternName": "Complement Lookup",
              "interviewFrequency": "Very High"
            },
            {
              "id": "sliding_window",
              "relationship": "Track character/element counts in window",
              "patternName": "Window State Tracking",
              "interviewFrequency": "High"
            },
            {
              "id": "prefix_sum",
              "relationship": "Store prefix sums for O(1) subarray sum lookup",
              "patternName": "Prefix Sum Frequency",
              "interviewFrequency": "High"
            },
            {
              "id": "group_anagrams",
              "relationship": "Group strings by sorted key or char count",
              "patternName": "Grouping by Key",
              "interviewFrequency": "High"
            },
            {
              "id": "lru_cache",
              "relationship": "O(1) access + O(1) LRU eviction via hash + linked list",
              "patternName": "Hash + Linked List",
              "interviewFrequency": "Very High"
            }
          ],
          "lineagePath": {
            "description": "Hash Map skill tree",
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart LR\n    ARR[Array] --> HASH[Hashing]\n    HASH --> HM[Hash Map]\n    HM --> TS[Two Sum]\n    HM --> SW[Sliding Window]\n    HM --> PS[Prefix Sum]\n    HM --> LRU[LRU Cache]\n    \n    style HM fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          },
          "relatedPatterns": [
            {
              "id": "set",
              "relationship": "Hash set = hash map with only keys (no values)"
            },
            {
              "id": "counter",
              "relationship": "Counter is specialized for frequency counting"
            },
            {
              "id": "defaultdict",
              "relationship": "Auto-initializes missing keys"
            }
          ]
        }
      }
    },
    {
      "id": "bloom",
      "label": "Bloom Filter",
      "type": "ds-probabilistic",
      "description": "Probabilistic set membership.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Bloom_filter"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-4 hours",
      "companies": [
        "Google",
        "Meta"
      ],
      "interviewFrequency": "low",
      "category": "Probabilistic DS",
      "categoryIcon": "üé≤",
      "content": {
        "definition": {
          "simple": "A space-efficient structure that answers 'maybe in set' or 'definitely not in set'. Can have false positives, never false negatives.",
          "technical": "Bit array with k hash functions. Insert sets k bits. Query checks if all k bits set. False positive rate ‚âà (1-e^(-kn/m))^k"
        },
        "keyTakeaways": [
          "No false negatives, possible false positives",
          "Very space efficient",
          "Cannot delete elements",
          "Used for caching, spam filters, DB queries"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "hashing",
              "label": "Hashing",
              "why": "Uses multiple hash functions"
            }
          ],
          "nextTopics": [
            {
              "id": "cuckoo_filter",
              "label": "Cuckoo Filter",
              "why": "Supports deletion"
            }
          ]
        }
      }
    },
    {
      "id": "stack",
      "label": "Stack",
      "type": "ds-abstract",
      "description": "LIFO (Last In, First Out).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Stack_(abstract_data_type)"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/list"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/stack/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/stack-data-structure/"
          }
        ]
      },
      "difficulty": 2,
      "timeEstimate": "1-2 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft",
        "Bloomberg"
      ],
      "interviewFrequency": "high",
      "category": "Abstract DS",
      "categoryIcon": "üì¶",
      "interviewQuestions": [
        {
          "name": "Valid Parentheses",
          "leetcode": "https://leetcode.com/problems/valid-parentheses/",
          "difficulty": "Easy",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Bloomberg"
          ],
          "frequency": "Very High",
          "whyAsked": "Classic stack for matching pairs",
          "approach": "Push opening brackets. Pop and match for closing. Stack empty at end = valid",
          "followUps": [
            {
              "question": "Longest valid parentheses?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Minimum remove for valid?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "Min Stack",
          "leetcode": "https://leetcode.com/problems/min-stack/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Microsoft",
            "Bloomberg"
          ],
          "frequency": "High",
          "whyAsked": "Design stack with O(1) getMin - tests auxiliary data structure",
          "approach": "Two stacks: main + mins. Or store (value, currentMin) pairs. All ops O(1)",
          "followUps": [
            {
              "question": "Max stack with popMax?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Space optimization?",
              "answer": "Usually can't optimize bitmask DP space - need previous states arbitrarily."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Daily Temperatures",
          "leetcode": "https://leetcode.com/problems/daily-temperatures/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google"
          ],
          "frequency": "High",
          "whyAsked": "Monotonic decreasing stack - next greater element pattern",
          "approach": "Stack of indices. Pop when current > top. Answer = current_idx - popped_idx. O(n)",
          "followUps": [
            {
              "question": "Next greater element variants?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Circular array?",
              "answer": "Max of: normal Kadane, or total_sum - min_subarray_sum. Handle all-negative case."
            }
          ],
          "sources": [
            "neetcode150",
            "seanprashad"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Sean Prashad's Patterns",
              "url": "https://seanprashad.com/leetcode-patterns/",
              "note": "Pattern-based problem categorization"
            }
          ]
        },
        {
          "name": "Largest Rectangle in Histogram",
          "leetcode": "https://leetcode.com/problems/largest-rectangle-in-histogram/",
          "difficulty": "Hard",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Microsoft"
          ],
          "frequency": "High",
          "whyAsked": "Classic monotonic stack problem - finding spans",
          "approach": "Monotonic increasing stack. When smaller bar found, calculate area. O(n)",
          "followUps": [
            {
              "question": "Maximal rectangle in binary matrix?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Trapping rain water?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Basic Calculator II",
          "leetcode": "https://leetcode.com/problems/basic-calculator-ii/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Microsoft",
            "Google"
          ],
          "frequency": "High",
          "whyAsked": "Expression evaluation with operator precedence",
          "approach": "Stack for values. Process * and / immediately. Add/subtract push to stack. Sum at end",
          "followUps": [
            {
              "question": "With parentheses?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "With variables?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "teamblind"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Blind (Teamblind)",
              "url": "https://www.teamblind.com/",
              "note": "Crowdsourced interview experiences from FAANG employees"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based problem categorization"
        },
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with video explanations"
        }
      ],
      "content": {
        "definition": {
          "simple": "A stack is like a pile of plates - you can only add or remove from the top. Last In, First Out (LIFO).",
          "technical": "A stack is an abstract data type with two principal operations: push (add to top) and pop (remove from top). It follows Last-In-First-Out (LIFO) ordering, where the most recently added element is the first to be removed."
        },
        "howItWorks": {
          "explanation": "Think of a stack of cafeteria trays. You can only take from the top (pop) or add to the top (push). You can't grab a tray from the middle without removing all the ones above it first.",
          "steps": [
            {
              "step": 1,
              "title": "Push",
              "description": "Add element to top of stack. If using array, add at end.",
              "why": "O(1) - just increment top pointer and write."
            },
            {
              "step": 2,
              "title": "Pop",
              "description": "Remove and return top element. If using array, remove from end.",
              "why": "O(1) - just read and decrement top pointer."
            },
            {
              "step": 3,
              "title": "Peek/Top",
              "description": "Look at top element without removing it.",
              "why": "O(1) - just read, no modification."
            },
            {
              "step": 4,
              "title": "isEmpty",
              "description": "Check if stack has no elements.",
              "why": "O(1) - compare top pointer to -1 or 0."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TB\n    subgraph Stack\n        TOP[\"TOP ‚Üí\"] --> E3[\"30\"]\n        E3 --> E2[\"20\"]\n        E2 --> E1[\"10\"]\n        E1 --> BOT[\"BOTTOM\"]\n    end\n    \n    PUSH[\"push(40)\"] -.-> TOP\n    POP[\"pop() ‚Üí 30\"] -.-> E3\n    \n    style E3 fill:#ee6c4d\n    style TOP fill:#98c1d9",
            "caption": "Stack: push adds to top, pop removes from top. LIFO order."
          }
        },
        "whenToUse": {
          "summary": "Use stacks when you need LIFO ordering - undo operations, parsing, DFS traversal.",
          "patterns": [
            {
              "pattern": "Undo/Redo Operations",
              "signal": "Need to reverse recent actions",
              "example": "Text editor undo, browser back button",
              "withoutIt": "Track all history, search for last action",
              "withIt": "Pop from stack = instant undo"
            },
            {
              "pattern": "Matching Parentheses/Brackets",
              "signal": "Validate or match nested structures",
              "example": "Valid parentheses: ({[]})",
              "withoutIt": "Complex counting logic with edge cases",
              "withIt": "Push opens, pop for closes, check match"
            },
            {
              "pattern": "DFS / Backtracking",
              "signal": "Explore paths, backtrack when stuck",
              "example": "Maze solving, tree traversal",
              "withoutIt": "Recursion uses call stack anyway",
              "withIt": "Explicit stack avoids recursion limits"
            },
            {
              "pattern": "Expression Evaluation",
              "signal": "Evaluate infix/postfix expressions",
              "example": "Calculate: 3 + 4 * 2",
              "withoutIt": "Complex precedence handling",
              "withIt": "Operators on stack, apply when precedence resolves"
            },
            {
              "pattern": "Monotonic Stack",
              "signal": "Find next greater/smaller element",
              "example": "Next greater element, stock span",
              "withoutIt": "O(n¬≤) nested loops",
              "withIt": "O(n) with stack maintaining monotonic order"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Stacks only access the top. Avoid when you need random access or FIFO order.",
          "antiPatterns": [
            {
              "situation": "Need FIFO Order",
              "why": "Stack is LIFO",
              "useInstead": "Queue",
              "example": "Task scheduling, BFS"
            },
            {
              "situation": "Need Random Access",
              "why": "Can only see top",
              "useInstead": "Array or HashMap",
              "example": "Access middle elements"
            },
            {
              "situation": "Need to Search",
              "why": "Must pop everything to find",
              "useInstead": "Set or HashMap",
              "example": "Check if value exists"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Plate Stack",
            "story": "In a cafeteria, clean plates are stacked. You take from the top (pop), and the dishwasher adds to the top (push). The plate you just added is the first one that will be taken. That's LIFO - Last In, First Out.",
            "connection": "Function calls work the same way! When you call a function, it goes on the call stack. When it returns, it pops off. That's why recursive functions can cause 'stack overflow'."
          },
          "keyInsight": "Stacks naturally model any process where you need to 'go back' to the previous state - undo, backtracking, matching brackets. If you're thinking 'I need to remember where I was', you probably need a stack.",
          "commonConfusion": [
            {
              "confusion": "When to use stack vs queue?",
              "clarification": "Stack = LIFO (undo, DFS, backtracking). Queue = FIFO (scheduling, BFS, waiting lines)."
            },
            {
              "confusion": "Array vs linked list for stack?",
              "clarification": "Array is usually better (cache-friendly, simpler). Linked list only if you need unbounded size without resize overhead."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "push",
                "average": "O(1)",
                "worst": "O(1)*",
                "note": "*O(n) if array needs resize"
              },
              {
                "operation": "pop",
                "average": "O(1)",
                "worst": "O(1)",
                "note": "Always constant"
              },
              {
                "operation": "peek/top",
                "average": "O(1)",
                "worst": "O(1)",
                "note": "Just read"
              },
              {
                "operation": "isEmpty",
                "average": "O(1)",
                "worst": "O(1)",
                "note": "Check size"
              }
            ],
            "explanation": "All operations are O(1) because we only interact with the top."
          },
          "space": {
            "complexity": "O(n)",
            "explanation": "Store n elements"
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Stack is typically implemented with array (push/pop at end) or linked list (push/pop at head).",
            "keyPoints": [
              "Array-based: top pointer tracks last element index",
              "Linked list: head is the top, push/pop at head",
              "Call stack: separate memory region, grows downward on most systems",
              "Each function call pushes a 'stack frame' with local variables and return address"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Use array with push() and pop(). No built-in Stack class.",
              "gotchas": [
                "Don't use shift()/unshift() - those are O(n)",
                "Array is the stack"
              ]
            },
            "python": {
              "implementation": "Use list with append() and pop(). No built-in Stack class.",
              "gotchas": [
                "list.pop() is O(1) at end",
                "Don't use pop(0) - that's O(n)",
                "collections.deque works but overkill for stack"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Push and pop are O(1)",
            "proof": {
              "step1": {
                "action": "Access top index",
                "cost": "O(1)"
              },
              "step2": {
                "action": "Write/read at index",
                "cost": "O(1)"
              },
              "step3": {
                "action": "Increment/decrement top",
                "cost": "O(1)"
              }
            },
            "totalCost": "O(1)"
          }
        },
        "codeTemplates": [
          {
            "name": "Basic Stack Operations",
            "description": "Push, pop, peek using array",
            "javascript": {
              "code": "// Stack using array\nconst stack = [];\n\n// Push - add to top\nstack.push(10);\nstack.push(20);\nstack.push(30);  // [10, 20, 30]\n\n// Pop - remove from top\nconst top = stack.pop();  // 30, stack is now [10, 20]\n\n// Peek - look at top without removing\nconst peek = stack[stack.length - 1];  // 20\n\n// isEmpty\nconst isEmpty = stack.length === 0;  // false",
              "notes": "In JS, arrays ARE stacks. push/pop at end is O(1)."
            },
            "python": {
              "code": "# Stack using list\nstack = []\n\n# Push\nstack.append(10)\nstack.append(20)\nstack.append(30)  # [10, 20, 30]\n\n# Pop\ntop = stack.pop()  # 30, stack is [10, 20]\n\n# Peek\npeek = stack[-1]  # 20\n\n# isEmpty\nis_empty = len(stack) == 0  # False",
              "notes": "Use append/pop at end. Don't use pop(0)!"
            }
          },
          {
            "name": "Valid Parentheses",
            "description": "Classic stack problem - match brackets",
            "javascript": {
              "code": "function isValid(s) {\n  const stack = [];\n  const pairs = { ')': '(', '}': '{', ']': '[' };\n  \n  for (const char of s) {\n    if (char === '(' || char === '{' || char === '[') {\n      stack.push(char);  // Push opening brackets\n    } else {\n      // Closing bracket - check match\n      if (stack.length === 0 || stack.pop() !== pairs[char]) {\n        return false;\n      }\n    }\n  }\n  \n  return stack.length === 0;  // All matched?\n}\n\n// isValid(\"({[]})\") ‚Üí true\n// isValid(\"([)]\") ‚Üí false",
              "notes": "Push opens, pop for closes. Final stack must be empty."
            },
            "python": {
              "code": "def is_valid(s):\n    stack = []\n    pairs = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in '({[':\n            stack.append(char)\n        else:\n            if not stack or stack.pop() != pairs[char]:\n                return False\n    \n    return len(stack) == 0",
              "notes": "Same pattern: push opens, pop and match for closes."
            }
          },
          {
            "name": "Monotonic Stack - Next Greater Element",
            "description": "Find next greater element for each position",
            "javascript": {
              "code": "function nextGreaterElement(nums) {\n  const result = new Array(nums.length).fill(-1);\n  const stack = [];  // Stack of indices\n  \n  for (let i = 0; i < nums.length; i++) {\n    // Pop elements smaller than current\n    while (stack.length && nums[stack[stack.length - 1]] < nums[i]) {\n      const idx = stack.pop();\n      result[idx] = nums[i];  // Current is next greater\n    }\n    stack.push(i);\n  }\n  \n  return result;\n}\n\n// nextGreaterElement([2, 1, 2, 4, 3])\n// ‚Üí [4, 2, 4, -1, -1]",
              "notes": "Stack maintains decreasing order. When we find greater, pop and record."
            },
            "python": {
              "code": "def next_greater_element(nums):\n    result = [-1] * len(nums)\n    stack = []  # Stack of indices\n    \n    for i, num in enumerate(nums):\n        while stack and nums[stack[-1]] < num:\n            idx = stack.pop()\n            result[idx] = num\n        stack.append(i)\n    \n    return result",
              "notes": "O(n) - each element pushed and popped at most once."
            }
          }
        ],
        "visualTrace": {
          "title": "Valid Parentheses: ({[]})",
          "input": {
            "string": "({[]})"
          },
          "steps": [
            {
              "char": "(",
              "action": "Push",
              "stack": "['(']"
            },
            {
              "char": "{",
              "action": "Push",
              "stack": "['(', '{']"
            },
            {
              "char": "[",
              "action": "Push",
              "stack": "['(', '{', '[']"
            },
            {
              "char": "]",
              "action": "Pop '[', matches!",
              "stack": "['(', '{']"
            },
            {
              "char": "}",
              "action": "Pop '{', matches!",
              "stack": "['(']"
            },
            {
              "char": ")",
              "action": "Pop '(', matches!",
              "stack": "[]"
            },
            {
              "result": "Stack empty ‚Üí Valid!"
            }
          ]
        },
        "commonMistakes": [
          {
            "mistake": "Popping from empty stack",
            "wrong": "stack.pop() // when empty = undefined or error",
            "right": "if (stack.length) stack.pop()",
            "explanation": "Always check isEmpty before pop."
          },
          {
            "mistake": "Using shift/unshift in JS",
            "wrong": "stack.shift() // O(n)!",
            "right": "stack.pop() // O(1)",
            "explanation": "shift/unshift operate at beginning - O(n) due to shifting."
          },
          {
            "mistake": "Using pop(0) in Python",
            "wrong": "stack.pop(0) // O(n)!",
            "right": "stack.pop() // O(1)",
            "explanation": "pop(0) shifts all elements - use pop() at end."
          }
        ],
        "keyTakeaways": [
          "Stack = LIFO. push() adds to top, pop() removes from top. Both O(1).",
          "Use for: undo, matching brackets, DFS, expression evaluation, monotonic stack",
          "In JS: array with push/pop. In Python: list with append/pop",
          "Call stack is literally a stack - function calls push, returns pop",
          "Monotonic stack pattern: O(n) solution for next greater/smaller element problems"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Array",
              "why": "Stacks often implemented with arrays"
            },
            {
              "id": "ll",
              "label": "Linked List",
              "why": "Alternative implementation"
            }
          ],
          "nextTopics": [
            {
              "id": "queue",
              "label": "Queue",
              "why": "FIFO counterpart to LIFO stack"
            },
            {
              "id": "dfs",
              "label": "DFS",
              "why": "Stack-based graph traversal"
            },
            {
              "id": "recursion",
              "label": "Recursion",
              "why": "Uses call stack implicitly"
            },
            {
              "id": "monotonic_stack",
              "label": "Monotonic Stack",
              "why": "Advanced stack pattern"
            }
          ]
        },
        "patternChain": {
          "description": "Stack connections in DSA graph",
          "buildsOn": [
            {
              "id": "array",
              "relationship": "Array is typical underlying storage",
              "whatToKnow": "push/pop at end is O(1)"
            }
          ],
          "enables": [
            {
              "id": "valid_parens",
              "relationship": "Match brackets with push/pop",
              "patternName": "Bracket Matching",
              "interviewFrequency": "Very High"
            },
            {
              "id": "dfs",
              "relationship": "Explicit stack for iterative DFS",
              "patternName": "Iterative DFS",
              "interviewFrequency": "High"
            },
            {
              "id": "monotonic_stack",
              "relationship": "Next greater/smaller element",
              "patternName": "Monotonic Stack",
              "interviewFrequency": "High"
            },
            {
              "id": "calculator",
              "relationship": "Expression evaluation with operator stack",
              "patternName": "Calculator",
              "interviewFrequency": "Medium"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart LR\n    ARR[Array] --> STK[Stack]\n    STK --> PAR[Valid Parentheses]\n    STK --> DFS[DFS Traversal]\n    STK --> MONO[Monotonic Stack]\n    STK --> CALC[Calculator]\n    \n    style STK fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "queue",
      "label": "Queue",
      "type": "ds-abstract",
      "description": "FIFO (First In, First Out).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Queue_(abstract_data_type)"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/list"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/queue/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/queue-data-structure/"
          }
        ]
      },
      "difficulty": 2,
      "timeEstimate": "1-2 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft"
      ],
      "interviewFrequency": "medium",
      "category": "Abstract DS",
      "categoryIcon": "üì¶",
      "interviewQuestions": [
        {
          "name": "Implement Queue using Stacks",
          "leetcode": "https://leetcode.com/problems/implement-queue-using-stacks/",
          "difficulty": "Easy",
          "companies": [
            "Amazon",
            "Microsoft",
            "Apple"
          ],
          "frequency": "High",
          "whyAsked": "Understanding of stack/queue LIFO vs FIFO, amortized analysis",
          "approach": "Two stacks: input and output. Push to input. On pop/peek, transfer to output if empty",
          "followUps": [
            {
              "question": "Amortized O(1)?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Implement stack using queues?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Design Circular Queue",
          "leetcode": "https://leetcode.com/problems/design-circular-queue/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon"
          ],
          "frequency": "Medium",
          "whyAsked": "Circular buffer implementation - modular arithmetic",
          "approach": "Array with front and rear pointers. Use modulo for wrapping. Track count or isEmpty",
          "followUps": [
            {
              "question": "Thread-safe version?",
              "answer": "Use lock for all operations, or lock-free with CAS for enqueue/dequeue. Producer-consumer patterns."
            },
            {
              "question": "Dynamic resizing?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Number of Recent Calls",
          "leetcode": "https://leetcode.com/problems/number-of-recent-calls/",
          "difficulty": "Easy",
          "companies": [
            "Amazon"
          ],
          "frequency": "Medium",
          "whyAsked": "Sliding window with queue - discard old timestamps",
          "approach": "Queue of timestamps. On ping, remove timestamps older than t-3000. Return size",
          "followUps": [
            {
              "question": "Optimize for high frequency?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "With variable window?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "leetcode"
          ],
          "sourceDetails": [
            {
              "name": "LeetCode",
              "url": "https://leetcode.com/problemset/",
              "note": "Problem difficulty and company tags"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with videos"
        }
      ],
      "content": {
        "definition": {
          "simple": "A queue is like a line at a store - first person in line is first to be served. First In, First Out (FIFO).",
          "technical": "A queue is an abstract data type with enqueue (add to back) and dequeue (remove from front) operations. It follows First-In-First-Out (FIFO) ordering, where elements are processed in the order they were added."
        },
        "howItWorks": {
          "explanation": "Think of a line at a coffee shop. New customers join at the back (enqueue). The person at the front gets served and leaves (dequeue). Fair and orderly - whoever arrived first gets served first.",
          "steps": [
            {
              "step": 1,
              "title": "Enqueue",
              "description": "Add element to back of queue.",
              "why": "O(1) with proper implementation (linked list or circular array)."
            },
            {
              "step": 2,
              "title": "Dequeue",
              "description": "Remove and return element from front.",
              "why": "O(1) - just update front pointer."
            },
            {
              "step": 3,
              "title": "Peek/Front",
              "description": "Look at front element without removing.",
              "why": "O(1) - just read."
            },
            {
              "step": 4,
              "title": "isEmpty",
              "description": "Check if queue has no elements.",
              "why": "O(1) - compare front and back pointers."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart LR\n    DEQ[\"dequeue()\"] -.-> FRONT\n    subgraph Queue\n        FRONT[\"10\"] --> M1[\"20\"] --> M2[\"30\"] --> BACK[\"40\"]\n    end\n    ENQ[\"enqueue(50)\"] -.-> BACK\n    \n    style FRONT fill:#ee6c4d\n    style BACK fill:#98c1d9",
            "caption": "Queue: enqueue adds to back, dequeue removes from front. FIFO order."
          }
        },
        "whenToUse": {
          "summary": "Use queues when you need FIFO ordering - scheduling, BFS traversal, buffering.",
          "patterns": [
            {
              "pattern": "BFS - Level-Order Traversal",
              "signal": "Explore nodes level by level, find shortest path in unweighted graph",
              "example": "Shortest path in maze, level order of tree",
              "withoutIt": "Would need to track levels manually",
              "withIt": "Queue naturally processes level by level"
            },
            {
              "pattern": "Task Scheduling",
              "signal": "Process tasks in order they arrived",
              "example": "Print queue, request handling, CPU scheduling",
              "withoutIt": "Unfair - some tasks could starve",
              "withIt": "Fair ordering - first come, first served"
            },
            {
              "pattern": "Sliding Window (with Deque)",
              "signal": "Track max/min in sliding window",
              "example": "Sliding window maximum",
              "withoutIt": "O(n*k) - recalculate max for each window",
              "withIt": "O(n) with monotonic deque"
            },
            {
              "pattern": "Rate Limiting / Buffering",
              "signal": "Process items at controlled rate",
              "example": "API rate limiter, video buffer",
              "withoutIt": "Complex timing logic",
              "withIt": "Buffer in queue, process from front"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Queues only access front and back. Avoid when you need LIFO or random access.",
          "antiPatterns": [
            {
              "situation": "Need LIFO Order",
              "why": "Queue is FIFO",
              "useInstead": "Stack",
              "example": "Undo operations"
            },
            {
              "situation": "Need Random Access",
              "why": "Can only see front",
              "useInstead": "Array or HashMap",
              "example": "Access by index"
            },
            {
              "situation": "Need Priority-Based Order",
              "why": "Queue is strictly FIFO",
              "useInstead": "Priority Queue/Heap",
              "example": "Process urgent tasks first"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Coffee Shop Line",
            "story": "A queue is like waiting in line at a coffee shop. You join at the back, wait your turn, and eventually reach the front to be served. It's fair - whoever arrived first gets served first. No cutting in line!",
            "connection": "BFS works the same way. We 'discover' nodes and add them to the back of the queue. We process nodes from the front, ensuring we visit closer nodes before farther ones."
          },
          "keyInsight": "Queues model any 'waiting' scenario. If items should be processed in arrival order, you need a queue. BFS uses a queue because it must process all neighbors at distance 1 before distance 2.",
          "commonConfusion": [
            {
              "confusion": "Stack vs Queue for graph traversal?",
              "clarification": "Queue ‚Üí BFS (level by level, shortest path). Stack ‚Üí DFS (go deep first, backtrack)."
            },
            {
              "confusion": "Array-based queue in JS?",
              "clarification": "shift() is O(n)! Use a proper circular buffer or just use indices with an object/Map."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "enqueue",
                "average": "O(1)",
                "worst": "O(1)",
                "note": "Add to back"
              },
              {
                "operation": "dequeue",
                "average": "O(1)",
                "worst": "O(1)",
                "note": "Remove from front"
              },
              {
                "operation": "peek/front",
                "average": "O(1)",
                "worst": "O(1)",
                "note": "Just read"
              },
              {
                "operation": "isEmpty",
                "average": "O(1)",
                "worst": "O(1)",
                "note": "Check size"
              }
            ],
            "explanation": "All O(1) with proper implementation (linked list or circular array)."
          },
          "space": {
            "complexity": "O(n)",
            "explanation": "Store n elements"
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Queues can be implemented with linked list (O(1) at both ends) or circular array (avoids shifting).",
            "keyPoints": [
              "Linked list: enqueue at tail, dequeue at head - both O(1)",
              "Circular array: front and back pointers wrap around",
              "Simple array with shift() is O(n) - avoid!",
              "JS has no built-in Queue - use array carefully or implement circular buffer"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "No built-in Queue. Array shift() is O(n)! Use object with head/tail indices for O(1).",
              "gotchas": [
                "shift() is O(n) - don't use for queue!",
                "Implement with object: {0: 'a', 1: 'b'} and head/tail indices",
                "Or use Map which maintains insertion order"
              ]
            },
            "python": {
              "implementation": "Use collections.deque - optimized for O(1) at both ends.",
              "gotchas": [
                "list.pop(0) is O(n)!",
                "deque.append() and deque.popleft() are O(1)",
                "deque is implemented as doubly-linked list of blocks"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Enqueue and dequeue are O(1) with linked list",
            "proof": {
              "step1": {
                "action": "Access tail/head pointer",
                "cost": "O(1)"
              },
              "step2": {
                "action": "Create/remove node",
                "cost": "O(1)"
              },
              "step3": {
                "action": "Update pointers",
                "cost": "O(1)"
              }
            },
            "totalCost": "O(1)"
          }
        },
        "codeTemplates": [
          {
            "name": "Queue Using Proper Data Structure",
            "description": "O(1) operations in both languages",
            "javascript": {
              "code": "// Queue with object (O(1) operations)\nclass Queue {\n  constructor() {\n    this.items = {};\n    this.head = 0;\n    this.tail = 0;\n  }\n  \n  enqueue(item) {\n    this.items[this.tail] = item;\n    this.tail++;\n  }\n  \n  dequeue() {\n    if (this.isEmpty()) return undefined;\n    const item = this.items[this.head];\n    delete this.items[this.head];\n    this.head++;\n    return item;\n  }\n  \n  peek() {\n    return this.items[this.head];\n  }\n  \n  isEmpty() {\n    return this.tail === this.head;\n  }\n  \n  size() {\n    return this.tail - this.head;\n  }\n}\n\nconst q = new Queue();\nq.enqueue(1); q.enqueue(2); q.enqueue(3);\nq.dequeue();  // 1\nq.peek();     // 2",
              "notes": "Object with indices = O(1). Don't use array.shift()!"
            },
            "python": {
              "code": "from collections import deque\n\n# Use deque for O(1) queue operations\nq = deque()\n\n# Enqueue (add to back)\nq.append(1)\nq.append(2)\nq.append(3)  # deque([1, 2, 3])\n\n# Dequeue (remove from front)\nfront = q.popleft()  # 1, deque is [2, 3]\n\n# Peek\npeek = q[0]  # 2\n\n# isEmpty\nis_empty = len(q) == 0\n\n# Size\nsize = len(q)",
              "notes": "deque is the standard choice. Don't use list.pop(0)!"
            }
          },
          {
            "name": "BFS Template",
            "description": "Level-order traversal with queue",
            "javascript": {
              "code": "function bfs(root) {\n  if (!root) return [];\n  \n  const result = [];\n  const queue = [root];  // OK for BFS - shift is occasional\n  \n  while (queue.length > 0) {\n    const node = queue.shift();\n    result.push(node.val);\n    \n    // Add children to back of queue\n    if (node.left) queue.push(node.left);\n    if (node.right) queue.push(node.right);\n  }\n  \n  return result;\n}\n\n// Level-by-level with level tracking\nfunction levelOrder(root) {\n  if (!root) return [];\n  \n  const result = [];\n  const queue = [root];\n  \n  while (queue.length > 0) {\n    const levelSize = queue.length;\n    const currentLevel = [];\n    \n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.shift();\n      currentLevel.push(node.val);\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    \n    result.push(currentLevel);\n  }\n  \n  return result;\n}",
              "notes": "For BFS, shift() is acceptable since it's not in tight loop relative to n."
            },
            "python": {
              "code": "from collections import deque\n\ndef bfs(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        node = queue.popleft()\n        result.append(node.val)\n        \n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n    \n    return result\n\ndef level_order(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        current_level = []\n        \n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(current_level)\n    \n    return result",
              "notes": "Level order: process queue.length nodes per level before moving to next."
            }
          },
          {
            "name": "Sliding Window Maximum (Monotonic Deque)",
            "description": "O(n) max in each window position",
            "javascript": {
              "code": "function maxSlidingWindow(nums, k) {\n  const result = [];\n  const deque = [];  // Indices, maintaining decreasing order of values\n  \n  for (let i = 0; i < nums.length; i++) {\n    // Remove indices outside window\n    while (deque.length && deque[0] < i - k + 1) {\n      deque.shift();\n    }\n    \n    // Remove smaller elements (they'll never be max)\n    while (deque.length && nums[deque[deque.length - 1]] < nums[i]) {\n      deque.pop();\n    }\n    \n    deque.push(i);\n    \n    // Window is full, record max (front of deque)\n    if (i >= k - 1) {\n      result.push(nums[deque[0]]);\n    }\n  }\n  \n  return result;\n}\n\n// maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3) ‚Üí [3,3,5,5,6,7]",
              "notes": "Deque stores indices. Front is always max in current window."
            },
            "python": {
              "code": "from collections import deque\n\ndef max_sliding_window(nums, k):\n    result = []\n    dq = deque()  # Stores indices\n    \n    for i, num in enumerate(nums):\n        # Remove indices outside window\n        while dq and dq[0] < i - k + 1:\n            dq.popleft()\n        \n        # Remove smaller elements\n        while dq and nums[dq[-1]] < num:\n            dq.pop()\n        \n        dq.append(i)\n        \n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    \n    return result",
              "notes": "Monotonic deque: front is max, back is for new insertions."
            }
          }
        ],
        "visualTrace": {
          "title": "BFS Level Order: Tree [3, 9, 20, null, null, 15, 7]",
          "input": {
            "tree": "     3\n    / \\\n   9  20\n      / \\\n     15  7"
          },
          "steps": [
            {
              "queue": "[3]",
              "processing": "3",
              "result": "[[3]]",
              "action": "Add 9, 20"
            },
            {
              "queue": "[9, 20]",
              "processing": "9",
              "result": "[[3], [9...]]",
              "action": "No children"
            },
            {
              "queue": "[20]",
              "processing": "20",
              "result": "[[3], [9, 20]]",
              "action": "Add 15, 7"
            },
            {
              "queue": "[15, 7]",
              "processing": "15, 7",
              "result": "[[3], [9, 20], [15, 7]]",
              "action": "Done"
            }
          ],
          "output": "[[3], [9, 20], [15, 7]]"
        },
        "commonMistakes": [
          {
            "mistake": "Using array.shift() for high-performance queue",
            "wrong": "const front = queue.shift(); // O(n)!",
            "right": "Use deque or object-based queue",
            "explanation": "shift() moves all elements - O(n). Fine for BFS, bad for millions of operations."
          },
          {
            "mistake": "Using list.pop(0) in Python",
            "wrong": "front = queue.pop(0) // O(n)!",
            "right": "from collections import deque; front = queue.popleft()",
            "explanation": "pop(0) is O(n). deque.popleft() is O(1)."
          },
          {
            "mistake": "Forgetting to check empty before dequeue",
            "wrong": "queue.popleft() // Error if empty!",
            "right": "if queue: front = queue.popleft()",
            "explanation": "Always check isEmpty before dequeue."
          }
        ],
        "keyTakeaways": [
          "Queue = FIFO. enqueue adds to back, dequeue removes from front. Both O(1).",
          "Use for: BFS, scheduling, buffering, level-order traversal",
          "In JS: DON'T use shift() for perf - use object with indices",
          "In Python: USE collections.deque - popleft() is O(1)",
          "BFS pattern: process queue.length nodes per level for level-order",
          "Deque (double-ended queue) enables sliding window max/min in O(n)"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Array",
              "why": "Can implement queue with circular array"
            },
            {
              "id": "ll",
              "label": "Linked List",
              "why": "Natural O(1) queue implementation"
            }
          ],
          "nextTopics": [
            {
              "id": "bfs",
              "label": "BFS",
              "why": "Queue-based graph/tree traversal"
            },
            {
              "id": "pq",
              "label": "Priority Queue",
              "why": "Queue with ordering by priority"
            },
            {
              "id": "sliding_window",
              "label": "Sliding Window",
              "why": "Deque for max/min in window"
            }
          ]
        },
        "patternChain": {
          "description": "Queue connections in DSA graph",
          "buildsOn": [
            {
              "id": "ll",
              "relationship": "Linked list enables O(1) at both ends",
              "whatToKnow": "Tail pointer for O(1) enqueue"
            }
          ],
          "enables": [
            {
              "id": "bfs",
              "relationship": "Queue processes nodes level by level",
              "patternName": "BFS Traversal",
              "interviewFrequency": "Very High"
            },
            {
              "id": "level_order",
              "relationship": "Tree level order uses queue",
              "patternName": "Level Order",
              "interviewFrequency": "High"
            },
            {
              "id": "sliding_window_max",
              "relationship": "Monotonic deque for O(n) window max",
              "patternName": "Monotonic Deque",
              "interviewFrequency": "Medium"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart LR\n    LL[Linked List] --> Q[Queue]\n    Q --> BFS[BFS]\n    Q --> LVL[Level Order]\n    Q --> SWM[Sliding Window Max]\n    \n    style Q fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "recursion",
      "label": "Recursion",
      "type": "concept",
      "description": "Function calling itself.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Recursion_(computer_science)"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/recursion/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/recursion/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "3-4 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft",
        "Apple"
      ],
      "interviewFrequency": "high",
      "category": "Concept",
      "categoryIcon": "üí°",
      "interviewQuestions": [
        {
          "name": "Pow(x, n)",
          "leetcode": "https://leetcode.com/problems/powx-n/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Fast exponentiation - divide and conquer recursion",
          "approach": "x^n = (x^(n/2))^2 if even, x * x^(n-1) if odd. Handle negative n",
          "followUps": [
            {
              "question": "Iterative version?",
              "answer": "Use explicit stack. Push children in reverse order for same traversal order as recursive."
            },
            {
              "question": "Modular exponentiation?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Reverse Linked List",
          "leetcode": "https://leetcode.com/problems/reverse-linked-list/",
          "difficulty": "Easy",
          "companies": [
            "Amazon",
            "Microsoft",
            "Apple",
            "Google"
          ],
          "frequency": "Very High",
          "whyAsked": "Recursive and iterative solutions - understand call stack",
          "approach": "Recursive: reverse rest, then curr.next.next = curr. Base: null or single node",
          "followUps": [
            {
              "question": "Reverse in groups of k?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Iterative version?",
              "answer": "Use explicit stack. Push children in reverse order for same traversal order as recursive."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Merge Two Sorted Lists",
          "leetcode": "https://leetcode.com/problems/merge-two-sorted-lists/",
          "difficulty": "Easy",
          "companies": [
            "Amazon",
            "Microsoft",
            "Google"
          ],
          "frequency": "Very High",
          "whyAsked": "Recursive merge logic - smaller head + merge rest",
          "approach": "Compare heads, smaller becomes result head. Recurse on smaller.next and other",
          "followUps": [
            {
              "question": "Merge k lists?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Iterative version?",
              "answer": "Use explicit stack. Push children in reverse order for same traversal order as recursive."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Letter Combinations of Phone",
          "leetcode": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google"
          ],
          "frequency": "High",
          "whyAsked": "Generate all combinations recursively",
          "approach": "For each digit, add each mapped letter to current path. Recurse to next digit",
          "followUps": [
            {
              "question": "Return in sorted order?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "With wildcards?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Generate Parentheses",
          "leetcode": "https://leetcode.com/problems/generate-parentheses/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Recursion with constraints - track open/close counts",
          "approach": "Add '(' if open < n. Add ')' if close < open. Base: length = 2n",
          "followUps": [
            {
              "question": "Check if valid?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Different bracket types?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with videos"
        }
      ],
      "content": {
        "definition": {
          "simple": "Recursion is when a function calls itself to solve a smaller version of the same problem. It's like Russian nesting dolls - open one to find a smaller one inside, until you reach the smallest.",
          "technical": "Recursion is a programming technique where a function solves a problem by reducing it to smaller instances of the same problem, calling itself with modified parameters until reaching a base case that can be solved directly."
        },
        "howItWorks": {
          "explanation": "Think of counting people in a line. Instead of counting everyone yourself, ask the person in front: 'How many people are ahead of you?' They ask the next person, and so on. The first person says '0'. Each person adds 1 and passes back. The answer bubbles up.",
          "steps": [
            {
              "step": 1,
              "title": "Identify Base Case",
              "description": "The simplest case that can be answered directly without recursion.",
              "why": "Prevents infinite recursion. This is where we stop."
            },
            {
              "step": 2,
              "title": "Identify Recursive Case",
              "description": "How to break the problem into smaller subproblems.",
              "why": "Each recursive call must make progress toward base case."
            },
            {
              "step": 3,
              "title": "Make Recursive Call",
              "description": "Call the function with smaller/simpler input.",
              "why": "Delegate the subproblem to another instance."
            },
            {
              "step": 4,
              "title": "Combine Results",
              "description": "Use subproblem results to build the final answer.",
              "why": "Assemble solution from smaller pieces."
            },
            {
              "step": 5,
              "title": "Return",
              "description": "Pass the combined result back up the call chain.",
              "why": "Each level receives its answer and can compute its own."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph TD\n    F3[\"factorial(3)\"] --> F2[\"factorial(2)\"]\n    F2 --> F1[\"factorial(1)\"]\n    F1 --> R1[\"return 1\"]\n    R1 --> R2[\"return 1*2=2\"]\n    R2 --> R3[\"return 2*3=6\"]\n    \n    style F1 fill:#98c1d9\n    style R3 fill:#ee6c4d",
            "caption": "factorial(3): calls factorial(2), which calls factorial(1). Base case returns 1, results bubble up."
          }
        },
        "whenToUse": {
          "summary": "Use recursion when a problem can be broken into smaller identical subproblems - trees, graphs, divide-and-conquer, backtracking.",
          "patterns": [
            {
              "pattern": "Tree Traversal",
              "signal": "Process nodes in hierarchical structure",
              "example": "Preorder, inorder, postorder traversals",
              "withoutIt": "Complex stack management",
              "withIt": "Natural left/right recursive calls"
            },
            {
              "pattern": "Divide and Conquer",
              "signal": "Split problem, solve parts, combine",
              "example": "Merge sort, quick sort, binary search",
              "withoutIt": "Manual subarray management",
              "withIt": "Clean recursive splitting"
            },
            {
              "pattern": "Backtracking",
              "signal": "Explore all possibilities, undo and try next",
              "example": "Permutations, N-Queens, Sudoku solver",
              "withoutIt": "Complex nested loops",
              "withIt": "Natural explore-undo pattern"
            },
            {
              "pattern": "Mathematical Recurrence",
              "signal": "f(n) defined in terms of f(n-1), f(n-2), etc.",
              "example": "Fibonacci, factorial, combinations",
              "withoutIt": "Loop with state tracking",
              "withIt": "Direct translation of math formula"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Recursion has overhead (stack space) and can be inefficient without memoization. Avoid when simple iteration works.",
          "antiPatterns": [
            {
              "situation": "Simple Iteration",
              "why": "Recursion adds stack overhead",
              "useInstead": "For loop",
              "example": "Sum of array elements"
            },
            {
              "situation": "Deep Recursion",
              "why": "Stack overflow risk",
              "useInstead": "Iterative with explicit stack",
              "example": "Processing very deep trees"
            },
            {
              "situation": "Overlapping Subproblems Without Memo",
              "why": "Exponential redundant work",
              "useInstead": "DP (memoization or tabulation)",
              "example": "Naive Fibonacci"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Inception Approach",
            "story": "Like the movie Inception, you go deeper into dreams within dreams. Each level is simpler than the one above. At the deepest level (base case), you get the answer. Then you wake up level by level, each level using the answer from below to compute its own result.",
            "connection": "Recursion works the same way. Each recursive call goes 'deeper' with a simpler problem. The base case is the deepest level. Then results 'bubble up' as calls return."
          },
          "keyInsight": "Every recursive function has two parts: (1) Base case - the exit condition, and (2) Recursive case - how to make the problem smaller. Missing either causes infinite recursion or wrong answers.",
          "commonConfusion": [
            {
              "confusion": "How does the call stack work?",
              "clarification": "Each call creates a new 'frame' with its own variables. When it returns, the frame is popped, and we're back in the caller's context."
            },
            {
              "confusion": "When is recursion better than iteration?",
              "clarification": "When the problem has recursive structure (trees, nested subproblems). For simple linear processing, loops are cleaner."
            },
            {
              "confusion": "Why stack overflow?",
              "clarification": "Each call uses stack memory. Too many nested calls = stack runs out. Use iterative or tail recursion optimization."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Linear Recursion",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "n calls, O(1) each (factorial, sum)"
              },
              {
                "operation": "Binary Recursion",
                "average": "O(2^n)",
                "worst": "O(2^n)",
                "note": "Two calls per level (naive Fibonacci)"
              },
              {
                "operation": "Divide & Conquer",
                "average": "O(n log n)",
                "worst": "O(n log n)",
                "note": "Split in half each level (merge sort)"
              }
            ],
            "explanation": "Depends on branching factor and depth. Draw the recursion tree to analyze."
          },
          "space": {
            "complexity": "O(depth) for call stack",
            "explanation": "Each active call uses stack space. Maximum concurrent calls = recursion depth."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Each recursive call creates a stack frame with local variables, parameters, and return address.",
            "keyPoints": [
              "Stack frame: local vars, parameters, return address",
              "Stack grows with each call, shrinks on return",
              "Maximum depth = stack limit (typically ~10,000 in JS, ~1000 in Python)",
              "Tail recursion: some languages optimize to avoid stack growth"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "No tail call optimization in practice. Watch for deep recursion.",
              "gotchas": [
                "Call stack limit ~10,000 (varies by engine)",
                "Use iterative for deep/unknown recursion depth",
                "Closures in recursion can cause memory leaks"
              ]
            },
            "python": {
              "implementation": "Default recursion limit ~1000. Can increase with sys.setrecursionlimit().",
              "gotchas": [
                "sys.setrecursionlimit(10000) for deeper recursion",
                "No tail call optimization",
                "Consider iterative for production code on unknown depths"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Merge sort is O(n log n)",
            "proof": {
              "step1": {
                "action": "Divide array in half",
                "cost": "O(1)"
              },
              "step2": {
                "action": "Recursively sort each half",
                "cost": "2 * T(n/2)"
              },
              "step3": {
                "action": "Merge sorted halves",
                "cost": "O(n)"
              },
              "step4": {
                "action": "Recurrence: T(n) = 2T(n/2) + O(n)",
                "cost": "Master theorem ‚Üí O(n log n)"
              }
            },
            "totalCost": "O(n log n)"
          }
        },
        "codeTemplates": [
          {
            "name": "Basic Recursion Patterns",
            "description": "Factorial, sum, and power - linear recursion",
            "javascript": {
              "code": "// Factorial: n! = n * (n-1)!\nfunction factorial(n) {\n  // Base case\n  if (n <= 1) return 1;\n  \n  // Recursive case\n  return n * factorial(n - 1);\n}\n\n// Sum of array\nfunction sum(arr, i = 0) {\n  // Base case: past the end\n  if (i >= arr.length) return 0;\n  \n  // Recursive case: current + rest\n  return arr[i] + sum(arr, i + 1);\n}\n\n// Power: x^n\nfunction power(x, n) {\n  if (n === 0) return 1;\n  if (n < 0) return 1 / power(x, -n);\n  \n  // Optimization: x^n = (x^(n/2))^2\n  if (n % 2 === 0) {\n    const half = power(x, n / 2);\n    return half * half;\n  }\n  return x * power(x, n - 1);\n}\n\n// The pattern:\n// 1. Check base case ‚Üí return simple value\n// 2. Make recursive call with smaller input\n// 3. Combine result with current value\n// 4. Return combined result",
              "notes": "Base case first! Then recursive case. Combine subresult with current."
            },
            "python": {
              "code": "def factorial(n):\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)\n\ndef array_sum(arr, i=0):\n    if i >= len(arr):\n        return 0\n    return arr[i] + array_sum(arr, i + 1)\n\ndef power(x, n):\n    if n == 0:\n        return 1\n    if n < 0:\n        return 1 / power(x, -n)\n    \n    if n % 2 == 0:\n        half = power(x, n // 2)\n        return half * half\n    return x * power(x, n - 1)",
              "notes": "power uses 'fast exponentiation' - O(log n) instead of O(n)."
            }
          },
          {
            "name": "Tree Recursion",
            "description": "Process tree with recursive calls to children",
            "javascript": {
              "code": "// Tree node\nclass TreeNode {\n  constructor(val, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n// Max depth\nfunction maxDepth(root) {\n  if (!root) return 0;  // Base case: empty tree\n  \n  const leftDepth = maxDepth(root.left);\n  const rightDepth = maxDepth(root.right);\n  \n  return 1 + Math.max(leftDepth, rightDepth);\n}\n\n// Check if tree is balanced\nfunction isBalanced(root) {\n  function height(node) {\n    if (!node) return 0;\n    \n    const left = height(node.left);\n    if (left === -1) return -1;  // Left subtree unbalanced\n    \n    const right = height(node.right);\n    if (right === -1) return -1;  // Right subtree unbalanced\n    \n    if (Math.abs(left - right) > 1) return -1;  // This node unbalanced\n    \n    return 1 + Math.max(left, right);\n  }\n  \n  return height(root) !== -1;\n}\n\n// Invert tree\nfunction invertTree(root) {\n  if (!root) return null;\n  \n  // Recursively invert subtrees\n  const left = invertTree(root.left);\n  const right = invertTree(root.right);\n  \n  // Swap\n  root.left = right;\n  root.right = left;\n  \n  return root;\n}",
              "notes": "Tree problems: base case is null, recursive case processes children, combines results."
            },
            "python": {
              "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef max_depth(root):\n    if not root:\n        return 0\n    return 1 + max(max_depth(root.left), max_depth(root.right))\n\ndef is_balanced(root):\n    def height(node):\n        if not node:\n            return 0\n        \n        left = height(node.left)\n        if left == -1:\n            return -1\n        \n        right = height(node.right)\n        if right == -1:\n            return -1\n        \n        if abs(left - right) > 1:\n            return -1\n        \n        return 1 + max(left, right)\n    \n    return height(root) != -1\n\ndef invert_tree(root):\n    if not root:\n        return None\n    \n    root.left, root.right = invert_tree(root.right), invert_tree(root.left)\n    return root",
              "notes": "Python's tuple unpacking makes swap elegant."
            }
          },
          {
            "name": "Generating Combinations/Permutations",
            "description": "Recursive enumeration",
            "javascript": {
              "code": "// All subsets (power set)\nfunction subsets(nums) {\n  const result = [];\n  \n  function backtrack(start, current) {\n    result.push([...current]);  // Add current subset\n    \n    for (let i = start; i < nums.length; i++) {\n      current.push(nums[i]);      // Choose\n      backtrack(i + 1, current);  // Explore\n      current.pop();              // Unchoose (backtrack)\n    }\n  }\n  \n  backtrack(0, []);\n  return result;\n}\n\n// All permutations\nfunction permutations(nums) {\n  const result = [];\n  const used = new Array(nums.length).fill(false);\n  \n  function backtrack(current) {\n    if (current.length === nums.length) {\n      result.push([...current]);\n      return;\n    }\n    \n    for (let i = 0; i < nums.length; i++) {\n      if (used[i]) continue;\n      \n      current.push(nums[i]);\n      used[i] = true;\n      \n      backtrack(current);\n      \n      current.pop();\n      used[i] = false;\n    }\n  }\n  \n  backtrack([]);\n  return result;\n}",
              "notes": "Backtracking pattern: choose ‚Üí explore ‚Üí unchoose. Key is undoing changes."
            },
            "python": {
              "code": "def subsets(nums):\n    result = []\n    \n    def backtrack(start, current):\n        result.append(current[:])\n        \n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            backtrack(i + 1, current)\n            current.pop()\n    \n    backtrack(0, [])\n    return result\n\ndef permutations(nums):\n    result = []\n    used = [False] * len(nums)\n    \n    def backtrack(current):\n        if len(current) == len(nums):\n            result.append(current[:])\n            return\n        \n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            \n            current.append(nums[i])\n            used[i] = True\n            \n            backtrack(current)\n            \n            current.pop()\n            used[i] = False\n    \n    backtrack([])\n    return result",
              "notes": "Use current[:] to copy list when adding to result."
            }
          }
        ],
        "visualTrace": {
          "title": "factorial(4) Call Stack",
          "input": {
            "function": "factorial(4)"
          },
          "steps": [
            {
              "call": "factorial(4)",
              "stack": "[f(4)]",
              "action": "4 > 1, call factorial(3)"
            },
            {
              "call": "factorial(3)",
              "stack": "[f(4), f(3)]",
              "action": "3 > 1, call factorial(2)"
            },
            {
              "call": "factorial(2)",
              "stack": "[f(4), f(3), f(2)]",
              "action": "2 > 1, call factorial(1)"
            },
            {
              "call": "factorial(1)",
              "stack": "[f(4), f(3), f(2), f(1)]",
              "action": "BASE CASE: return 1"
            },
            {
              "return": "1",
              "stack": "[f(4), f(3), f(2)]",
              "compute": "2 * 1 = 2"
            },
            {
              "return": "2",
              "stack": "[f(4), f(3)]",
              "compute": "3 * 2 = 6"
            },
            {
              "return": "6",
              "stack": "[f(4)]",
              "compute": "4 * 6 = 24"
            },
            {
              "return": "24",
              "stack": "[]",
              "result": "Final answer: 24"
            }
          ],
          "output": "factorial(4) = 24. Stack depth: 4. Returns bubble up with computed values."
        },
        "commonMistakes": [
          {
            "mistake": "Missing base case",
            "wrong": "function f(n) { return f(n-1); } // Infinite!",
            "right": "if (n <= 0) return 1; return f(n-1);",
            "explanation": "Without base case, recursion never stops ‚Üí stack overflow."
          },
          {
            "mistake": "Not making progress toward base case",
            "wrong": "function f(n) { return f(n); } // Same n forever",
            "right": "return f(n - 1); // n decreases",
            "explanation": "Each call must be 'smaller' to eventually reach base case."
          },
          {
            "mistake": "Modifying shared state without backtracking",
            "wrong": "arr.push(x); recurse(); // x stays in arr!",
            "right": "arr.push(x); recurse(); arr.pop();",
            "explanation": "For exploration, undo changes after recursive call returns."
          }
        ],
        "keyTakeaways": [
          "Recursion = function calls itself with smaller input",
          "Two essential parts: BASE CASE (stop) and RECURSIVE CASE (smaller problem)",
          "Call stack: each call creates a frame, returns pop the frame",
          "Space complexity: O(max depth) for stack",
          "Use for: trees, divide-and-conquer, backtracking, mathematical recurrences",
          "Beware: stack overflow for deep recursion, exponential time without memoization"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "functions",
              "label": "Functions",
              "why": "Recursion is function calling itself"
            },
            {
              "id": "stack",
              "label": "Stack Concept",
              "why": "Call stack is a stack"
            }
          ],
          "nextTopics": [
            {
              "id": "dp",
              "label": "Dynamic Programming",
              "why": "Recursion + memoization"
            },
            {
              "id": "backtracking",
              "label": "Backtracking",
              "why": "Recursion with undo"
            },
            {
              "id": "tree",
              "label": "Tree Algorithms",
              "why": "Natural recursive structure"
            },
            {
              "id": "divide_conquer",
              "label": "Divide and Conquer",
              "why": "Split, recurse, combine"
            }
          ]
        },
        "patternChain": {
          "description": "Recursion is foundation for many advanced techniques",
          "buildsOn": [
            {
              "id": "functions",
              "relationship": "Self-calling function",
              "whatToKnow": "How functions work"
            },
            {
              "id": "stack",
              "relationship": "Uses call stack",
              "whatToKnow": "LIFO execution"
            }
          ],
          "enables": [
            {
              "id": "tree_traversal",
              "relationship": "Natural tree processing",
              "patternName": "Tree Recursion",
              "interviewFrequency": "Very High"
            },
            {
              "id": "backtracking",
              "relationship": "Explore + undo",
              "patternName": "Backtracking",
              "interviewFrequency": "Very High"
            },
            {
              "id": "dp",
              "relationship": "Recursion + memoization",
              "patternName": "Dynamic Programming",
              "interviewFrequency": "Very High"
            },
            {
              "id": "divide_conquer",
              "relationship": "Split, solve, combine",
              "patternName": "Divide & Conquer",
              "interviewFrequency": "High"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    FUNC[Functions] --> REC[Recursion]\n    STACK[Stack] --> REC\n    REC --> TREE[Tree Algorithms]\n    REC --> BT[Backtracking]\n    REC --> DP[Dynamic Programming]\n    REC --> DC[Divide & Conquer]\n    \n    style REC fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "sorting",
      "label": "Sorting Algorithms",
      "type": "algo",
      "description": "Ordering data.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Sorting_algorithm"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/sorting"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/sorting/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/sorting-algorithms/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "2-4 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft"
      ],
      "interviewFrequency": "high",
      "category": "Algorithm",
      "categoryIcon": "‚ö°",
      "interviewQuestions": [
        {
          "name": "Merge Intervals",
          "leetcode": "https://leetcode.com/problems/merge-intervals/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Sort + merge pattern - fundamental for interval problems",
          "approach": "Sort by start. Iterate and merge overlapping by extending end",
          "followUps": [
            {
              "question": "Insert interval?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Meeting rooms?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Sort Colors (Dutch National Flag)",
          "leetcode": "https://leetcode.com/problems/sort-colors/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Microsoft",
            "Meta",
            "Flipkart"
          ],
          "frequency": "High",
          "whyAsked": "3-way partitioning in-place, one pass",
          "approach": "Three pointers: low, mid, high. Swap 0s to low, 2s to high. O(n) time, O(1) space",
          "followUps": [
            {
              "question": "4 colors?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "With extra constraints?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Kth Largest Element",
          "leetcode": "https://leetcode.com/problems/kth-largest-element-in-an-array/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Quickselect vs heap trade-offs. Partial sorting",
          "approach": "Quickselect: O(n) average. Or min-heap of size k: O(n log k)",
          "followUps": [
            {
              "question": "Guaranteed O(n)?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Stream of numbers?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Meeting Rooms II",
          "leetcode": "https://leetcode.com/problems/meeting-rooms-ii/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Microsoft",
            "Bloomberg"
          ],
          "frequency": "Very High",
          "whyAsked": "Min-heap for scheduling - minimum rooms needed",
          "approach": "Sort by start. Min-heap of end times. For each meeting, pop if can reuse room",
          "followUps": [
            {
              "question": "With room sizes?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Specific room preferences?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "teamblind"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Blind (Teamblind)",
              "url": "https://www.teamblind.com/",
              "note": "Crowdsourced FAANG interview experiences"
            }
          ]
        },
        {
          "name": "Largest Number",
          "leetcode": "https://leetcode.com/problems/largest-number/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google"
          ],
          "frequency": "Medium",
          "whyAsked": "Custom comparator - form largest number from digits",
          "approach": "Sort with custom compare: a+b vs b+a. Concatenate result. Handle leading zeros",
          "followUps": [
            {
              "question": "Smallest number?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "With k digits?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with videos"
        },
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based categorization"
        }
      ],
      "content": {
        "definition": {
          "simple": "Sorting is arranging elements in a specific order (ascending/descending). It's like organizing a deck of cards by number - there are many ways to do it, some faster than others.",
          "technical": "Sorting algorithms reorder elements of a list according to a comparison function that defines the ordering relation. Key characteristics include time complexity, space complexity, stability (preserving relative order of equal elements), and whether comparisons are required."
        },
        "howItWorks": {
          "explanation": "Different algorithms use different strategies. Some compare and swap neighbors (Bubble Sort). Some repeatedly find the minimum (Selection Sort). Some divide and conquer (Merge Sort, Quick Sort). Some don't compare at all (Counting Sort).",
          "steps": [
            {
              "step": 1,
              "title": "Choose Algorithm",
              "description": "Based on data size, distribution, and constraints.",
              "why": "No one-size-fits-all solution."
            },
            {
              "step": 2,
              "title": "Compare Elements",
              "description": "Determine relative ordering of pairs.",
              "why": "Basis for most sorting (comparison-based)."
            },
            {
              "step": 3,
              "title": "Rearrange",
              "description": "Move elements toward correct positions.",
              "why": "Reduce 'disorder' with each step."
            },
            {
              "step": 4,
              "title": "Repeat",
              "description": "Continue until fully sorted.",
              "why": "Each pass brings closer to sorted state."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph TB\n    subgraph \"O(n¬≤)\"\n        A[Bubble Sort]\n        B[Selection Sort]\n        C[Insertion Sort]\n    end\n    subgraph \"O(n log n)\"\n        D[Merge Sort]\n        E[Quick Sort]\n        F[Heap Sort]\n    end\n    subgraph \"O(n) - Non-comparison\"\n        G[Counting Sort]\n        H[Radix Sort]\n        I[Bucket Sort]\n    end\n    \n    style D fill:#98c1d9\n    style E fill:#98c1d9",
            "caption": "Sorting algorithms by time complexity"
          }
        },
        "whenToUse": {
          "summary": "Choose based on: data size, nearly sorted?, memory constraints, stability needed?",
          "patterns": [
            {
              "pattern": "Small Arrays (n < 50)",
              "signal": "Overhead matters more than Big O",
              "example": "Sorting 10-20 elements",
              "withoutIt": "Complex algorithm overhead dominates",
              "withIt": "Insertion Sort - low overhead, cache-friendly"
            },
            {
              "pattern": "Nearly Sorted Data",
              "signal": "Most elements close to final position",
              "example": "Real-time sensor data with occasional out-of-order",
              "withoutIt": "Full O(n log n) work",
              "withIt": "Insertion Sort O(n) for nearly sorted"
            },
            {
              "pattern": "Large Arrays, Stability Needed",
              "signal": "Preserve relative order of equal elements",
              "example": "Sort by last name, then by first name",
              "withoutIt": "Secondary sort destroys primary",
              "withIt": "Merge Sort - stable, guaranteed O(n log n)"
            },
            {
              "pattern": "In-Place, Large Arrays",
              "signal": "Can't afford O(n) extra memory",
              "example": "Embedded systems, memory-constrained",
              "withoutIt": "Merge Sort needs O(n) space",
              "withIt": "Quick Sort or Heap Sort - O(log n) or O(1) extra"
            },
            {
              "pattern": "Integer Keys, Known Range",
              "signal": "Keys are integers in [0, k] where k ~ O(n)",
              "example": "Sorting ages, grades, small IDs",
              "withoutIt": "O(n log n) comparison sort",
              "withIt": "Counting Sort O(n + k)"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Some algorithms have severe worst cases or hidden costs.",
          "antiPatterns": [
            {
              "situation": "Quick Sort on Sorted Data (naive pivot)",
              "why": "O(n¬≤) worst case",
              "useInstead": "Random pivot or Merge Sort",
              "example": "Already sorted array"
            },
            {
              "situation": "Counting Sort for Large Range",
              "why": "O(k) space where k = max - min",
              "useInstead": "Comparison sort",
              "example": "Sorting floats or large integers"
            },
            {
              "situation": "Bubble/Selection for Large Data",
              "why": "O(n¬≤) is prohibitive",
              "useInstead": "Quick Sort, Merge Sort",
              "example": "n > 1000 elements"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Card Sorting Strategies",
            "story": "Imagine sorting a hand of cards:\n- **Insertion**: Pick each card and insert into correct position in sorted hand.\n- **Selection**: Find smallest, put in front. Find next smallest, put second.\n- **Merge**: Split deck, sort each half, merge back together.\n- **Quick**: Pick a card (pivot), put smaller cards left, larger right, repeat in each half.",
            "connection": "Each strategy has trade-offs: Insertion is great for few cards, Merge works well for any amount but needs a table to lay cards out."
          },
          "keyInsight": "Comparison-based sorting has a theoretical lower bound of O(n log n). You cannot do better using only comparisons. Non-comparison sorts (Counting, Radix) can be O(n) but require constraints on input.",
          "commonConfusion": [
            {
              "confusion": "Why is Quick Sort 'quick' if worst case is O(n¬≤)?",
              "clarification": "Average case O(n log n) with small constants. Worst case rare with random pivot. In practice, faster than Merge Sort due to cache locality."
            },
            {
              "confusion": "What does 'stable' mean?",
              "clarification": "Equal elements stay in original relative order. Sort [(3,'a'), (1,'b'), (3,'c')] by number: stable gives [(1,'b'), (3,'a'), (3,'c')], unstable might swap the 3s."
            },
            {
              "confusion": "When is O(n) sort possible?",
              "clarification": "Non-comparison sorts (Counting, Radix) don't compare elements. They use element values directly as indices or digits. Requires integer keys with bounded range."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Bubble Sort",
                "average": "O(n¬≤)",
                "worst": "O(n¬≤)",
                "note": "Stable, simple, slow"
              },
              {
                "operation": "Selection Sort",
                "average": "O(n¬≤)",
                "worst": "O(n¬≤)",
                "note": "Unstable, always n¬≤ compares"
              },
              {
                "operation": "Insertion Sort",
                "average": "O(n¬≤)",
                "worst": "O(n¬≤)",
                "note": "Stable, O(n) for nearly sorted"
              },
              {
                "operation": "Merge Sort",
                "average": "O(n log n)",
                "worst": "O(n log n)",
                "note": "Stable, O(n) space"
              },
              {
                "operation": "Quick Sort",
                "average": "O(n log n)",
                "worst": "O(n¬≤)",
                "note": "In-place, cache-friendly"
              },
              {
                "operation": "Heap Sort",
                "average": "O(n log n)",
                "worst": "O(n log n)",
                "note": "In-place, not stable"
              },
              {
                "operation": "Counting Sort",
                "average": "O(n + k)",
                "worst": "O(n + k)",
                "note": "k = range of values"
              },
              {
                "operation": "Radix Sort",
                "average": "O(d(n + k))",
                "worst": "O(d(n + k))",
                "note": "d = digits, k = base"
              }
            ],
            "explanation": "Comparison sorts: O(n log n) lower bound. Non-comparison: O(n) with constraints."
          },
          "space": {
            "complexity": "Varies: O(1) for Heap/Quick, O(n) for Merge, O(n+k) for Counting",
            "explanation": "In-place sorts use O(log n) stack; Merge Sort needs O(n) auxiliary."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Sorting algorithms differ dramatically in memory access patterns.",
            "keyPoints": [
              "Quick Sort: excellent cache locality (sequential access)",
              "Merge Sort: copies to auxiliary array (less cache-friendly)",
              "Insertion Sort: shifts elements (good for small/local data)",
              "Heap Sort: jumps around heap (poor cache behavior)"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Array.prototype.sort() uses Timsort (hybrid of merge + insertion).",
              "gotchas": [
                "Default is lexicographic: [10, 2, 1].sort() ‚Üí [1, 10, 2]",
                "Always provide comparator: .sort((a, b) => a - b)",
                "Mutates original array",
                "Not guaranteed stable before ES2019"
              ]
            },
            "python": {
              "implementation": "Timsort: hybrid merge + insertion. Stable, O(n log n).",
              "gotchas": [
                "list.sort() mutates, sorted() returns new list",
                "Use key= for custom comparison: sorted(arr, key=lambda x: x[1])",
                "reverse=True for descending",
                "Timsort is optimized for real-world data with runs"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Comparison-based sorting requires Œ©(n log n) comparisons",
            "proof": {
              "step1": {
                "action": "n! possible orderings (permutations)",
                "cost": "Input could be any of n! arrangements"
              },
              "step2": {
                "action": "Each comparison gives 1 bit of information",
                "cost": "Binary decision tree"
              },
              "step3": {
                "action": "Tree must have n! leaves to distinguish all orderings",
                "cost": "Minimum depth = log‚ÇÇ(n!)"
              },
              "step4": {
                "action": "log‚ÇÇ(n!) = Œò(n log n) by Stirling's approximation",
                "cost": "Mathematical proof"
              }
            },
            "totalCost": "Œ©(n log n) is information-theoretic lower bound"
          }
        },
        "codeTemplates": [
          {
            "name": "Merge Sort",
            "description": "Stable, guaranteed O(n log n), divide-and-conquer",
            "javascript": {
              "code": "function mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n  \n  const mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n  \n  return merge(left, right);\n}\n\nfunction merge(left, right) {\n  const result = [];\n  let i = 0, j = 0;\n  \n  while (i < left.length && j < right.length) {\n    // <= for stability (take from left first if equal)\n    if (left[i] <= right[j]) {\n      result.push(left[i++]);\n    } else {\n      result.push(right[j++]);\n    }\n  }\n  \n  // Remaining elements\n  while (i < left.length) result.push(left[i++]);\n  while (j < right.length) result.push(right[j++]);\n  \n  return result;\n}\n\n// Merge Sort Analysis:\n// Time: O(n log n) - always, no worst case\n// Space: O(n) - need auxiliary array for merging\n// Stable: Yes - equal elements maintain order\n// Use when: stability needed, consistent performance",
              "notes": "Use <= in merge for stability. O(n) space for auxiliary array."
            },
            "python": {
              "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:  # <= for stability\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result",
              "notes": "Python slicing creates copies (adds to space)."
            }
          },
          {
            "name": "Quick Sort",
            "description": "In-place, cache-friendly, O(n log n) average",
            "javascript": {
              "code": "function quickSort(arr, lo = 0, hi = arr.length - 1) {\n  if (lo >= hi) return arr;\n  \n  const pivotIndex = partition(arr, lo, hi);\n  quickSort(arr, lo, pivotIndex - 1);\n  quickSort(arr, pivotIndex + 1, hi);\n  \n  return arr;\n}\n\nfunction partition(arr, lo, hi) {\n  // Random pivot to avoid worst case\n  const randomIdx = lo + Math.floor(Math.random() * (hi - lo + 1));\n  [arr[randomIdx], arr[hi]] = [arr[hi], arr[randomIdx]];\n  \n  const pivot = arr[hi];\n  let i = lo - 1;  // Boundary of \"smaller\" partition\n  \n  for (let j = lo; j < hi; j++) {\n    if (arr[j] < pivot) {\n      i++;\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n  \n  // Place pivot in correct position\n  [arr[i + 1], arr[hi]] = [arr[hi], arr[i + 1]];\n  return i + 1;\n}\n\n// Quick Sort Analysis:\n// Time: O(n log n) average, O(n¬≤) worst (rare with random pivot)\n// Space: O(log n) for recursion stack\n// Stable: No - swapping can change relative order\n// Use when: in-place needed, large arrays, average case matters",
              "notes": "Random pivot prevents O(n¬≤) on sorted input. In-place but unstable."
            },
            "python": {
              "code": "import random\n\ndef quick_sort(arr, lo=0, hi=None):\n    if hi is None:\n        hi = len(arr) - 1\n    \n    if lo >= hi:\n        return arr\n    \n    pivot_idx = partition(arr, lo, hi)\n    quick_sort(arr, lo, pivot_idx - 1)\n    quick_sort(arr, pivot_idx + 1, hi)\n    \n    return arr\n\ndef partition(arr, lo, hi):\n    # Random pivot\n    rand_idx = random.randint(lo, hi)\n    arr[rand_idx], arr[hi] = arr[hi], arr[rand_idx]\n    \n    pivot = arr[hi]\n    i = lo - 1\n    \n    for j in range(lo, hi):\n        if arr[j] < pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    arr[i + 1], arr[hi] = arr[hi], arr[i + 1]\n    return i + 1",
              "notes": "Lomuto partition shown. Hoare partition is slightly faster."
            }
          },
          {
            "name": "Counting Sort",
            "description": "O(n + k) non-comparison sort for integers",
            "javascript": {
              "code": "function countingSort(arr) {\n  if (!arr.length) return arr;\n  \n  const max = Math.max(...arr);\n  const min = Math.min(...arr);\n  const range = max - min + 1;\n  \n  // Count occurrences\n  const count = new Array(range).fill(0);\n  for (const num of arr) {\n    count[num - min]++;\n  }\n  \n  // Build sorted array\n  const result = [];\n  for (let i = 0; i < range; i++) {\n    while (count[i] > 0) {\n      result.push(i + min);\n      count[i]--;\n    }\n  }\n  \n  return result;\n}\n\n// Counting Sort Analysis:\n// Time: O(n + k) where k = range of values\n// Space: O(k) for count array\n// Stable: Can be made stable with cumulative sum approach\n// Use when: integers with small range (k ~ O(n))\n\n// Warning: If k >> n (e.g., sorting 10 numbers in range [0, 10^9]),\n// counting sort is worse than comparison sorts!",
              "notes": "Only for integers. Space O(k) where k = max - min."
            },
            "python": {
              "code": "def counting_sort(arr):\n    if not arr:\n        return arr\n    \n    min_val = min(arr)\n    max_val = max(arr)\n    range_size = max_val - min_val + 1\n    \n    count = [0] * range_size\n    for num in arr:\n        count[num - min_val] += 1\n    \n    result = []\n    for i in range(range_size):\n        result.extend([i + min_val] * count[i])\n    \n    return result\n\n# Stable version (preserves order of equal elements)\ndef counting_sort_stable(arr, key=lambda x: x):\n    if not arr:\n        return arr\n    \n    keys = [key(x) for x in arr]\n    min_key = min(keys)\n    max_key = max(keys)\n    range_size = max_key - min_key + 1\n    \n    count = [0] * range_size\n    for k in keys:\n        count[k - min_key] += 1\n    \n    # Cumulative sum\n    for i in range(1, range_size):\n        count[i] += count[i - 1]\n    \n    # Build output in reverse for stability\n    result = [None] * len(arr)\n    for i in range(len(arr) - 1, -1, -1):\n        k = key(arr[i]) - min_key\n        count[k] -= 1\n        result[count[k]] = arr[i]\n    \n    return result",
              "notes": "Stable version uses cumulative counts and reverse iteration."
            }
          }
        ],
        "visualTrace": {
          "title": "Merge Sort on [38, 27, 43, 3, 9, 82, 10]",
          "input": {
            "array": "[38, 27, 43, 3, 9, 82, 10]"
          },
          "steps": [
            {
              "phase": "Divide",
              "arrays": "[[38,27,43,3], [9,82,10]]",
              "action": "Split in half"
            },
            {
              "phase": "Divide",
              "arrays": "[[38,27], [43,3], [9,82], [10]]",
              "action": "Split again"
            },
            {
              "phase": "Divide",
              "arrays": "[[38], [27], [43], [3], [9], [82], [10]]",
              "action": "Single elements"
            },
            {
              "phase": "Merge",
              "arrays": "[[27,38], [3,43], [9,82], [10]]",
              "action": "Merge pairs"
            },
            {
              "phase": "Merge",
              "arrays": "[[3,27,38,43], [9,10,82]]",
              "action": "Merge groups"
            },
            {
              "phase": "Merge",
              "arrays": "[[3,9,10,27,38,43,82]]",
              "action": "Final merge"
            }
          ],
          "output": "[3, 9, 10, 27, 38, 43, 82] - Total comparisons: ~12, O(n log n)"
        },
        "commonMistakes": [
          {
            "mistake": "Using default JS sort for numbers",
            "wrong": "[10, 2, 1].sort() ‚Üí [1, 10, 2]",
            "right": "[10, 2, 1].sort((a,b) => a-b) ‚Üí [1, 2, 10]",
            "explanation": "Default sort is lexicographic (string comparison)."
          },
          {
            "mistake": "Quick Sort with first/last pivot on sorted data",
            "wrong": "Always pick arr[0] as pivot",
            "right": "Random pivot or median-of-three",
            "explanation": "Sorted input causes O(n¬≤) with naive pivot."
          },
          {
            "mistake": "Expecting stability from unstable sorts",
            "wrong": "Quick Sort then sort by secondary key",
            "right": "Use Merge Sort for stable multi-key sorting",
            "explanation": "Unstable sorts may scramble equal-key elements."
          }
        ],
        "keyTakeaways": [
          "Comparison sorts: O(n log n) is optimal (information-theoretic bound)",
          "Quick Sort: fastest in practice (cache locality), but O(n¬≤) worst case",
          "Merge Sort: stable, guaranteed O(n log n), but O(n) space",
          "Insertion Sort: best for small or nearly-sorted data",
          "Counting/Radix Sort: O(n) for integers with bounded range",
          "Built-in sorts (Timsort): hybrid algorithms optimized for real data"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Arrays",
              "why": "Sorting operates on arrays"
            },
            {
              "id": "recursion",
              "label": "Recursion",
              "why": "Merge Sort, Quick Sort are recursive"
            }
          ],
          "nextTopics": [
            {
              "id": "binary_search",
              "label": "Binary Search",
              "why": "Requires sorted data"
            },
            {
              "id": "greedy",
              "label": "Greedy Algorithms",
              "why": "Often sort first"
            },
            {
              "id": "heap",
              "label": "Heap Sort",
              "why": "Heap-based sorting"
            }
          ]
        },
        "patternChain": {
          "description": "Sorting is foundational for many algorithms",
          "buildsOn": [
            {
              "id": "array",
              "relationship": "Operates on arrays",
              "whatToKnow": "Array indexing"
            },
            {
              "id": "recursion",
              "relationship": "Divide and conquer",
              "whatToKnow": "Recursive decomposition"
            }
          ],
          "enables": [
            {
              "id": "binary_search",
              "relationship": "Sorted data ‚Üí O(log n) search",
              "patternName": "Binary Search",
              "interviewFrequency": "Very High"
            },
            {
              "id": "two_pointers",
              "relationship": "Sorted data ‚Üí meet-in-middle",
              "patternName": "Two Sum Variants",
              "interviewFrequency": "Very High"
            },
            {
              "id": "greedy",
              "relationship": "Sort first, then greedy select",
              "patternName": "Interval Scheduling",
              "interviewFrequency": "High"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    ARR[Arrays] --> SORT[Sorting]\n    REC[Recursion] --> SORT\n    SORT --> BS[Binary Search]\n    SORT --> TP[Two Pointers]\n    SORT --> GREEDY[Greedy]\n    SORT --> HEAP[Heap Sort]\n    \n    style SORT fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "binary_search",
      "label": "Binary Search",
      "type": "algo",
      "description": "O(log n) search on sorted data.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Binary_search_algorithm"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/binarysearch"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/binary-search/"
          },
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/num_methods/binary_search.html"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2-3 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft",
        "Apple"
      ],
      "interviewFrequency": "high",
      "category": "Algorithm",
      "categoryIcon": "‚ö°",
      "interviewQuestions": [
        {
          "name": "Binary Search",
          "leetcode": "https://leetcode.com/problems/binary-search/",
          "difficulty": "Easy",
          "companies": [
            "Amazon",
            "Google",
            "Microsoft"
          ],
          "frequency": "High",
          "whyAsked": "Foundation - must know invariants and boundary conditions",
          "approach": "lo, hi pointers. mid = lo + (hi - lo) / 2. Adjust based on comparison. O(log n)",
          "followUps": [
            {
              "question": "First/last occurrence?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Rotated array?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Matrix search?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "Search in Rotated Sorted Array",
          "leetcode": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Microsoft",
            "LinkedIn",
            "Flipkart"
          ],
          "frequency": "Very High",
          "whyAsked": "Modified binary search - identify sorted half first",
          "approach": "Find which half is sorted. Check if target in sorted half. Adjust search. O(log n)",
          "followUps": [
            {
              "question": "With duplicates?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Find minimum in rotated?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Find rotation count?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "Find Minimum in Rotated Sorted Array",
          "leetcode": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Microsoft"
          ],
          "frequency": "High",
          "whyAsked": "Binary search for pivot point",
          "approach": "Compare mid with right. If mid > right, min is in right half. Else left half. O(log n)",
          "followUps": [
            {
              "question": "With duplicates?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Find peak element?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Koko Eating Bananas",
          "leetcode": "https://leetcode.com/problems/koko-eating-bananas/",
          "difficulty": "Medium",
          "companies": [
            "Google",
            "Amazon",
            "Meta"
          ],
          "frequency": "Medium",
          "whyAsked": "Binary search on answer - minimize speed to finish in h hours",
          "approach": "Binary search on speed [1, max(piles)]. For each speed, check if can finish in h hours. O(n log m)",
          "followUps": [
            {
              "question": "Ship packages in d days?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Split array largest sum?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "seanprashad"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Sean Prashad's Patterns",
              "url": "https://seanprashad.com/leetcode-patterns/",
              "note": "Pattern-based problem categorization"
            }
          ]
        },
        {
          "name": "Median of Two Sorted Arrays",
          "leetcode": "https://leetcode.com/problems/median-of-two-sorted-arrays/",
          "difficulty": "Hard",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Goldman Sachs"
          ],
          "frequency": "High",
          "whyAsked": "Advanced binary search - find partition in smaller array",
          "approach": "Binary search on smaller array for partition. Ensure left parts <= right parts. O(log min(m,n))",
          "followUps": [
            {
              "question": "Kth element of two sorted arrays?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "teamblind"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Blind (Teamblind)",
              "url": "https://www.teamblind.com/",
              "note": "Crowdsourced interview experiences from FAANG employees"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based problem categorization"
        },
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with video explanations"
        }
      ],
      "content": {
        "definition": {
          "simple": "Binary search is like finding a word in a dictionary - you open to the middle, check if you need to go earlier or later, and repeat. Each step eliminates half the remaining options.",
          "technical": "Binary search is a divide-and-conquer algorithm that finds a target in a sorted array by repeatedly comparing the middle element and narrowing the search space by half. Time complexity is O(log n)."
        },
        "howItWorks": {
          "explanation": "Imagine guessing a number between 1-100. Instead of guessing 1, 2, 3..., you guess 50. 'Too high!' Now you know it's 1-49. Guess 25. 'Too low!' It's 26-49. Each guess eliminates half. At most 7 guesses for 100 numbers (log‚ÇÇ100 ‚âà 7).",
          "steps": [
            {
              "step": 1,
              "title": "Initialize Pointers",
              "description": "Set left = 0, right = length - 1",
              "why": "Define search space boundaries."
            },
            {
              "step": 2,
              "title": "Find Middle",
              "description": "mid = left + Math.floor((right - left) / 2)",
              "why": "Avoid overflow. (left + right) / 2 can overflow."
            },
            {
              "step": 3,
              "title": "Compare",
              "description": "If arr[mid] === target, found! If arr[mid] < target, search right. Else search left.",
              "why": "Eliminate half based on sorted order."
            },
            {
              "step": 4,
              "title": "Narrow Search",
              "description": "Update left = mid + 1 or right = mid - 1",
              "why": "Exclude mid since we checked it."
            },
            {
              "step": 5,
              "title": "Repeat or Terminate",
              "description": "Continue while left <= right. If pointers cross, element not found.",
              "why": "Empty search space means not present."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    A[\"Array: [1,3,5,7,9,11,13]\\nFind: 9\"] --> B[\"left=0, right=6\\nmid=3, arr[3]=7\"]\n    B --> C{\"7 < 9?\"}\n    C -->|Yes| D[\"left=4, right=6\\nmid=5, arr[5]=11\"]\n    D --> E{\"11 > 9?\"}\n    E -->|Yes| F[\"left=4, right=4\\nmid=4, arr[4]=9\"]\n    F --> G[\"Found at index 4!\"]\n    \n    style G fill:#98c1d9",
            "caption": "3 comparisons to find 9 in 7 elements. log‚ÇÇ(7) ‚âà 3."
          }
        },
        "whenToUse": {
          "summary": "Use binary search when data is SORTED or has a monotonic property (all false then all true).",
          "patterns": [
            {
              "pattern": "Find Exact Match",
              "signal": "Find target in sorted array",
              "example": "Search in sorted array",
              "withoutIt": "Linear scan O(n)",
              "withIt": "Binary search O(log n)"
            },
            {
              "pattern": "Find Boundary (First/Last)",
              "signal": "Find first occurrence, leftmost valid, insertion point",
              "example": "First bad version, search insert position",
              "withoutIt": "Find then scan left/right O(n)",
              "withIt": "Modified binary search O(log n)"
            },
            {
              "pattern": "Search on Answer",
              "signal": "Minimize/maximize value where condition flips from false to true",
              "example": "Koko eating bananas, capacity to ship",
              "withoutIt": "Try all values O(n * check)",
              "withIt": "Binary search on answer O(log n * check)"
            },
            {
              "pattern": "Rotated Array",
              "signal": "Sorted array rotated at unknown pivot",
              "example": "Search in rotated sorted array",
              "withoutIt": "Find pivot O(n), then search",
              "withIt": "Modified binary search O(log n)"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Binary search requires sorted/monotonic data. Avoid when unsorted or when linear scan is simpler for small n.",
          "antiPatterns": [
            {
              "situation": "Unsorted Data",
              "why": "Binary search relies on sorted order",
              "useInstead": "Sort first O(n log n) + binary, or linear O(n)",
              "example": "Find max in unsorted array"
            },
            {
              "situation": "Small Arrays (n < 10)",
              "why": "Overhead not worth it",
              "useInstead": "Linear scan",
              "example": "Config lookup"
            },
            {
              "situation": "Linked Lists",
              "why": "No O(1) random access",
              "useInstead": "Linear scan O(n)",
              "example": "Can't jump to middle"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Phone Book",
            "story": "Looking up 'Smith' in a phone book. You don't start at 'A'. You open to the middle - 'M'. Smith is after M, so you go to the right half. Open to 'S' area. Fine tune. Each flip eliminates half the remaining pages.",
            "connection": "This is why binary search is O(log n). With 1000 pages, you need at most 10 flips (2^10 = 1024). With a million entries, only 20 comparisons!"
          },
          "keyInsight": "Binary search works because sorted order gives you INFORMATION. Knowing arr[mid] < target tells you target CAN'T be in left half. No need to check. This 'free information' is what makes it fast.",
          "commonConfusion": [
            {
              "confusion": "left <= right vs left < right?",
              "clarification": "Use <= when search space includes single element. Use < when left and right converge to answer."
            },
            {
              "confusion": "mid + 1 vs mid?",
              "clarification": "If you checked mid and it's not the answer, exclude it (mid + 1 or mid - 1). If mid might be the answer, keep it (right = mid)."
            },
            {
              "confusion": "Why (right - left) / 2?",
              "clarification": "left + (right - left) / 2 prevents integer overflow. (left + right) / 2 can overflow if both are large."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Binary Search",
                "average": "O(log n)",
                "worst": "O(log n)",
                "note": "Halve search space each step"
              },
              {
                "operation": "Find + Boundary",
                "average": "O(log n)",
                "worst": "O(log n)",
                "note": "Same - don't stop at first find"
              }
            ],
            "explanation": "Each comparison eliminates half. After k comparisons: n/2^k = 1 ‚Üí k = log‚ÇÇ(n)."
          },
          "space": {
            "complexity": "O(1) iterative, O(log n) recursive",
            "explanation": "Iterative uses constant space. Recursive uses stack."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Binary search just uses two pointers (indices). The array is not modified.",
            "keyPoints": [
              "Only 2 pointers: left and right",
              "No extra memory beyond a few variables",
              "Works on any random-access data structure",
              "Iterative is preferred over recursive (no stack overhead)"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Use Math.floor for integer division. No built-in binary search.",
              "gotchas": [
                "JavaScript numbers are floats - no overflow issues",
                "Math.floor((left + right) / 2) is safe in JS",
                "Array.prototype doesn't have binarySearch"
              ]
            },
            "python": {
              "implementation": "Use // for integer division. bisect module available.",
              "gotchas": [
                "bisect.bisect_left() finds insertion point",
                "bisect.bisect_right() / bisect() for right insertion",
                "Python integers don't overflow"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Binary search is O(log n)",
            "proof": {
              "step1": {
                "action": "Start with n elements",
                "cost": "n"
              },
              "step2": {
                "action": "After 1 comparison: n/2 elements",
                "cost": "n/2"
              },
              "step3": {
                "action": "After 2 comparisons: n/4 elements",
                "cost": "n/4"
              },
              "step4": {
                "action": "After k comparisons: n/2^k elements",
                "cost": "n/2^k"
              },
              "step5": {
                "action": "Stop when n/2^k = 1",
                "cost": "k = log‚ÇÇ(n)"
              }
            },
            "totalCost": "O(log n) comparisons"
          }
        },
        "codeTemplates": [
          {
            "name": "Basic Binary Search",
            "description": "Find target in sorted array",
            "javascript": {
              "code": "function binarySearch(arr, target) {\n  let left = 0;\n  let right = arr.length - 1;\n  \n  while (left <= right) {\n    const mid = left + Math.floor((right - left) / 2);\n    \n    if (arr[mid] === target) {\n      return mid;  // Found!\n    } else if (arr[mid] < target) {\n      left = mid + 1;  // Search right half\n    } else {\n      right = mid - 1;  // Search left half\n    }\n  }\n  \n  return -1;  // Not found\n}\n\n// Example:\n// binarySearch([1,3,5,7,9], 5) ‚Üí 2\n// binarySearch([1,3,5,7,9], 4) ‚Üí -1",
              "notes": "left <= right because single element is valid. Exclude mid after checking."
            },
            "python": {
              "code": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\n# Using bisect module\nfrom bisect import bisect_left\n\ndef binary_search_bisect(arr, target):\n    i = bisect_left(arr, target)\n    if i < len(arr) and arr[i] == target:\n        return i\n    return -1",
              "notes": "bisect_left returns insertion point. Check if that position holds target."
            }
          },
          {
            "name": "Find Left Boundary (First Occurrence)",
            "description": "Find leftmost element >= target",
            "javascript": {
              "code": "function findLeftBoundary(arr, target) {\n  let left = 0;\n  let right = arr.length;  // Note: right = length, not length - 1\n  \n  while (left < right) {  // Note: < not <=\n    const mid = left + Math.floor((right - left) / 2);\n    \n    if (arr[mid] < target) {\n      left = mid + 1;  // mid is too small\n    } else {\n      right = mid;  // mid could be answer, keep it\n    }\n  }\n  \n  return left;  // Left is insertion point / first >= target\n}\n\n// Find first occurrence of target\nfunction findFirst(arr, target) {\n  const idx = findLeftBoundary(arr, target);\n  return (idx < arr.length && arr[idx] === target) ? idx : -1;\n}\n\n// Examples:\n// findLeftBoundary([1,2,2,2,3], 2) ‚Üí 1 (first 2)\n// findLeftBoundary([1,2,2,2,3], 2.5) ‚Üí 4 (insertion point)",
              "notes": "right = mid (not mid - 1) because mid could be the answer. Converges to leftmost."
            },
            "python": {
              "code": "def find_left_boundary(arr, target):\n    left, right = 0, len(arr)\n    \n    while left < right:\n        mid = left + (right - left) // 2\n        \n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left\n\ndef find_first(arr, target):\n    idx = find_left_boundary(arr, target)\n    return idx if idx < len(arr) and arr[idx] == target else -1\n\n# Or just use bisect\nfrom bisect import bisect_left\n\ndef find_first_bisect(arr, target):\n    idx = bisect_left(arr, target)\n    return idx if idx < len(arr) and arr[idx] == target else -1",
              "notes": "bisect_left is exactly this algorithm. Returns insertion point."
            }
          },
          {
            "name": "Search on Answer (Minimize Maximum)",
            "description": "Binary search on result space",
            "javascript": {
              "code": "// Koko Eating Bananas - LeetCode 875\n// Find minimum eating speed to finish all piles in h hours\nfunction minEatingSpeed(piles, h) {\n  let left = 1;  // Minimum possible speed\n  let right = Math.max(...piles);  // Maximum possible speed\n  \n  while (left < right) {\n    const mid = left + Math.floor((right - left) / 2);\n    \n    if (canFinish(piles, mid, h)) {\n      right = mid;  // mid works, try smaller\n    } else {\n      left = mid + 1;  // mid doesn't work, need faster\n    }\n  }\n  \n  return left;\n}\n\nfunction canFinish(piles, speed, h) {\n  let hours = 0;\n  for (const pile of piles) {\n    hours += Math.ceil(pile / speed);\n  }\n  return hours <= h;\n}\n\n// Pattern: Binary search on answer space when:\n// 1. Answer has a range [min, max]\n// 2. There's a monotonic \"feasibility\" function\n// 3. You want minimum/maximum feasible answer",
              "notes": "The key insight: we're not searching an array, we're searching the ANSWER space."
            },
            "python": {
              "code": "import math\n\ndef min_eating_speed(piles, h):\n    left, right = 1, max(piles)\n    \n    while left < right:\n        mid = left + (right - left) // 2\n        \n        if can_finish(piles, mid, h):\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\ndef can_finish(piles, speed, h):\n    hours = sum(math.ceil(pile / speed) for pile in piles)\n    return hours <= h\n\n# The pattern:\n# 1. Define search space: [min_possible, max_possible]\n# 2. Define condition: can we achieve X?\n# 3. Binary search for minimum/maximum valid X",
              "notes": "Search space is speed (1 to max pile). Condition is 'can finish in h hours'."
            }
          }
        ],
        "visualTrace": {
          "title": "Binary Search for 7 in [1,2,3,4,5,6,7,8,9]",
          "input": {
            "array": "[1,2,3,4,5,6,7,8,9]",
            "target": 7
          },
          "steps": [
            {
              "left": 0,
              "right": 8,
              "mid": 4,
              "arr[mid]": 5,
              "compare": "5 < 7",
              "action": "left = 5"
            },
            {
              "left": 5,
              "right": 8,
              "mid": 6,
              "arr[mid]": 7,
              "compare": "7 == 7",
              "action": "FOUND!"
            }
          ],
          "output": "Found 7 at index 6 in 2 comparisons. log‚ÇÇ(9) ‚âà 3.2"
        },
        "commonMistakes": [
          {
            "mistake": "Integer overflow in mid calculation",
            "wrong": "mid = (left + right) / 2 // Can overflow!",
            "right": "mid = left + (right - left) / 2",
            "explanation": "If left + right > MAX_INT, overflow. Subtract first."
          },
          {
            "mistake": "Wrong loop condition for boundary search",
            "wrong": "while (left <= right) { right = mid; }",
            "right": "while (left < right) { right = mid; }",
            "explanation": "With <=, if right = mid, infinite loop when left == right."
          },
          {
            "mistake": "Off-by-one in boundary search",
            "wrong": "right = arr.length - 1 // Might miss insertion at end",
            "right": "right = arr.length // Allow insertion after last element",
            "explanation": "For boundary/insertion, right should be length to allow all positions."
          }
        ],
        "keyTakeaways": [
          "Binary search = O(log n) by halving search space each step",
          "Requires SORTED or MONOTONIC data (all false then all true)",
          "Use left + (right - left) / 2 to avoid overflow",
          "left <= right for exact match; left < right for boundary",
          "right = mid when mid might be answer; right = mid - 1 when excluding",
          "'Search on answer' pattern: binary search the result space, not an array"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Array",
              "why": "Binary search operates on arrays"
            },
            {
              "id": "sorting",
              "label": "Sorting",
              "why": "Data must be sorted"
            }
          ],
          "nextTopics": [
            {
              "id": "binary_search_variations",
              "label": "BS Variations",
              "why": "Rotated array, 2D matrix"
            },
            {
              "id": "two_pointers",
              "label": "Two Pointers",
              "why": "Related pointer manipulation"
            }
          ]
        },
        "patternChain": {
          "description": "Binary search is foundation for many O(log n) solutions",
          "buildsOn": [
            {
              "id": "array",
              "relationship": "Operates on random-access data",
              "whatToKnow": "O(1) index access required"
            },
            {
              "id": "sorting",
              "relationship": "Requires sorted data",
              "whatToKnow": "Sort first if needed"
            }
          ],
          "enables": [
            {
              "id": "search_insert",
              "relationship": "Find insertion point",
              "patternName": "Boundary Search",
              "interviewFrequency": "High"
            },
            {
              "id": "search_rotated",
              "relationship": "Modified BS for rotated",
              "patternName": "Rotated Array",
              "interviewFrequency": "High"
            },
            {
              "id": "search_on_answer",
              "relationship": "BS on result space",
              "patternName": "Minimize/Maximize",
              "interviewFrequency": "Very High"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    ARR[Array] --> BS[Binary Search]\n    SORT[Sorting] --> BS\n    BS --> BND[Boundary Search]\n    BS --> ROT[Rotated Array]\n    BS --> ANS[Search on Answer]\n    BS --> MATRIX[2D Matrix Search]\n    \n    style BS fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "two_pointers",
      "label": "Two Pointers",
      "type": "algo-pattern",
      "description": "Iterating with two references.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Two_pointers_technique"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/two-pointers/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/two-pointers-technique/"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2-3 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft",
        "Apple"
      ],
      "interviewFrequency": "high",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "interviewQuestions": [
        {
          "name": "Valid Palindrome",
          "leetcode": "https://leetcode.com/problems/valid-palindrome/",
          "difficulty": "Easy",
          "companies": [
            "Meta",
            "Amazon",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Basic two-pointer with character filtering",
          "approach": "Left and right pointers. Skip non-alphanumeric. Compare lowercase",
          "followUps": [
            {
              "question": "Valid Palindrome II (one deletion)?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Count palindromic substrings?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Two Sum II - Sorted Array",
          "leetcode": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta"
          ],
          "frequency": "High",
          "whyAsked": "Two pointers on sorted array - no extra space needed",
          "approach": "Left at start, right at end. If sum < target, move left. If > target, move right",
          "followUps": [
            {
              "question": "Three sum?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Closest to target?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "3Sum",
          "leetcode": "https://leetcode.com/problems/3sum/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Microsoft",
            "Apple"
          ],
          "frequency": "Very High",
          "whyAsked": "Sort + fix one + two pointers for remaining - skip duplicates",
          "approach": "Sort array. Fix i, use two pointers for j,k. Skip duplicate values",
          "followUps": [
            {
              "question": "4Sum?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "3Sum Closest?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Count triplets?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Container With Most Water",
          "leetcode": "https://leetcode.com/problems/container-with-most-water/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Goldman Sachs"
          ],
          "frequency": "Very High",
          "whyAsked": "Greedy two-pointer - move shorter line inward",
          "approach": "Left and right at ends. Calculate area. Move the shorter pointer inward",
          "followUps": [
            {
              "question": "Prove why greedy works",
              "answer": "Moving shorter line can only potentially improve area. Moving taller line can only decrease area (width decreases, height can't increase beyond shorter)."
            },
            {
              "question": "Trapping rain water?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Trapping Rain Water",
          "leetcode": "https://leetcode.com/problems/trapping-rain-water/",
          "difficulty": "Hard",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Goldman Sachs",
            "Bloomberg",
            "Flipkart"
          ],
          "frequency": "Very High",
          "whyAsked": "Two pointers with running max from both sides",
          "approach": "Track leftMax and rightMax. Water at position = min(leftMax, rightMax) - height",
          "followUps": [
            {
              "question": "Stack approach?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "3D version?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "teamblind"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Blind (Teamblind)",
              "url": "https://www.teamblind.com/",
              "note": "Crowdsourced FAANG interview experiences"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based categorization"
        },
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with videos"
        }
      ],
      "content": {
        "definition": {
          "simple": "Two pointers means using two index variables to scan data from different positions - often from both ends moving toward middle, or one fast and one slow.",
          "technical": "Two Pointers is a technique that uses two index pointers to traverse data structures (usually arrays or linked lists) simultaneously. It reduces time complexity from O(n¬≤) to O(n) by avoiding nested loops when examining pairs of elements."
        },
        "howItWorks": {
          "explanation": "Imagine two people searching a long bookshelf. Instead of one person checking every book, one starts from the left, one from the right. They move toward each other based on what they find. They meet in the middle having checked everything once. That's O(n), not O(n¬≤).",
          "steps": [
            {
              "step": 1,
              "title": "Initialize Pointers",
              "description": "Place pointers at strategic positions (both ends, same start, etc.).",
              "why": "Position depends on the pattern."
            },
            {
              "step": 2,
              "title": "Loop Until Pointers Meet/Cross",
              "description": "Continue while left < right (or fast catches slow, etc.).",
              "why": "Ensures we process all relevant elements."
            },
            {
              "step": 3,
              "title": "Make Decisions",
              "description": "Based on values at pointers, decide which to move.",
              "why": "The key insight - movement rules encode problem logic."
            },
            {
              "step": 4,
              "title": "Update Pointers",
              "description": "Move one or both pointers based on decision.",
              "why": "Guarantees progress toward termination."
            },
            {
              "step": 5,
              "title": "Track Answer",
              "description": "Update result as needed during traversal.",
              "why": "Collect answer incrementally."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart LR\n    subgraph \"Two Pointers - Opposite Ends\"\n        L[\"left‚Üí\"] --- A1[1] --- A2[2] --- A3[3] --- A4[4] --- A5[5] --- R[\"‚Üêright\"]\n    end\n    \n    subgraph \"Two Pointers - Fast/Slow\"\n        S[\"slow‚Üí\"] --- B1[1] --- B2[2] --- F[\"fast‚Üí‚Üí\"] --- B3[3] --- B4[4]\n    end",
            "caption": "Opposite ends: move toward middle. Fast/slow: fast moves 2x, slow moves 1x."
          }
        },
        "whenToUse": {
          "summary": "Use two pointers when examining pairs/subarrays in sorted data, or detecting cycles in linked lists.",
          "patterns": [
            {
              "pattern": "Opposite Direction (Converging)",
              "signal": "Sorted array, find pair with sum/property",
              "example": "Two Sum (sorted), Container with Most Water, Valid Palindrome",
              "withoutIt": "Nested loops O(n¬≤)",
              "withIt": "Single pass O(n)"
            },
            {
              "pattern": "Same Direction (Fast/Slow)",
              "signal": "Cycle detection, find middle, nth from end",
              "example": "Linked list cycle, middle of linked list, remove nth from end",
              "withoutIt": "Multiple passes or extra space",
              "withIt": "Single pass O(n), O(1) space"
            },
            {
              "pattern": "Partition/Rearrange",
              "signal": "Move elements satisfying condition to one side",
              "example": "Remove duplicates, move zeroes, Dutch National Flag",
              "withoutIt": "Extra array O(n) space",
              "withIt": "In-place O(1) space"
            },
            {
              "pattern": "Merge Two Sorted",
              "signal": "Combine two sorted arrays/lists",
              "example": "Merge sorted arrays, merge sorted lists",
              "withoutIt": "Repeated insertions",
              "withIt": "Linear merge O(n+m)"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Two pointers need some ordering or structure. Avoid on unsorted data when order matters.",
          "antiPatterns": [
            {
              "situation": "Unsorted Array for Sum",
              "why": "No ordering to guide pointer movement",
              "useInstead": "HashMap for O(n)",
              "example": "Two Sum unsorted"
            },
            {
              "situation": "Need All Pairs",
              "why": "Two pointers skip pairs",
              "useInstead": "Nested loops",
              "example": "Generate all pairs"
            },
            {
              "situation": "Non-Linear Structures",
              "why": "Pointers need linear traversal",
              "useInstead": "HashMap or other techniques",
              "example": "Graph problems"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Book Matching Game",
            "story": "You have books sorted by page count on a shelf. You need to find two books that together have exactly 500 pages. One friend starts at the thinnest book (left), another at the thickest (right). If sum < 500, left moves right (need bigger). If sum > 500, right moves left (need smaller). They meet in the middle.",
            "connection": "This works because the array is SORTED. If we're too low, moving left pointer right increases the sum. If too high, moving right pointer left decreases it. We never miss the answer."
          },
          "keyInsight": "Two pointers eliminate unnecessary comparisons. In sorted arrays, once we know sum is too big, we don't need to try bigger values for the current pair. That's why O(n¬≤) becomes O(n).",
          "commonConfusion": [
            {
              "confusion": "When to move which pointer?",
              "clarification": "Depends on what you're optimizing. For sum: too small ‚Üí move left right. Too big ‚Üí move right left."
            },
            {
              "confusion": "Why does fast/slow detect cycles?",
              "clarification": "If there's a cycle, fast will 'lap' slow. Like two runners on a track - faster one catches up."
            },
            {
              "confusion": "Two pointers vs sliding window?",
              "clarification": "Two pointers: usually find pair/element meeting condition. Sliding window: maintain/track subarray property."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Converging Pointers",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Each pointer moves at most n times"
              },
              {
                "operation": "Fast/Slow",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Fast traverses list once"
              },
              {
                "operation": "Partition",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Each element visited once"
              }
            ],
            "explanation": "Total pointer movements = O(n). Each element processed at most twice (once per pointer)."
          },
          "space": {
            "complexity": "O(1)",
            "explanation": "Only pointer variables, no extra data structures."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Just two integer indices. No additional memory allocation.",
            "keyPoints": [
              "Two integer variables (indices or pointers)",
              "Operates on existing array/list in-place",
              "Perfect for memory-constrained scenarios",
              "Indices for arrays, actual pointers for linked lists"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Use indices (let left = 0, right = arr.length - 1).",
              "gotchas": [
                "Strings are immutable - can't swap in-place, use array",
                "For linked lists, use actual node references",
                "while (left < right) for converging, left <= right for inclusive"
              ]
            },
            "python": {
              "implementation": "Indices for arrays, node references for linked lists.",
              "gotchas": [
                "Strings are immutable - convert to list for swaps",
                "Use // for integer division in index calculations",
                "Tuple unpacking for simultaneous updates: left, right = right, left"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Two Sum on sorted array is O(n) with two pointers",
            "proof": {
              "step1": {
                "action": "Initialize left = 0, right = n-1",
                "cost": "O(1)"
              },
              "step2": {
                "action": "Each iteration: move left right OR right left",
                "cost": "O(1) per iteration"
              },
              "step3": {
                "action": "Pointers can only move n times total (left increases, right decreases)",
                "cost": "At most n iterations"
              },
              "step4": {
                "action": "Never miss answer because: if sum too small, current left can't be part of smaller sum with any smaller right",
                "cost": "Correctness"
              }
            },
            "totalCost": "O(n)"
          }
        },
        "codeTemplates": [
          {
            "name": "Two Sum II (Sorted Array)",
            "description": "Classic converging two pointers",
            "javascript": {
              "code": "function twoSum(numbers, target) {\n  let left = 0;\n  let right = numbers.length - 1;\n  \n  while (left < right) {\n    const sum = numbers[left] + numbers[right];\n    \n    if (sum === target) {\n      return [left + 1, right + 1];  // 1-indexed\n    } else if (sum < target) {\n      left++;   // Need bigger sum, move left right\n    } else {\n      right--;  // Need smaller sum, move right left\n    }\n  }\n  \n  return [-1, -1];  // Not found\n}\n\n// Why it works:\n// If sum too small: moving left right increases sum\n// If sum too big: moving right left decreases sum\n// If we skip a valid pair, we would have found it earlier",
              "notes": "Only works on SORTED array. For unsorted, use HashMap."
            },
            "python": {
              "code": "def two_sum(numbers, target):\n    left, right = 0, len(numbers) - 1\n    \n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        \n        if current_sum == target:\n            return [left + 1, right + 1]  # 1-indexed\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return [-1, -1]",
              "notes": "Move left right for bigger sum, right left for smaller."
            }
          },
          {
            "name": "Container With Most Water",
            "description": "Two pointers with greedy choice",
            "javascript": {
              "code": "function maxArea(height) {\n  let left = 0;\n  let right = height.length - 1;\n  let maxWater = 0;\n  \n  while (left < right) {\n    // Water height limited by shorter bar\n    const h = Math.min(height[left], height[right]);\n    const width = right - left;\n    const water = h * width;\n    maxWater = Math.max(maxWater, water);\n    \n    // Move the shorter bar inward\n    // Why? Moving the taller bar can only decrease area\n    // (width shrinks, height capped by shorter)\n    if (height[left] < height[right]) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n  \n  return maxWater;\n}",
              "notes": "Key insight: move the SHORTER bar. Moving taller can't help (still capped by shorter)."
            },
            "python": {
              "code": "def max_area(height):\n    left, right = 0, len(height) - 1\n    max_water = 0\n    \n    while left < right:\n        h = min(height[left], height[right])\n        width = right - left\n        water = h * width\n        max_water = max(max_water, water)\n        \n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return max_water",
              "notes": "Greedy choice: always move the limiting factor (shorter bar)."
            }
          },
          {
            "name": "Fast/Slow Pointer - Cycle Detection",
            "description": "Floyd's Cycle Detection (Tortoise and Hare)",
            "javascript": {
              "code": "function hasCycle(head) {\n  if (!head || !head.next) return false;\n  \n  let slow = head;\n  let fast = head;\n  \n  while (fast && fast.next) {\n    slow = slow.next;        // Move 1 step\n    fast = fast.next.next;   // Move 2 steps\n    \n    if (slow === fast) {\n      return true;  // They met = cycle exists\n    }\n  }\n  \n  return false;  // Fast reached end = no cycle\n}\n\n// Find where cycle begins\nfunction detectCycle(head) {\n  if (!head || !head.next) return null;\n  \n  let slow = head, fast = head;\n  \n  // Phase 1: Detect if cycle exists\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow === fast) break;\n  }\n  \n  if (!fast || !fast.next) return null;\n  \n  // Phase 2: Find cycle start\n  // Reset one pointer to head, move both at same speed\n  slow = head;\n  while (slow !== fast) {\n    slow = slow.next;\n    fast = fast.next;\n  }\n  \n  return slow;  // Cycle starts here\n}",
              "notes": "Phase 1: detect cycle. Phase 2: math proves resetting one pointer finds start."
            },
            "python": {
              "code": "def has_cycle(head):\n    if not head or not head.next:\n        return False\n    \n    slow = fast = head\n    \n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        \n        if slow == fast:\n            return True\n    \n    return False\n\ndef detect_cycle(head):\n    if not head or not head.next:\n        return None\n    \n    slow = fast = head\n    \n    # Phase 1: Find meeting point\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            break\n    \n    if not fast or not fast.next:\n        return None\n    \n    # Phase 2: Find cycle start\n    slow = head\n    while slow != fast:\n        slow = slow.next\n        fast = fast.next\n    \n    return slow",
              "notes": "Floyd's algorithm. Fast moves 2x. If cycle, fast catches slow."
            }
          },
          {
            "name": "Remove Duplicates from Sorted Array",
            "description": "Slow pointer for write position, fast for scanning",
            "javascript": {
              "code": "function removeDuplicates(nums) {\n  if (nums.length === 0) return 0;\n  \n  let slow = 0;  // Write position (last unique element)\n  \n  for (let fast = 1; fast < nums.length; fast++) {\n    if (nums[fast] !== nums[slow]) {\n      slow++;                // Move write position\n      nums[slow] = nums[fast];  // Write new unique\n    }\n    // If equal, just move fast (skip duplicate)\n  }\n  \n  return slow + 1;  // Length of unique portion\n}\n\n// Example: [1,1,2,2,3] ‚Üí [1,2,3,_,_], returns 3\n// slow starts at index 0 (value 1)\n// fast finds 2 (different) ‚Üí slow=1, nums[1]=2\n// fast finds 3 (different) ‚Üí slow=2, nums[2]=3",
              "notes": "Slow = write head. Fast scans. Only write when new value found."
            },
            "python": {
              "code": "def remove_duplicates(nums):\n    if not nums:\n        return 0\n    \n    slow = 0\n    \n    for fast in range(1, len(nums)):\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    \n    return slow + 1",
              "notes": "In-place modification. Returns count of unique elements."
            }
          }
        ],
        "visualTrace": {
          "title": "Two Sum II: numbers = [2,7,11,15], target = 9",
          "input": {
            "array": "[2, 7, 11, 15]",
            "target": 9
          },
          "steps": [
            {
              "left": 0,
              "right": 3,
              "values": "2 + 15 = 17",
              "compare": "17 > 9",
              "action": "right--"
            },
            {
              "left": 0,
              "right": 2,
              "values": "2 + 11 = 13",
              "compare": "13 > 9",
              "action": "right--"
            },
            {
              "left": 0,
              "right": 1,
              "values": "2 + 7 = 9",
              "compare": "9 == 9",
              "action": "FOUND!"
            }
          ],
          "output": "[1, 2] (1-indexed). Found in 3 iterations instead of 6 pairs (n*(n-1)/2)."
        },
        "commonMistakes": [
          {
            "mistake": "Using two pointers on unsorted array for sum",
            "wrong": "Two Sum on [3,1,2] with two pointers // Wrong order!",
            "right": "Sort first, or use HashMap",
            "explanation": "Two pointers relies on sorted order to decide which pointer to move."
          },
          {
            "mistake": "Off-by-one in loop condition",
            "wrong": "while (left <= right) { left++; right--; } // May process same element twice",
            "right": "while (left < right) for pairs",
            "explanation": "Use < when processing pairs, <= when single middle element matters."
          },
          {
            "mistake": "Not moving pointer after finding match",
            "wrong": "if (found) return; // But what about finding all pairs?",
            "right": "Move both pointers after match to continue",
            "explanation": "For finding all pairs, move both pointers after match (skip duplicates if needed)."
          }
        ],
        "keyTakeaways": [
          "Two pointers reduces O(n¬≤) to O(n) by eliminating redundant comparisons",
          "Converging: start from both ends, meet in middle (sorted arrays)",
          "Fast/Slow: one moves 2x speed (cycle detection, find middle)",
          "Partition: slow marks boundary, fast scans (remove duplicates)",
          "REQUIRES sorted data or special structure to guide movement",
          "O(1) extra space - just pointer variables"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Array",
              "why": "Two pointers operate on arrays"
            },
            {
              "id": "sorting",
              "label": "Sorting",
              "why": "Often requires sorted input"
            }
          ],
          "nextTopics": [
            {
              "id": "sliding_window",
              "label": "Sliding Window",
              "why": "Related pointer technique"
            },
            {
              "id": "three_sum",
              "label": "3Sum",
              "why": "Two pointers inside outer loop"
            },
            {
              "id": "linked_list_techniques",
              "label": "Linked List Techniques",
              "why": "Fast/slow for LL problems"
            }
          ]
        },
        "patternChain": {
          "description": "Two pointers is a fundamental optimization technique",
          "buildsOn": [
            {
              "id": "array",
              "relationship": "Operates on array indices",
              "whatToKnow": "Random access O(1)"
            },
            {
              "id": "sorting",
              "relationship": "Often requires sorted input",
              "whatToKnow": "Sort first if needed"
            }
          ],
          "enables": [
            {
              "id": "three_sum",
              "relationship": "Sort + loop + two pointers",
              "patternName": "3Sum Pattern",
              "interviewFrequency": "Very High"
            },
            {
              "id": "container_water",
              "relationship": "Greedy two pointer",
              "patternName": "Greedy Pointers",
              "interviewFrequency": "High"
            },
            {
              "id": "cycle_detection",
              "relationship": "Fast/slow pointers",
              "patternName": "Floyd's Cycle",
              "interviewFrequency": "High"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    ARR[Array] --> TP[Two Pointers]\n    SORT[Sorting] --> TP\n    TP --> SUM[Two Sum II]\n    TP --> 3S[3Sum]\n    TP --> CYC[Cycle Detection]\n    TP --> PART[Partition]\n    TP --> SW[Sliding Window]\n    \n    style TP fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "sliding_window",
      "label": "Sliding Window",
      "type": "algo-pattern",
      "description": "Sub-array optimization.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Sliding_window_protocol"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/sliding-window/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/window-sliding-technique/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "3-4 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft",
        "Stripe"
      ],
      "interviewFrequency": "high",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "interviewQuestions": [
        {
          "name": "Best Time to Buy and Sell Stock",
          "leetcode": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
          "difficulty": "Easy",
          "companies": [
            "Amazon",
            "Meta",
            "Google",
            "Goldman Sachs"
          ],
          "frequency": "Very High",
          "whyAsked": "Basic sliding window / running minimum pattern",
          "approach": "Track minimum price so far. At each price, calculate profit. Track max profit",
          "followUps": [
            {
              "question": "Multiple transactions?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "With cooldown?",
              "answer": "State machine DP: hold[i], sold[i], rest[i]. Transitions between states based on action."
            },
            {
              "question": "With fee?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Longest Substring Without Repeating Characters",
          "leetcode": "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Microsoft",
            "Bloomberg"
          ],
          "frequency": "Very High",
          "whyAsked": "Classic sliding window with set/map for duplicates",
          "approach": "Expand right. If duplicate, shrink left until valid. Track max length",
          "followUps": [
            {
              "question": "At most k distinct?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Minimum window substring?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Minimum Window Substring",
          "leetcode": "https://leetcode.com/problems/minimum-window-substring/",
          "difficulty": "Hard",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Uber",
            "LinkedIn"
          ],
          "frequency": "Very High",
          "whyAsked": "Advanced sliding window with character frequency matching",
          "approach": "Expand to include all chars of t. Contract to minimize. Track counts with have/need",
          "followUps": [
            {
              "question": "All starting indices?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "With k distinct?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Sliding Window Maximum",
          "leetcode": "https://leetcode.com/problems/sliding-window-maximum/",
          "difficulty": "Hard",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Citadel"
          ],
          "frequency": "High",
          "whyAsked": "Monotonic deque for O(n) sliding window max",
          "approach": "Monotonic decreasing deque. Front is always max. Remove out-of-window and smaller elements",
          "followUps": [
            {
              "question": "Minimum instead of max?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Sum of all window maxes?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "teamblind"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Blind (Teamblind)",
              "url": "https://www.teamblind.com/",
              "note": "Crowdsourced FAANG interview experiences"
            }
          ]
        },
        {
          "name": "Permutation in String",
          "leetcode": "https://leetcode.com/problems/permutation-in-string/",
          "difficulty": "Medium",
          "companies": [
            "Microsoft",
            "Amazon",
            "Google"
          ],
          "frequency": "High",
          "whyAsked": "Fixed-size sliding window with frequency matching",
          "approach": "Fixed window of s1 length. Slide through s2, compare char frequencies",
          "followUps": [
            {
              "question": "Find all anagrams?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Return starting indices?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based categorization"
        },
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with videos"
        }
      ],
      "content": {
        "definition": {
          "simple": "Sliding window maintains a 'window' over a contiguous portion of data, sliding it along to track properties like sum, max, or character counts. Instead of recalculating from scratch each time, we add the new element and remove the old.",
          "technical": "Sliding Window is a technique that converts O(n*k) brute force approaches to O(n) by maintaining a window of elements and updating it incrementally. Fixed-size windows slide by one position; variable-size windows expand/contract based on conditions."
        },
        "howItWorks": {
          "explanation": "Imagine looking through a picture frame at a long mural. Instead of photographing every possible section, you slide the frame smoothly across. At each position, only the entering/exiting pieces change - the middle stays the same. Update incrementally, don't recalculate.",
          "steps": [
            {
              "step": 1,
              "title": "Initialize Window",
              "description": "Set left and right pointers, initialize window state (sum, map, etc.).",
              "why": "Define initial window and tracking variables."
            },
            {
              "step": 2,
              "title": "Expand (Move Right)",
              "description": "Add element at right to window, update state.",
              "why": "Grow window by including new element."
            },
            {
              "step": 3,
              "title": "Check Condition",
              "description": "Is window valid? Too big? Contains what we need?",
              "why": "Determine if we need to shrink or record answer."
            },
            {
              "step": 4,
              "title": "Contract (Move Left)",
              "description": "If needed, remove element at left, update state.",
              "why": "Shrink window to maintain constraint."
            },
            {
              "step": 5,
              "title": "Record Answer",
              "description": "Update result (min length, max sum, etc.) when window meets criteria.",
              "why": "Capture best answer during traversal."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart LR\n    subgraph \"Fixed Window k=3\"\n        A1[1] --- A2[2] --- A3[3] --- A4[4] --- A5[5]\n    end\n    \n    subgraph \"Step 1\"\n        B1[\"[1,2,3]\"] --> B2[\"sum=6\"]\n    end\n    \n    subgraph \"Step 2\"\n        C1[\"[2,3,4]\"] --> C2[\"sum=9\"]\n    end\n    \n    style B1 fill:#98c1d9\n    style C1 fill:#ee6c4d",
            "caption": "Fixed window slides: remove 1 (subtract), add 4 (add). O(1) update, not O(k) recalculation."
          }
        },
        "whenToUse": {
          "summary": "Use sliding window for contiguous subarray/substring problems involving sum, count, or character frequency.",
          "patterns": [
            {
              "pattern": "Fixed Size Window",
              "signal": "Find max/min/average of all subarrays of size k",
              "example": "Max sum subarray of size k, moving average",
              "withoutIt": "O(n*k) - recalculate each window",
              "withIt": "O(n) - update incrementally"
            },
            {
              "pattern": "Variable Size - Longest",
              "signal": "Find longest subarray/substring satisfying condition",
              "example": "Longest substring without repeating chars, max consecutive ones",
              "withoutIt": "O(n¬≤) - try all subarrays",
              "withIt": "O(n) - expand until invalid, then shrink"
            },
            {
              "pattern": "Variable Size - Shortest",
              "signal": "Find shortest/minimum subarray satisfying condition",
              "example": "Minimum size subarray sum, minimum window substring",
              "withoutIt": "O(n¬≤) - try all subarrays",
              "withIt": "O(n) - expand until valid, shrink while still valid"
            },
            {
              "pattern": "Count Subarrays",
              "signal": "Count subarrays satisfying condition",
              "example": "Subarrays with k distinct, subarrays with sum = k",
              "withoutIt": "O(n¬≤) enumeration",
              "withIt": "O(n) with clever counting (atMost(k) - atMost(k-1))"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Sliding window needs contiguous elements. Avoid for subsequences or when element order doesn't matter.",
          "antiPatterns": [
            {
              "situation": "Non-Contiguous (Subsequence)",
              "why": "Window requires contiguous elements",
              "useInstead": "DP or Two Pointers",
              "example": "Longest increasing subsequence"
            },
            {
              "situation": "Element Order Doesn't Matter",
              "why": "No 'sliding' makes sense",
              "useInstead": "Sorting or HashMap",
              "example": "Two Sum"
            },
            {
              "situation": "Global Property",
              "why": "Can't be computed from window",
              "useInstead": "Full scan or other technique",
              "example": "Median of entire array"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Moving Train Window",
            "story": "You're on a train looking out a fixed-size window. As the train moves, new scenery enters from one side, old scenery exits from the other. You don't re-examine all the scenery - you just note what changed. 'Lost a tree, gained a building.'",
            "connection": "That's sliding window. When the window moves one position, we add the new element's contribution and remove the old. O(1) update per slide, O(n) total."
          },
          "keyInsight": "Sliding window works because we can INCREMENTALLY update the window state. If computing window property requires seeing ALL elements every time, sliding window won't help.",
          "commonConfusion": [
            {
              "confusion": "Fixed vs variable window?",
              "clarification": "Fixed: window size constant, slide right. Variable: expand right until invalid, shrink left until valid."
            },
            {
              "confusion": "When to move left pointer?",
              "clarification": "For 'longest': shrink when window becomes invalid. For 'shortest': shrink while window is still valid."
            },
            {
              "confusion": "Sliding window vs two pointers?",
              "clarification": "Sliding window: contiguous subarray, track state. Two pointers: often opposite ends, or fast/slow."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Fixed Window",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Each element enters and leaves window once"
              },
              {
                "operation": "Variable Window",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Left and right each move at most n times"
              }
            ],
            "explanation": "Each element is added once (right moves) and removed once (left moves). Total: 2n operations = O(n)."
          },
          "space": {
            "complexity": "O(1) to O(k)",
            "explanation": "O(1) for sum/count. O(k) or O(26) for character frequency maps."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Two pointers (left, right) plus window state (sum, map, count).",
            "keyPoints": [
              "left and right pointers define window bounds",
              "State: sum (integer), or frequency map (Map/object)",
              "For character problems: often 26-size array or Map",
              "No extra array needed - operate on original"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Use Map for character counts, or object if only lowercase letters.",
              "gotchas": [
                "Map.get() returns undefined if not present - use || 0",
                "String.charAt(i) or string[i] for character access",
                "For ASCII: use array of size 128"
              ]
            },
            "python": {
              "implementation": "collections.Counter or defaultdict(int) for frequency.",
              "gotchas": [
                "Counter can go negative - check for == 0 carefully",
                "collections.defaultdict(int) auto-initializes to 0",
                "String slicing creates new string - avoid in hot path"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Variable sliding window is O(n)",
            "proof": {
              "step1": {
                "action": "right pointer moves from 0 to n-1",
                "cost": "n increments"
              },
              "step2": {
                "action": "left pointer moves from 0 to at most n-1",
                "cost": "at most n increments"
              },
              "step3": {
                "action": "Each element added once (right) and removed once (left)",
                "cost": "2n operations"
              },
              "step4": {
                "action": "Add/remove operations are O(1)",
                "cost": "O(1) each"
              }
            },
            "totalCost": "O(n)"
          }
        },
        "codeTemplates": [
          {
            "name": "Fixed Size Window Template",
            "description": "Max sum of subarray of size k",
            "javascript": {
              "code": "function maxSumSubarray(arr, k) {\n  let windowSum = 0;\n  let maxSum = -Infinity;\n  \n  for (let i = 0; i < arr.length; i++) {\n    windowSum += arr[i];  // Add incoming element\n    \n    if (i >= k - 1) {\n      maxSum = Math.max(maxSum, windowSum);\n      windowSum -= arr[i - k + 1];  // Remove outgoing element\n    }\n  }\n  \n  return maxSum;\n}\n\n// Template pattern:\n// 1. Expand window by adding arr[right]\n// 2. When window reaches size k, record answer\n// 3. Shrink by removing arr[left], move left",
              "notes": "Window reaches size k when i >= k-1. Remove element that's sliding out."
            },
            "python": {
              "code": "def max_sum_subarray(arr, k):\n    window_sum = 0\n    max_sum = float('-inf')\n    \n    for i in range(len(arr)):\n        window_sum += arr[i]\n        \n        if i >= k - 1:\n            max_sum = max(max_sum, window_sum)\n            window_sum -= arr[i - k + 1]\n    \n    return max_sum",
              "notes": "Fixed window: add right, when full: record + remove left."
            }
          },
          {
            "name": "Longest Substring Without Repeating Characters",
            "description": "Variable window - expand until duplicate, shrink until valid",
            "javascript": {
              "code": "function lengthOfLongestSubstring(s) {\n  const charIndex = new Map();  // char -> last index\n  let maxLen = 0;\n  let left = 0;\n  \n  for (let right = 0; right < s.length; right++) {\n    const char = s[right];\n    \n    // If char seen and within current window, move left past it\n    if (charIndex.has(char) && charIndex.get(char) >= left) {\n      left = charIndex.get(char) + 1;\n    }\n    \n    charIndex.set(char, right);\n    maxLen = Math.max(maxLen, right - left + 1);\n  }\n  \n  return maxLen;\n}\n\n// Alternative with Set (cleaner logic)\nfunction lengthOfLongestSubstring2(s) {\n  const seen = new Set();\n  let maxLen = 0;\n  let left = 0;\n  \n  for (let right = 0; right < s.length; right++) {\n    while (seen.has(s[right])) {\n      seen.delete(s[left]);\n      left++;\n    }\n    seen.add(s[right]);\n    maxLen = Math.max(maxLen, right - left + 1);\n  }\n  \n  return maxLen;\n}",
              "notes": "Map stores last index - jump left past duplicate. Set approach shrinks until valid."
            },
            "python": {
              "code": "def length_of_longest_substring(s):\n    char_index = {}\n    max_len = 0\n    left = 0\n    \n    for right, char in enumerate(s):\n        if char in char_index and char_index[char] >= left:\n            left = char_index[char] + 1\n        \n        char_index[char] = right\n        max_len = max(max_len, right - left + 1)\n    \n    return max_len\n\n# Set approach\ndef length_of_longest_substring_set(s):\n    seen = set()\n    max_len = 0\n    left = 0\n    \n    for right in range(len(s)):\n        while s[right] in seen:\n            seen.remove(s[left])\n            left += 1\n        seen.add(s[right])\n        max_len = max(max_len, right - left + 1)\n    \n    return max_len",
              "notes": "Track last seen index to jump left pointer. Or shrink until no duplicate."
            }
          },
          {
            "name": "Minimum Window Substring",
            "description": "Find shortest substring containing all target chars",
            "javascript": {
              "code": "function minWindow(s, t) {\n  if (t.length > s.length) return '';\n  \n  // Count chars needed\n  const need = new Map();\n  for (const c of t) {\n    need.set(c, (need.get(c) || 0) + 1);\n  }\n  \n  let have = 0;\n  const required = need.size;  // Unique chars to match\n  const window = new Map();\n  \n  let minLen = Infinity;\n  let minStart = 0;\n  let left = 0;\n  \n  for (let right = 0; right < s.length; right++) {\n    const c = s[right];\n    window.set(c, (window.get(c) || 0) + 1);\n    \n    // Check if this char is now satisfied\n    if (need.has(c) && window.get(c) === need.get(c)) {\n      have++;\n    }\n    \n    // Shrink window while valid\n    while (have === required) {\n      if (right - left + 1 < minLen) {\n        minLen = right - left + 1;\n        minStart = left;\n      }\n      \n      const leftChar = s[left];\n      window.set(leftChar, window.get(leftChar) - 1);\n      \n      if (need.has(leftChar) && window.get(leftChar) < need.get(leftChar)) {\n        have--;\n      }\n      left++;\n    }\n  }\n  \n  return minLen === Infinity ? '' : s.slice(minStart, minStart + minLen);\n}",
              "notes": "Expand until valid, shrink while still valid to find minimum. Track satisfied count."
            },
            "python": {
              "code": "from collections import Counter, defaultdict\n\ndef min_window(s, t):\n    if len(t) > len(s):\n        return ''\n    \n    need = Counter(t)\n    window = defaultdict(int)\n    \n    have, required = 0, len(need)\n    min_len = float('inf')\n    min_start = 0\n    left = 0\n    \n    for right, c in enumerate(s):\n        window[c] += 1\n        \n        if c in need and window[c] == need[c]:\n            have += 1\n        \n        while have == required:\n            if right - left + 1 < min_len:\n                min_len = right - left + 1\n                min_start = left\n            \n            left_char = s[left]\n            window[left_char] -= 1\n            \n            if left_char in need and window[left_char] < need[left_char]:\n                have -= 1\n            left += 1\n    \n    return '' if min_len == float('inf') else s[min_start:min_start + min_len]",
              "notes": "Counter for target frequency. Shrink while window contains all needed chars."
            }
          }
        ],
        "visualTrace": {
          "title": "Longest Substring Without Repeating: s = 'abcabcbb'",
          "input": {
            "string": "abcabcbb"
          },
          "steps": [
            {
              "window": "a",
              "left": 0,
              "right": 0,
              "seen": "{a}",
              "maxLen": 1
            },
            {
              "window": "ab",
              "left": 0,
              "right": 1,
              "seen": "{a,b}",
              "maxLen": 2
            },
            {
              "window": "abc",
              "left": 0,
              "right": 2,
              "seen": "{a,b,c}",
              "maxLen": 3
            },
            {
              "window": "bca",
              "left": 1,
              "right": 3,
              "seen": "{b,c,a}",
              "action": "a duplicate, move left past old a",
              "maxLen": 3
            },
            {
              "window": "cab",
              "left": 2,
              "right": 4,
              "seen": "{c,a,b}",
              "action": "b duplicate, move left",
              "maxLen": 3
            },
            {
              "window": "abc",
              "left": 3,
              "right": 5,
              "seen": "{a,b,c}",
              "maxLen": 3
            }
          ],
          "output": "3 (window 'abc')"
        },
        "commonMistakes": [
          {
            "mistake": "Off-by-one in window size",
            "wrong": "if (i > k) // Window is size k+1!",
            "right": "if (i >= k - 1) // Window is exactly size k",
            "explanation": "Window [i-k+1, i] has k elements when i >= k-1."
          },
          {
            "mistake": "Not updating left pointer for variable window",
            "wrong": "Only move right, never shrink",
            "right": "Shrink when window becomes invalid (for longest) or while valid (for shortest)",
            "explanation": "Variable window must contract to find optimal answer."
          },
          {
            "mistake": "Wrong condition for minimum window",
            "wrong": "Shrink when window becomes invalid",
            "right": "Shrink WHILE window is still valid",
            "explanation": "For minimum, keep shrinking while condition holds to find smallest."
          }
        ],
        "keyTakeaways": [
          "Sliding window converts O(n*k) to O(n) for contiguous subarray problems",
          "Fixed window: expand then slide. Variable: expand until invalid, shrink until valid.",
          "For 'longest': expand always, shrink when invalid",
          "For 'shortest': expand until valid, shrink while still valid",
          "Track window state (sum, map, count) and update incrementally",
          "Each element enters and exits window once ‚Üí O(n)"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Array",
              "why": "Operates on arrays/strings"
            },
            {
              "id": "hashmap",
              "label": "HashMap",
              "why": "Track character frequencies"
            },
            {
              "id": "two_pointers",
              "label": "Two Pointers",
              "why": "Window defined by two pointers"
            }
          ],
          "nextTopics": [
            {
              "id": "sliding_window_max",
              "label": "Sliding Window Maximum",
              "why": "Monotonic deque variation"
            },
            {
              "id": "subarray_sum",
              "label": "Subarray Sum Problems",
              "why": "Prefix sum alternative"
            }
          ]
        },
        "patternChain": {
          "description": "Sliding window optimizes contiguous subarray queries",
          "buildsOn": [
            {
              "id": "two_pointers",
              "relationship": "Window is two-pointer variant",
              "whatToKnow": "left and right define bounds"
            },
            {
              "id": "hashmap",
              "relationship": "Track window contents",
              "whatToKnow": "Character frequency maps"
            }
          ],
          "enables": [
            {
              "id": "longest_substring",
              "relationship": "Variable window pattern",
              "patternName": "Longest Valid",
              "interviewFrequency": "Very High"
            },
            {
              "id": "minimum_window",
              "relationship": "Shrink while valid",
              "patternName": "Shortest Valid",
              "interviewFrequency": "High"
            },
            {
              "id": "subarray_sum",
              "relationship": "Fixed/variable sum windows",
              "patternName": "Subarray Sum",
              "interviewFrequency": "High"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    TP[Two Pointers] --> SW[Sliding Window]\n    HM[HashMap] --> SW\n    SW --> LONG[Longest Substring]\n    SW --> MIN[Minimum Window]\n    SW --> SUM[Subarray Sum]\n    SW --> PERM[Permutation in String]\n    \n    style SW fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "tree",
      "label": "Tree",
      "type": "ds-hierarchical",
      "description": "Hierarchical node structure.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Tree_(data_structure)"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/bst"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/tree/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/introduction-to-tree-data-structure/"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2-3 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft",
        "Apple"
      ],
      "interviewFrequency": "high",
      "category": "Tree DS",
      "categoryIcon": "üå≥",
      "interviewQuestions": [
        {
          "name": "Invert Binary Tree",
          "leetcode": "https://leetcode.com/problems/invert-binary-tree/",
          "difficulty": "Easy",
          "companies": [
            "Google",
            "Amazon",
            "Meta"
          ],
          "frequency": "High",
          "whyAsked": "Famous for Homebrew creator story. Tests basic tree recursion",
          "approach": "Recursively swap left and right children. Base case: null node. O(n)",
          "followUps": [
            {
              "question": "Iterative solution?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Only invert at certain level?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "Maximum Depth of Binary Tree",
          "leetcode": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
          "difficulty": "Easy",
          "companies": [
            "Amazon",
            "Google",
            "Microsoft"
          ],
          "frequency": "High",
          "whyAsked": "Basic tree recursion pattern",
          "approach": "Return 1 + max(depth(left), depth(right)). Base case: null = 0. O(n)",
          "followUps": [
            {
              "question": "Minimum depth?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Iterative BFS?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "Lowest Common Ancestor of BST",
          "leetcode": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Microsoft",
            "LinkedIn"
          ],
          "frequency": "Very High",
          "whyAsked": "Tests BST property usage for efficient search",
          "approach": "If both nodes < current, go left. Both > current, go right. Else current is LCA. O(h)",
          "followUps": [
            {
              "question": "LCA of binary tree (not BST)?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "LCA with parent pointers?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Binary Tree Level Order Traversal",
          "leetcode": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Meta",
            "Google",
            "Microsoft"
          ],
          "frequency": "High",
          "whyAsked": "BFS on trees, level-by-level processing",
          "approach": "BFS with queue. Process level by level using queue size. O(n)",
          "followUps": [
            {
              "question": "Zigzag order?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Right side view?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Bottom-up order?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "Left View of Binary Tree",
          "gfg": "https://www.geeksforgeeks.org/problems/left-view-of-binary-tree/1",
          "difficulty": "Easy",
          "companies": [
            "Flipkart",
            "Amazon",
            "Microsoft",
            "Paytm"
          ],
          "frequency": "High",
          "whyAsked": "Level order traversal - capture first node of each level",
          "approach": "BFS level by level, add first node of each level to result. Or DFS with level tracking.",
          "followUps": [
            {
              "question": "Right side view?",
              "answer": "Same approach but take last node of each level instead of first."
            },
            {
              "question": "Bottom view?",
              "answer": "Use horizontal distance mapping. BFS with (node, hd) pairs. Last node at each hd is bottom view."
            },
            {
              "question": "Top view?",
              "answer": "Use horizontal distance mapping. BFS with (node, hd) pairs. First node at each hd is top view."
            }
          ],
          "sources": [
            "gfg"
          ],
          "sourceDetails": [
            {
              "name": "GeeksforGeeks",
              "url": "https://www.geeksforgeeks.org/explore?company=Flipkart",
              "note": "Top Flipkart problem"
            }
          ]
        },
        {
          "name": "Validate Binary Search Tree",
          "leetcode": "https://leetcode.com/problems/validate-binary-search-tree/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Meta",
            "Microsoft",
            "Bloomberg"
          ],
          "frequency": "High",
          "whyAsked": "Tests understanding of BST invariant with range checking",
          "approach": "Pass min/max range down. Each node must be within range. O(n)",
          "followUps": [
            {
              "question": "In-order traversal approach?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Recover BST with two swapped nodes?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Serialize and Deserialize Binary Tree",
          "leetcode": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/",
          "difficulty": "Hard",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Microsoft",
            "LinkedIn"
          ],
          "frequency": "Very High",
          "whyAsked": "Tests tree traversal + string parsing. Common in distributed systems",
          "approach": "Preorder with null markers. Serialize: DFS with 'null' for empty. Deserialize: use queue/index",
          "followUps": [
            {
              "question": "BST serialization (more compact)?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "N-ary tree?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "teamblind"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Blind (Teamblind)",
              "url": "https://www.teamblind.com/",
              "note": "Crowdsourced interview experiences from FAANG employees"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based problem categorization"
        },
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with video explanations"
        }
      ],
      "content": {
        "definition": {
          "simple": "A tree is like a family tree - one root, branches out, each node connects to children below. No loops, just parent-child relationships.",
          "technical": "A tree is a hierarchical data structure consisting of nodes connected by edges. It has exactly one root with no parent, and every other node has exactly one parent. Nodes with no children are called leaves. Unlike graphs, trees are acyclic (no loops)."
        },
        "howItWorks": {
          "explanation": "Think of a company org chart. CEO at top (root), then managers (children), then employees (leaves). Each person has one boss (parent), but can manage multiple people (children). Information flows down the hierarchy.",
          "steps": [
            {
              "step": 1,
              "title": "Root",
              "description": "Entry point. Only node with no parent.",
              "why": "Starting point for all traversals."
            },
            {
              "step": 2,
              "title": "Edges",
              "description": "Connections from parent to child.",
              "why": "Define relationships. n nodes = n-1 edges."
            },
            {
              "step": 3,
              "title": "Traverse",
              "description": "Visit nodes in specific order (DFS: preorder/inorder/postorder, or BFS: level order).",
              "why": "Different orders serve different purposes."
            },
            {
              "step": 4,
              "title": "Height/Depth",
              "description": "Height = longest path to leaf. Depth = distance from root.",
              "why": "Affects traversal time O(h) for operations."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph TD\n    R[\"Root: 10\"] --> L[\"Left: 5\"]\n    R --> R2[\"Right: 15\"]\n    L --> LL[\"3\"]\n    L --> LR[\"7\"]\n    R2 --> RL[\"12\"]\n    R2 --> RR[\"20\"]\n    \n    style R fill:#ee6c4d\n    style LL fill:#98c1d9\n    style LR fill:#98c1d9\n    style RL fill:#98c1d9\n    style RR fill:#98c1d9",
            "caption": "Binary Search Tree: Left child < Parent < Right child. Leaves in blue, root in orange."
          }
        },
        "whenToUse": {
          "summary": "Use trees for hierarchical data, when you need O(log n) search/insert, or when structure reflects parent-child relationships.",
          "patterns": [
            {
              "pattern": "Hierarchical Data",
              "signal": "Data has natural parent-child relationships",
              "example": "File system, org chart, HTML DOM",
              "withoutIt": "Flat lists don't show relationships",
              "withIt": "Tree structure mirrors real hierarchy"
            },
            {
              "pattern": "Fast Search/Insert (BST)",
              "signal": "Need O(log n) lookup in sorted data",
              "example": "Dictionary, database index",
              "withoutIt": "Array: O(n) search or O(n) insert (sorted)",
              "withIt": "BST: O(log n) both (if balanced)"
            },
            {
              "pattern": "Prefix Matching",
              "signal": "Autocomplete, word validation",
              "example": "Search suggestions, spell checker",
              "withoutIt": "Check all words - O(n * m)",
              "withIt": "Trie - O(m) where m = word length"
            },
            {
              "pattern": "Range Queries",
              "signal": "Find all values in range [a, b]",
              "example": "Database range scan",
              "withoutIt": "Scan all elements",
              "withIt": "BST inorder traversal between bounds"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Trees need O(log n) height to be efficient. Avoid when data has no hierarchy or when hash lookup suffices.",
          "antiPatterns": [
            {
              "situation": "Need O(1) Lookup by Key",
              "why": "Even balanced BST is O(log n)",
              "useInstead": "HashMap",
              "example": "Cache, seen set"
            },
            {
              "situation": "Data Has Cycles",
              "why": "Trees are acyclic by definition",
              "useInstead": "Graph",
              "example": "Social networks, road maps"
            },
            {
              "situation": "Simple List Operations",
              "why": "Overkill for sequential access",
              "useInstead": "Array or Linked List",
              "example": "Queue, stack"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Family Tree",
            "story": "A family tree shows ancestry. One ancestor at top (root). Each person can have children, but only one biological parent in our simple model. Siblings are at the same level. You can trace from any person back to the root ancestor.",
            "connection": "In computer trees, we often recursively solve problems: 'Solve for left subtree, solve for right subtree, combine results.' Each subtree is itself a smaller tree - just like each branch of a family is itself a smaller family tree."
          },
          "keyInsight": "Trees enable divide-and-conquer. A balanced tree with n nodes has height log‚ÇÇ(n). Each level doubles the nodes. 1 ‚Üí 2 ‚Üí 4 ‚Üí 8 ‚Üí 16... This is why 1 billion nodes only needs ~30 levels.",
          "commonConfusion": [
            {
              "confusion": "Binary Tree vs BST?",
              "clarification": "Binary Tree: each node has ‚â§2 children (no ordering). BST: left < parent < right."
            },
            {
              "confusion": "Height vs Depth?",
              "clarification": "Depth = distance FROM root (root=0). Height = longest path TO leaf."
            },
            {
              "confusion": "Why O(log n)?",
              "clarification": "Each comparison eliminates half the tree. log‚ÇÇ(n) halvings to get to 1."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Search (BST balanced)",
                "average": "O(log n)",
                "worst": "O(n)",
                "note": "Worst = unbalanced (linked list shape)"
              },
              {
                "operation": "Insert (BST balanced)",
                "average": "O(log n)",
                "worst": "O(n)",
                "note": "Same - depends on height"
              },
              {
                "operation": "Delete (BST balanced)",
                "average": "O(log n)",
                "worst": "O(n)",
                "note": "Find + restructure"
              },
              {
                "operation": "Traversal (any)",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Must visit all nodes"
              }
            ],
            "explanation": "BST operations are O(h) where h = height. Balanced tree: h = log n. Unbalanced: h = n."
          },
          "space": {
            "complexity": "O(n) for storage, O(h) for recursion stack",
            "explanation": "n nodes stored. Recursive calls use stack up to tree height."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Each node contains value + pointers to children. Unlike arrays, nodes scattered in memory (not contiguous).",
            "keyPoints": [
              "Node = { val, left, right } - 3 fields minimum",
              "Parent pointer optional (trades space for convenience)",
              "Memory not contiguous - cache-unfriendly compared to arrays",
              "Recursion uses call stack - O(h) space for traversals"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Class-based nodes. Use null for empty children.",
              "gotchas": [
                "No built-in tree - always implement yourself",
                "Deep recursion can hit stack limit (~10k calls)",
                "Use iterative with explicit stack for production"
              ]
            },
            "python": {
              "implementation": "Class-based nodes or namedtuple. None for empty.",
              "gotchas": [
                "Default recursion limit ~1000 - increase with sys.setrecursionlimit()",
                "Use iterative for deep trees",
                "dataclasses work great for TreeNode"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Balanced BST search is O(log n)",
            "proof": {
              "step1": {
                "action": "Compare with root",
                "cost": "O(1)",
                "result": "Eliminate half of nodes"
              },
              "step2": {
                "action": "Recurse into left OR right subtree",
                "cost": "T(n/2)",
                "result": "Half the problem"
              },
              "step3": {
                "action": "Recurrence: T(n) = T(n/2) + O(1)",
                "cost": "Master theorem",
                "result": "O(log n)"
              }
            },
            "totalCost": "O(log n) - each step halves remaining nodes"
          }
        },
        "codeTemplates": [
          {
            "name": "TreeNode + Basic Traversals",
            "description": "Node class and DFS traversals",
            "javascript": {
              "code": "class TreeNode {\n  constructor(val, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n// DFS Traversals (recursive)\nfunction preorder(root, result = []) {\n  if (!root) return result;\n  result.push(root.val);       // Root FIRST\n  preorder(root.left, result);\n  preorder(root.right, result);\n  return result;\n}\n\nfunction inorder(root, result = []) {\n  if (!root) return result;\n  inorder(root.left, result);\n  result.push(root.val);       // Root MIDDLE (sorted for BST!)\n  inorder(root.right, result);\n  return result;\n}\n\nfunction postorder(root, result = []) {\n  if (!root) return result;\n  postorder(root.left, result);\n  postorder(root.right, result);\n  result.push(root.val);       // Root LAST\n  return result;\n}\n\n// BFS / Level Order\nfunction levelOrder(root) {\n  if (!root) return [];\n  const result = [], queue = [root];\n  \n  while (queue.length) {\n    const level = [];\n    const size = queue.length;\n    \n    for (let i = 0; i < size; i++) {\n      const node = queue.shift();\n      level.push(node.val);\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    result.push(level);\n  }\n  return result;\n}",
              "notes": "Preorder: root-left-right. Inorder: left-root-right (BST gives sorted). Postorder: left-right-root."
            },
            "python": {
              "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef preorder(root, result=None):\n    if result is None: result = []\n    if not root: return result\n    result.append(root.val)       # Root FIRST\n    preorder(root.left, result)\n    preorder(root.right, result)\n    return result\n\ndef inorder(root, result=None):\n    if result is None: result = []\n    if not root: return result\n    inorder(root.left, result)\n    result.append(root.val)       # Root MIDDLE\n    inorder(root.right, result)\n    return result\n\ndef postorder(root, result=None):\n    if result is None: result = []\n    if not root: return result\n    postorder(root.left, result)\n    postorder(root.right, result)\n    result.append(root.val)       # Root LAST\n    return result\n\ndef level_order(root):\n    from collections import deque\n    if not root: return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            level.append(node.val)\n            if node.left: queue.append(node.left)\n            if node.right: queue.append(node.right)\n        result.append(level)\n    return result",
              "notes": "Use None default with check to avoid mutable default argument bug."
            }
          },
          {
            "name": "Max Depth of Binary Tree",
            "description": "Classic recursive tree problem",
            "javascript": {
              "code": "function maxDepth(root) {\n  // Base case: empty tree has depth 0\n  if (!root) return 0;\n  \n  // Recursive case: 1 + max of children depths\n  const leftDepth = maxDepth(root.left);\n  const rightDepth = maxDepth(root.right);\n  \n  return 1 + Math.max(leftDepth, rightDepth);\n}\n\n// Why this works:\n// - Empty tree: 0 levels\n// - Single node: 1 + max(0, 0) = 1\n// - Tree: 1 (this level) + depth of deeper subtree",
              "notes": "Pattern: solve for children, combine results, add contribution of current node."
            },
            "python": {
              "code": "def max_depth(root):\n    # Base case\n    if not root:\n        return 0\n    \n    # Recursive case\n    left_depth = max_depth(root.left)\n    right_depth = max_depth(root.right)\n    \n    return 1 + max(left_depth, right_depth)",
              "notes": "Same pattern. This is the essence of tree recursion."
            }
          },
          {
            "name": "Validate BST",
            "description": "Check if tree satisfies BST property",
            "javascript": {
              "code": "function isValidBST(root) {\n  return validate(root, -Infinity, Infinity);\n}\n\nfunction validate(node, min, max) {\n  if (!node) return true;\n  \n  // Node must be within valid range\n  if (node.val <= min || node.val >= max) {\n    return false;\n  }\n  \n  // Left subtree: all values must be < node.val\n  // Right subtree: all values must be > node.val\n  return validate(node.left, min, node.val) &&\n         validate(node.right, node.val, max);\n}\n\n// Alternative: Inorder traversal should be strictly increasing\nfunction isValidBST_Inorder(root) {\n  let prev = -Infinity;\n  \n  function inorder(node) {\n    if (!node) return true;\n    if (!inorder(node.left)) return false;\n    if (node.val <= prev) return false;\n    prev = node.val;\n    return inorder(node.right);\n  }\n  \n  return inorder(root);\n}",
              "notes": "Key insight: pass valid range down. Common mistake: only checking immediate children."
            },
            "python": {
              "code": "def is_valid_bst(root):\n    def validate(node, min_val, max_val):\n        if not node:\n            return True\n        \n        if node.val <= min_val or node.val >= max_val:\n            return False\n        \n        return (validate(node.left, min_val, node.val) and\n                validate(node.right, node.val, max_val))\n    \n    return validate(root, float('-inf'), float('inf'))\n\n# Inorder approach\ndef is_valid_bst_inorder(root):\n    prev = [float('-inf')]  # Use list for mutable closure\n    \n    def inorder(node):\n        if not node:\n            return True\n        if not inorder(node.left):\n            return False\n        if node.val <= prev[0]:\n            return False\n        prev[0] = node.val\n        return inorder(node.right)\n    \n    return inorder(root)",
              "notes": "Use list for prev to create mutable closure in Python."
            }
          }
        ],
        "visualTrace": {
          "title": "Inorder Traversal on BST [4,2,6,1,3,5,7]",
          "input": {
            "tree": "     4\n    / \\\n   2   6\n  / \\ / \\\n 1  3 5  7"
          },
          "steps": [
            {
              "call": "inorder(4)",
              "action": "Go left first",
              "stack": "[4]"
            },
            {
              "call": "inorder(2)",
              "action": "Go left",
              "stack": "[4,2]"
            },
            {
              "call": "inorder(1)",
              "action": "Go left = null",
              "stack": "[4,2,1]"
            },
            {
              "call": "visit 1",
              "action": "Add 1, right = null",
              "result": "[1]"
            },
            {
              "call": "back to 2",
              "action": "Add 2, go right",
              "result": "[1,2]"
            },
            {
              "call": "inorder(3)",
              "action": "left=null, visit, right=null",
              "result": "[1,2,3]"
            },
            {
              "call": "back to 4",
              "action": "Add 4, go right",
              "result": "[1,2,3,4]"
            },
            {
              "call": "inorder(6)",
              "action": "Go left",
              "result": "[1,2,3,4]"
            },
            {
              "call": "visit 5,6,7",
              "action": "Complete right subtree",
              "result": "[1,2,3,4,5,6,7]"
            }
          ],
          "output": "[1,2,3,4,5,6,7] - Sorted! BST inorder always gives sorted order."
        },
        "commonMistakes": [
          {
            "mistake": "Validate BST by only checking immediate children",
            "wrong": "if (node.left.val < node.val) // Only checks direct child!",
            "right": "Pass min/max range down the tree",
            "explanation": "Left child's right descendants must still be < root. Need global constraint."
          },
          {
            "mistake": "Forgetting base case in recursion",
            "wrong": "function height(node) { return 1 + max(height(left), height(right)); }",
            "right": "if (!node) return 0; // BASE CASE FIRST",
            "explanation": "Without base case, infinite recursion and stack overflow."
          },
          {
            "mistake": "Not handling null children",
            "wrong": "result.push(node.left.val); // Crashes if left is null!",
            "right": "if (node.left) result.push(node.left.val);",
            "explanation": "Always check if child exists before accessing."
          }
        ],
        "keyTakeaways": [
          "Tree = hierarchical, acyclic, one root, n-1 edges for n nodes",
          "BST property: left < parent < right. Inorder = sorted order.",
          "DFS traversals: Preorder (root first), Inorder (root middle), Postorder (root last)",
          "BFS/Level order: Use queue, process level by level",
          "Operations are O(h). Balanced tree: h = log n. Unbalanced: h = n.",
          "Tree recursion pattern: solve for children, combine, add current node's contribution"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "recursion",
              "label": "Recursion",
              "why": "Most tree operations are recursive"
            },
            {
              "id": "stack",
              "label": "Stack",
              "why": "DFS uses implicit/explicit stack"
            },
            {
              "id": "queue",
              "label": "Queue",
              "why": "BFS level-order uses queue"
            }
          ],
          "nextTopics": [
            {
              "id": "bst",
              "label": "Binary Search Tree",
              "why": "Tree with ordering property"
            },
            {
              "id": "heap",
              "label": "Heap",
              "why": "Complete binary tree with heap property"
            },
            {
              "id": "avl",
              "label": "Self-Balancing Trees",
              "why": "Maintain O(log n) height"
            },
            {
              "id": "trie",
              "label": "Trie",
              "why": "Tree for string/prefix operations"
            }
          ]
        },
        "patternChain": {
          "description": "Tree is central to many DS/Algo patterns",
          "buildsOn": [
            {
              "id": "recursion",
              "relationship": "Tree structure maps perfectly to recursion",
              "whatToKnow": "Base case + recursive case on children"
            },
            {
              "id": "ll",
              "relationship": "Tree is generalization of linked list",
              "whatToKnow": "Single child = linked list shape"
            }
          ],
          "enables": [
            {
              "id": "bfs",
              "relationship": "Level-order traversal",
              "patternName": "BFS on Tree",
              "interviewFrequency": "Very High"
            },
            {
              "id": "dfs",
              "relationship": "Pre/In/Post order traversals",
              "patternName": "DFS on Tree",
              "interviewFrequency": "Very High"
            },
            {
              "id": "heap",
              "relationship": "Complete binary tree with ordering",
              "patternName": "Heap Operations",
              "interviewFrequency": "High"
            },
            {
              "id": "segment_tree",
              "relationship": "Tree for range queries",
              "patternName": "Range Queries",
              "interviewFrequency": "Medium"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    REC[Recursion] --> TREE[Tree]\n    LL[Linked List] --> TREE\n    TREE --> BST[BST]\n    TREE --> HEAP[Heap]\n    TREE --> TRIE[Trie]\n    TREE --> BFS[BFS]\n    TREE --> DFS[DFS]\n    \n    style TREE fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "bst",
      "label": "Binary Search Tree",
      "type": "ds-hierarchical",
      "description": "Ordered tree for searching.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Binary_search_tree"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/bst"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/binary-search-tree/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/binary-search-tree-data-structure/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "3-4 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft"
      ],
      "interviewFrequency": "high",
      "category": "Tree DS",
      "categoryIcon": "üå≥",
      "content": {
        "definition": {
          "simple": "A tree where left children are smaller and right children are larger than the parent.",
          "technical": "Binary tree with ordering invariant: left < node < right. Enables O(log n) search/insert/delete when balanced."
        },
        "keyTakeaways": [
          "Left < Parent < Right",
          "O(log n) operations when balanced",
          "O(n) worst case if unbalanced (linked list)",
          "In-order traversal gives sorted order"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "tree",
              "label": "Trees",
              "why": "BST is a binary tree"
            }
          ],
          "nextTopics": [
            {
              "id": "avl",
              "label": "AVL Trees",
              "why": "Self-balancing BST"
            }
          ]
        }
      }
    },
    {
      "id": "avl",
      "label": "Self-Balancing Tree (AVL/RB)",
      "type": "ds-hierarchical",
      "description": "Automatically balanced BST.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/AVL_tree"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/bst"
          },
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/data_structures/avl_tree.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/avl-tree-set-1-insertion/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "4-5 hours",
      "companies": [
        "Google"
      ],
      "interviewFrequency": "low",
      "category": "Tree DS",
      "categoryIcon": "üå≥",
      "content": {
        "definition": {
          "simple": "A BST that automatically rebalances itself to guarantee O(log n) operations.",
          "technical": "Height-balanced BST where |height(left) - height(right)| ‚â§ 1 for every node. Rebalances via rotations."
        },
        "keyTakeaways": [
          "Self-balancing BST",
          "Height difference ‚â§ 1",
          "Rotations restore balance",
          "Guaranteed O(log n) operations"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bst",
              "label": "BST",
              "why": "AVL is a balanced BST"
            }
          ],
          "nextTopics": [
            {
              "id": "red_black_tree",
              "label": "Red-Black Tree",
              "why": "Alternative balancing"
            }
          ]
        }
      }
    },
    {
      "id": "heap",
      "label": "Heap",
      "type": "ds-hierarchical",
      "description": "Priority-based tree structure.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Heap_(data_structure)"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/heap"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/heap-priority-queue/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/heap-data-structure/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "3-4 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft",
        "Uber"
      ],
      "interviewFrequency": "high",
      "category": "Tree DS",
      "categoryIcon": "üå≥",
      "interviewQuestions": [
        {
          "name": "Kth Largest Element in Array",
          "leetcode": "https://leetcode.com/problems/kth-largest-element-in-an-array/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Microsoft",
            "LinkedIn"
          ],
          "frequency": "Very High",
          "whyAsked": "Tests heap vs quickselect trade-offs",
          "approach": "Min-heap of size k: O(n log k). Or Quickselect: O(n) average, O(n¬≤) worst",
          "followUps": [
            {
              "question": "Stream of numbers?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Kth smallest?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Median of stream?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "Find Median from Data Stream",
          "leetcode": "https://leetcode.com/problems/find-median-from-data-stream/",
          "difficulty": "Hard",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Microsoft",
            "Apple"
          ],
          "frequency": "Very High",
          "whyAsked": "Two heaps technique - max-heap for left half, min-heap for right",
          "approach": "Max-heap (left) + Min-heap (right). Keep balanced. Median from tops. O(log n) insert",
          "followUps": [
            {
              "question": "Sliding window median?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Remove element support?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "teamblind"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Blind (Teamblind)",
              "url": "https://www.teamblind.com/",
              "note": "Crowdsourced interview experiences from FAANG employees"
            }
          ]
        },
        {
          "name": "Task Scheduler",
          "leetcode": "https://leetcode.com/problems/task-scheduler/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Microsoft"
          ],
          "frequency": "High",
          "whyAsked": "Greedy + max-heap for scheduling with cooldown",
          "approach": "Max-heap by frequency. Process most frequent first. Track cooldown. O(n log 26) = O(n)",
          "followUps": [
            {
              "question": "Return actual schedule order?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Multiple processors?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "teamblind"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Blind (Teamblind)",
              "url": "https://www.teamblind.com/",
              "note": "Crowdsourced interview experiences from FAANG employees"
            }
          ]
        },
        {
          "name": "K Closest Points to Origin",
          "leetcode": "https://leetcode.com/problems/k-closest-points-to-origin/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google"
          ],
          "frequency": "High",
          "whyAsked": "Heap for top-k problems with custom comparator",
          "approach": "Max-heap of size k by distance. Or Quickselect for O(n) average",
          "followUps": [
            {
              "question": "Streaming points?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "With obstacles?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Reorganize String",
          "leetcode": "https://leetcode.com/problems/reorganize-string/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta"
          ],
          "frequency": "Medium",
          "whyAsked": "Greedy with max-heap - place most frequent char first",
          "approach": "Max-heap by frequency. Place most frequent, then second most, alternate. O(n log 26)",
          "followUps": [
            {
              "question": "K distance apart?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Check if possible only?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "seanprashad"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Sean Prashad's Patterns",
              "url": "https://seanprashad.com/leetcode-patterns/",
              "note": "Pattern-based problem categorization"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based problem categorization"
        },
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with video explanations"
        }
      ],
      "content": {
        "definition": {
          "simple": "A heap is like a VIP line - always know who's next (highest/lowest priority). Add anyone anywhere, but the VIP always bubbles to front.",
          "technical": "A heap is a complete binary tree satisfying the heap property: for a max-heap, every parent ‚â• children; for a min-heap, every parent ‚â§ children. The root is always the max (or min). Insertion and extraction are O(log n)."
        },
        "howItWorks": {
          "explanation": "Think of a corporate ladder where the CEO (root) is always the highest paid. When a new employee joins, they start at bottom and 'bubble up' if they earn more than their boss. When CEO leaves, promote someone and let them 'bubble down' to right position.",
          "steps": [
            {
              "step": 1,
              "title": "Structure",
              "description": "Complete binary tree stored in array. Parent at i, children at 2i+1 and 2i+2.",
              "why": "Array storage is cache-friendly, no pointers needed."
            },
            {
              "step": 2,
              "title": "Insert (Push)",
              "description": "Add to end, bubble up by swapping with parent while violating heap property.",
              "why": "O(log n) - at most height swaps."
            },
            {
              "step": 3,
              "title": "Extract (Pop)",
              "description": "Remove root, move last element to root, bubble down by swapping with larger/smaller child.",
              "why": "O(log n) - at most height swaps."
            },
            {
              "step": 4,
              "title": "Peek",
              "description": "Return root without removing.",
              "why": "O(1) - just read index 0."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph TD\n    A[\"50\"] --> B[\"30\"]\n    A --> C[\"40\"]\n    B --> D[\"10\"]\n    B --> E[\"20\"]\n    C --> F[\"35\"]\n    C --> G[\"25\"]\n    \n    style A fill:#ee6c4d\n    \n    subgraph Array\n        ARR[\"[50, 30, 40, 10, 20, 35, 25]\"]\n    end",
            "caption": "Max-Heap: Parent ‚â• children. Root (50) is always max. Stored as array."
          }
        },
        "whenToUse": {
          "summary": "Use heap when you need fast access to min/max element. Perfect for Top K, scheduling, and graph algorithms.",
          "patterns": [
            {
              "pattern": "Top K Elements",
              "signal": "Find k largest/smallest from n elements",
              "example": "Top K frequent elements, K closest points",
              "withoutIt": "Sort O(n log n)",
              "withIt": "Heap O(n log k) - much better for small k"
            },
            {
              "pattern": "Priority-Based Processing",
              "signal": "Always process highest/lowest priority first",
              "example": "Dijkstra's algorithm, task scheduling",
              "withoutIt": "Scan for min each time O(n)",
              "withIt": "Extract min O(log n)"
            },
            {
              "pattern": "Merge K Sorted Lists",
              "signal": "Combine multiple sorted sources",
              "example": "Merge K sorted arrays/lists",
              "withoutIt": "Compare all K heads each step O(n*k)",
              "withIt": "Heap of K elements O(n log k)"
            },
            {
              "pattern": "Running Median",
              "signal": "Track median in stream of numbers",
              "example": "Find median from data stream",
              "withoutIt": "Sort each time O(n log n)",
              "withIt": "Two heaps (max + min) O(log n) per insert"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Heap only gives fast min/max access. Can't search or access by index efficiently.",
          "antiPatterns": [
            {
              "situation": "Need to Search by Value",
              "why": "Heap has no ordering for search - O(n)",
              "useInstead": "BST or HashMap",
              "example": "Check if element exists"
            },
            {
              "situation": "Need Sorted Order",
              "why": "Heap gives one element at a time",
              "useInstead": "Sort the array",
              "example": "Display all items sorted"
            },
            {
              "situation": "Need Both Min and Max",
              "why": "Heap only optimizes one end",
              "useInstead": "Min-Max Heap or Two Heaps",
              "example": "Track both extremes"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Hospital ER",
            "story": "Emergency room uses triage. Patients don't wait in FIFO order - the most critical case goes first. When a new patient arrives, nurse assesses severity. Critical patient 'bubbles up' to front of queue. When a patient is treated (removed), the next most critical automatically becomes first.",
            "connection": "That's a max-heap by priority. Dijkstra's algorithm uses min-heap - always process closest unvisited node first."
          },
          "keyInsight": "Heap is a PARTIAL ordering. We only care about the relationship between parent and children, not between siblings. This relaxed constraint allows O(log n) operations while still guaranteeing the min/max is at root.",
          "commonConfusion": [
            {
              "confusion": "Heap vs BST?",
              "clarification": "BST: left < parent < right (total ordering). Heap: parent > children (partial ordering). Heap is more relaxed, so it's faster to maintain."
            },
            {
              "confusion": "Why array, not tree nodes?",
              "clarification": "Complete binary tree maps perfectly to array. Parent at i ‚Üí children at 2i+1, 2i+2. No pointers = less memory, better cache."
            },
            {
              "confusion": "Why O(log n) for insert?",
              "clarification": "Bubble up at most height levels. Complete tree with n nodes has height log n."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Insert (push)",
                "average": "O(log n)",
                "worst": "O(log n)",
                "note": "Bubble up tree height"
              },
              {
                "operation": "Extract (pop)",
                "average": "O(log n)",
                "worst": "O(log n)",
                "note": "Bubble down tree height"
              },
              {
                "operation": "Peek",
                "average": "O(1)",
                "worst": "O(1)",
                "note": "Just read root"
              },
              {
                "operation": "Heapify (build)",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Not O(n log n)! Clever math."
              },
              {
                "operation": "Search",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "No ordering for search"
              }
            ],
            "explanation": "Heapify is O(n) because most nodes are leaves (do no work) and only few are near root."
          },
          "space": {
            "complexity": "O(n)",
            "explanation": "Store n elements in array"
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Heap is stored as contiguous array. Tree structure is implicit through index math.",
            "keyPoints": [
              "Parent of i: Math.floor((i-1)/2)",
              "Left child of i: 2*i + 1",
              "Right child of i: 2*i + 2",
              "No wasted space - complete tree fills array left-to-right",
              "Array storage = cache-friendly, no pointer overhead"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "No built-in heap. Implement yourself or use a library.",
              "gotchas": [
                "No native PriorityQueue - must implement",
                "For simple cases, sort after each insert (fine for small n)",
                "Libraries: 'heap-js', 'fastpriorityqueue'"
              ]
            },
            "python": {
              "implementation": "heapq module - MIN-HEAP only. Negate values for max-heap.",
              "gotchas": [
                "heapq operates on list in-place",
                "MIN-heap only: for max-heap, push -value, pop and negate",
                "heapq.heappush(), heapq.heappop(), heapq.heapify()"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Heapify (build heap) is O(n), not O(n log n)",
            "proof": {
              "step1": {
                "action": "n/2 nodes are leaves - they do 0 swaps",
                "cost": "0"
              },
              "step2": {
                "action": "n/4 nodes at height 1 - do at most 1 swap each",
                "cost": "n/4"
              },
              "step3": {
                "action": "n/8 nodes at height 2 - do at most 2 swaps",
                "cost": "2 * n/8"
              },
              "step4": {
                "action": "Total: Œ£(h * n/2^(h+1)) = n * Œ£(h/2^(h+1)) < 2n",
                "cost": "O(n)"
              }
            },
            "totalCost": "O(n) - geometric series converges"
          }
        },
        "codeTemplates": [
          {
            "name": "MinHeap Implementation",
            "description": "Custom heap class with all operations",
            "javascript": {
              "code": "class MinHeap {\n  constructor() {\n    this.heap = [];\n  }\n  \n  parent(i) { return Math.floor((i - 1) / 2); }\n  leftChild(i) { return 2 * i + 1; }\n  rightChild(i) { return 2 * i + 2; }\n  \n  swap(i, j) {\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\n  }\n  \n  push(val) {\n    this.heap.push(val);\n    this.bubbleUp(this.heap.length - 1);\n  }\n  \n  bubbleUp(i) {\n    while (i > 0 && this.heap[this.parent(i)] > this.heap[i]) {\n      this.swap(i, this.parent(i));\n      i = this.parent(i);\n    }\n  }\n  \n  pop() {\n    if (this.heap.length === 0) return undefined;\n    if (this.heap.length === 1) return this.heap.pop();\n    \n    const min = this.heap[0];\n    this.heap[0] = this.heap.pop();\n    this.bubbleDown(0);\n    return min;\n  }\n  \n  bubbleDown(i) {\n    const n = this.heap.length;\n    while (true) {\n      let smallest = i;\n      const left = this.leftChild(i);\n      const right = this.rightChild(i);\n      \n      if (left < n && this.heap[left] < this.heap[smallest]) {\n        smallest = left;\n      }\n      if (right < n && this.heap[right] < this.heap[smallest]) {\n        smallest = right;\n      }\n      \n      if (smallest === i) break;\n      this.swap(i, smallest);\n      i = smallest;\n    }\n  }\n  \n  peek() { return this.heap[0]; }\n  size() { return this.heap.length; }\n}",
              "notes": "bubbleUp for insert, bubbleDown for extract. Parent/child index formulas are key."
            },
            "python": {
              "code": "import heapq\n\n# Python heapq - MIN HEAP by default\nnums = [3, 1, 4, 1, 5, 9, 2, 6]\n\n# Build heap in-place - O(n)\nheapq.heapify(nums)  # [1, 1, 2, 3, 5, 9, 4, 6]\n\n# Push - O(log n)\nheapq.heappush(nums, 0)\n\n# Pop minimum - O(log n)\nsmallest = heapq.heappop(nums)  # 0\n\n# Peek minimum - O(1)\npeek = nums[0]\n\n# For MAX-HEAP: negate values\nmax_heap = []\nheapq.heappush(max_heap, -5)\nheapq.heappush(max_heap, -3)\nheapq.heappush(max_heap, -8)\nlargest = -heapq.heappop(max_heap)  # 8\n\n# Push and pop in one operation\nreplaced = heapq.heappushpop(nums, 7)  # Push 7, pop smallest\n\n# N largest/smallest\nheapq.nlargest(3, nums)   # Top 3 largest\nheapq.nsmallest(3, nums)  # Top 3 smallest",
              "notes": "heapq is min-heap only. Negate for max-heap. heapify is O(n)."
            }
          },
          {
            "name": "Top K Frequent Elements",
            "description": "Classic heap problem - LeetCode 347",
            "javascript": {
              "code": "function topKFrequent(nums, k) {\n  // Step 1: Count frequencies\n  const freq = new Map();\n  for (const num of nums) {\n    freq.set(num, (freq.get(num) || 0) + 1);\n  }\n  \n  // Step 2: Use min-heap of size k\n  // (We could use max-heap and push all, but min-heap of size k is O(n log k))\n  const heap = new MinHeap(); // Custom heap storing [freq, num]\n  \n  for (const [num, count] of freq) {\n    heap.push([count, num]);\n    if (heap.size() > k) {\n      heap.pop(); // Remove smallest frequency\n    }\n  }\n  \n  // Step 3: Extract results\n  const result = [];\n  while (heap.size() > 0) {\n    result.push(heap.pop()[1]);\n  }\n  return result;\n}\n\n// Alternative: Bucket sort O(n) - even better!\nfunction topKFrequentBucket(nums, k) {\n  const freq = new Map();\n  for (const num of nums) {\n    freq.set(num, (freq.get(num) || 0) + 1);\n  }\n  \n  // Buckets: index = frequency, value = list of nums with that freq\n  const buckets = Array(nums.length + 1).fill(null).map(() => []);\n  for (const [num, count] of freq) {\n    buckets[count].push(num);\n  }\n  \n  // Collect from highest frequency buckets\n  const result = [];\n  for (let i = buckets.length - 1; i >= 0 && result.length < k; i--) {\n    result.push(...buckets[i]);\n  }\n  return result.slice(0, k);\n}",
              "notes": "Min-heap of size k: O(n log k). Bucket sort: O(n). Both work!"
            },
            "python": {
              "code": "import heapq\nfrom collections import Counter\n\ndef top_k_frequent(nums, k):\n    # Count frequencies\n    freq = Counter(nums)\n    \n    # Use heap - nlargest handles it\n    return heapq.nlargest(k, freq.keys(), key=freq.get)\n\n# Manual heap approach\ndef top_k_frequent_heap(nums, k):\n    freq = Counter(nums)\n    \n    # Min-heap of size k (negate for max behavior)\n    heap = []\n    for num, count in freq.items():\n        heapq.heappush(heap, (count, num))\n        if len(heap) > k:\n            heapq.heappop(heap)\n    \n    return [num for count, num in heap]\n\n# Bucket sort O(n)\ndef top_k_frequent_bucket(nums, k):\n    freq = Counter(nums)\n    buckets = [[] for _ in range(len(nums) + 1)]\n    \n    for num, count in freq.items():\n        buckets[count].append(num)\n    \n    result = []\n    for i in range(len(buckets) - 1, -1, -1):\n        result.extend(buckets[i])\n        if len(result) >= k:\n            return result[:k]\n    return result",
              "notes": "heapq.nlargest is clean. Manual heap shows the pattern."
            }
          },
          {
            "name": "Merge K Sorted Lists",
            "description": "Use heap to efficiently merge - LeetCode 23",
            "javascript": {
              "code": "function mergeKLists(lists) {\n  // Min-heap stores [value, listIndex, nodeIndex]\n  const heap = new MinHeap();\n  \n  // Initialize with first node from each list\n  for (let i = 0; i < lists.length; i++) {\n    if (lists[i]) {\n      heap.push([lists[i].val, i, lists[i]]);\n    }\n  }\n  \n  const dummy = new ListNode(0);\n  let current = dummy;\n  \n  while (heap.size() > 0) {\n    const [val, listIdx, node] = heap.pop();\n    current.next = node;\n    current = current.next;\n    \n    // If this list has more nodes, add next one\n    if (node.next) {\n      heap.push([node.next.val, listIdx, node.next]);\n    }\n  }\n  \n  return dummy.next;\n}",
              "notes": "Heap always has at most k nodes (one per list). O(n log k) total."
            },
            "python": {
              "code": "import heapq\n\ndef merge_k_lists(lists):\n    heap = []\n    \n    # Add first node from each list\n    for i, lst in enumerate(lists):\n        if lst:\n            # (value, list_index, node) - index breaks ties\n            heapq.heappush(heap, (lst.val, i, lst))\n    \n    dummy = ListNode(0)\n    current = dummy\n    \n    while heap:\n        val, idx, node = heapq.heappop(heap)\n        current.next = node\n        current = current.next\n        \n        if node.next:\n            heapq.heappush(heap, (node.next.val, idx, node.next))\n    \n    return dummy.next",
              "notes": "Include list index in tuple to break ties (Python compares tuples element-wise)."
            }
          }
        ],
        "visualTrace": {
          "title": "Insert 15 into Max-Heap [50, 30, 40, 10, 20]",
          "input": {
            "heap": "[50, 30, 40, 10, 20]",
            "insert": 15
          },
          "steps": [
            {
              "heap": "[50, 30, 40, 10, 20, 15]",
              "action": "Add 15 at end (index 5)",
              "compare": "Parent of 5 is index 2 (value 40)"
            },
            {
              "heap": "[50, 30, 40, 10, 20, 15]",
              "action": "15 < 40, heap property satisfied",
              "compare": "No swap needed"
            },
            {
              "heap": "[50, 30, 40, 10, 20, 15]",
              "action": "Done!",
              "result": "15 stays at index 5"
            }
          ],
          "output": "[50, 30, 40, 10, 20, 15]"
        },
        "commonMistakes": [
          {
            "mistake": "Using heapq for max-heap without negation",
            "wrong": "heapq.heappush(heap, 5) # This is min-heap!",
            "right": "heapq.heappush(heap, -5) # Negate for max-heap",
            "explanation": "Python heapq is min-heap only. Negate values for max-heap behavior."
          },
          {
            "mistake": "Forgetting heap is partial ordering",
            "wrong": "Expecting heap[1] < heap[2] // Not guaranteed!",
            "right": "Only parent > children is guaranteed",
            "explanation": "Siblings have no ordering relationship. Only root is guaranteed min/max."
          },
          {
            "mistake": "Using sort instead of heap for top-k",
            "wrong": "arr.sort(); return arr.slice(0, k); // O(n log n)",
            "right": "Use heap of size k // O(n log k)",
            "explanation": "For small k, heap is much faster than full sort."
          }
        ],
        "keyTakeaways": [
          "Heap = complete binary tree with heap property (parent ‚â• or ‚â§ children)",
          "Root is always min (min-heap) or max (max-heap). Peek is O(1).",
          "Insert/Extract are O(log n) via bubble up/down",
          "Stored as array: parent at i ‚Üí children at 2i+1, 2i+2",
          "Python heapq is MIN-heap only. Negate values for max-heap.",
          "Use cases: Top K, Dijkstra, merge K sorted, running median"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "tree",
              "label": "Binary Tree",
              "why": "Heap is a complete binary tree"
            },
            {
              "id": "array",
              "label": "Array",
              "why": "Heap stored in array"
            }
          ],
          "nextTopics": [
            {
              "id": "dijkstra",
              "label": "Dijkstra's Algorithm",
              "why": "Uses min-heap for efficiency"
            },
            {
              "id": "top_k",
              "label": "Top K Pattern",
              "why": "Classic heap application"
            },
            {
              "id": "median_finder",
              "label": "Running Median",
              "why": "Two heaps pattern"
            }
          ]
        },
        "patternChain": {
          "description": "Heap enables efficient priority-based algorithms",
          "buildsOn": [
            {
              "id": "tree",
              "relationship": "Complete binary tree structure",
              "whatToKnow": "Parent-child relationships"
            },
            {
              "id": "array",
              "relationship": "Stored as array with index math",
              "whatToKnow": "Parent/child index formulas"
            }
          ],
          "enables": [
            {
              "id": "dijkstra",
              "relationship": "Extract closest unvisited node",
              "patternName": "Shortest Path",
              "interviewFrequency": "High"
            },
            {
              "id": "top_k",
              "relationship": "Maintain k largest/smallest",
              "patternName": "Top K",
              "interviewFrequency": "Very High"
            },
            {
              "id": "merge_k",
              "relationship": "Efficiently merge sorted sources",
              "patternName": "K-Way Merge",
              "interviewFrequency": "High"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    ARR[Array] --> HEAP[Heap]\n    TREE[Tree] --> HEAP\n    HEAP --> DIJ[Dijkstra]\n    HEAP --> TOPK[Top K]\n    HEAP --> MERGE[K-Way Merge]\n    HEAP --> MED[Running Median]\n    \n    style HEAP fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "graph",
      "label": "Graph",
      "type": "ds-complex",
      "description": "Nodes (vertices) and edges.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Graph_(abstract_data_type)"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/graphds"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/graph/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "3-4 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft",
        "LinkedIn"
      ],
      "interviewFrequency": "high",
      "category": "Complex DS",
      "categoryIcon": "üï∏Ô∏è",
      "interviewQuestions": [
        {
          "name": "Number of Islands",
          "leetcode": "https://leetcode.com/problems/number-of-islands/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Microsoft",
            "Bloomberg"
          ],
          "frequency": "Very High",
          "whyAsked": "Classic grid DFS/BFS. Counting connected components",
          "approach": "DFS/BFS from each '1', mark visited. Count number of times we start new search. O(m*n)",
          "followUps": [
            {
              "question": "Max area of island?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Number of distinct islands?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Surrounded regions?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "Clone Graph",
          "leetcode": "https://leetcode.com/problems/clone-graph/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Microsoft"
          ],
          "frequency": "High",
          "whyAsked": "Tests deep copy with cycle handling using hash map",
          "approach": "BFS/DFS with hash map {original -> clone}. Clone neighbors recursively. O(V + E)",
          "followUps": [
            {
              "question": "Clone linked list with random pointer?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Clone n-ary tree?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Course Schedule",
          "leetcode": "https://leetcode.com/problems/course-schedule/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Meta",
            "Google",
            "Microsoft",
            "Apple"
          ],
          "frequency": "Very High",
          "whyAsked": "Cycle detection in directed graph (topological sort feasibility)",
          "approach": "Kahn's BFS (indegree) or DFS with 3 colors (white/gray/black). O(V + E)",
          "followUps": [
            {
              "question": "Return one valid order?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "All possible orders?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Minimum semesters?",
              "answer": "Topo sort by levels. Count levels = minimum semesters. Process all 0-indegree nodes together."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Pacific Atlantic Water Flow",
          "leetcode": "https://leetcode.com/problems/pacific-atlantic-water-flow/",
          "difficulty": "Medium",
          "companies": [
            "Google",
            "Amazon",
            "Meta"
          ],
          "frequency": "Medium",
          "whyAsked": "Reverse thinking - BFS/DFS from oceans inward",
          "approach": "BFS/DFS from Pacific and Atlantic edges separately. Intersection is answer. O(m*n)",
          "followUps": [
            {
              "question": "Optimize memory?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Word Ladder",
          "leetcode": "https://leetcode.com/problems/word-ladder/",
          "difficulty": "Hard",
          "companies": [
            "Amazon",
            "Meta",
            "Google",
            "Microsoft"
          ],
          "frequency": "High",
          "whyAsked": "BFS for shortest path in implicit graph (words as nodes)",
          "approach": "BFS from start word. Generate neighbors by changing one char. Use word set for O(1) lookup",
          "followUps": [
            {
              "question": "Return all shortest paths?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Bidirectional BFS?",
              "answer": "Search from both source and target. Meet in middle. Much faster for large graphs."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Alien Dictionary",
          "leetcode": "https://leetcode.com/problems/alien-dictionary/",
          "difficulty": "Hard",
          "companies": [
            "Meta",
            "Google",
            "Amazon",
            "Airbnb"
          ],
          "frequency": "High",
          "whyAsked": "Topological sort from implicit ordering constraints",
          "approach": "Build graph from adjacent word pairs. Topological sort for order. Handle invalid input",
          "followUps": [
            {
              "question": "Multiple valid orderings?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Verify if order is valid?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "teamblind"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Blind (Teamblind)",
              "url": "https://www.teamblind.com/",
              "note": "Crowdsourced interview experiences from FAANG employees"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based problem categorization"
        },
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with video explanations"
        }
      ],
      "content": {
        "definition": {
          "simple": "A graph is like a social network - people (nodes) connected by friendships (edges). Unlike trees, there's no hierarchy, and cycles are allowed.",
          "technical": "A graph G = (V, E) consists of vertices (nodes) V and edges E connecting pairs of vertices. Edges can be directed or undirected, weighted or unweighted. Unlike trees, graphs can have cycles and vertices can have any number of connections."
        },
        "howItWorks": {
          "explanation": "Think of a road map. Cities are nodes, roads are edges. Some roads are one-way (directed), some are two-way (undirected). Some roads have tolls/distances (weighted edges). You can travel in cycles - leave home, visit places, return home.",
          "steps": [
            {
              "step": 1,
              "title": "Representation",
              "description": "Store as adjacency list (map of node ‚Üí neighbors) or adjacency matrix (2D array).",
              "why": "List is space-efficient for sparse graphs; matrix is faster for dense."
            },
            {
              "step": 2,
              "title": "Traversal",
              "description": "BFS (explore level by level) or DFS (go deep, backtrack).",
              "why": "BFS for shortest path (unweighted), DFS for cycle detection, connected components."
            },
            {
              "step": 3,
              "title": "Track Visited",
              "description": "Use Set to avoid revisiting nodes (unlike trees, graphs have cycles).",
              "why": "Without visited check, infinite loop in cyclic graphs."
            },
            {
              "step": 4,
              "title": "Path Finding",
              "description": "Dijkstra (weighted), BFS (unweighted), Bellman-Ford (negative weights).",
              "why": "Different algorithms for different edge weight scenarios."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph LR\n    A((A)) --- B((B))\n    A --- C((C))\n    B --- C\n    B --- D((D))\n    C --- D\n    D --- E((E))\n    \n    style A fill:#ee6c4d\n    style E fill:#98c1d9",
            "caption": "Undirected graph. A to E has multiple paths. Contains cycles (A-B-C-A)."
          }
        },
        "whenToUse": {
          "summary": "Use graphs when relationships are complex - many-to-many, cycles, or non-hierarchical connections.",
          "patterns": [
            {
              "pattern": "Shortest Path",
              "signal": "Find minimum distance/cost between two points",
              "example": "GPS navigation, network routing",
              "withoutIt": "Try all paths exponentially",
              "withIt": "BFS (unweighted) or Dijkstra (weighted)"
            },
            {
              "pattern": "Cycle Detection",
              "signal": "Check if path returns to starting point",
              "example": "Deadlock detection, circular dependencies",
              "withoutIt": "Complex tracking of visited states",
              "withIt": "DFS with in-progress tracking"
            },
            {
              "pattern": "Topological Sort",
              "signal": "Order items by dependencies",
              "example": "Build systems, course prerequisites",
              "withoutIt": "Manual dependency resolution",
              "withIt": "DFS postorder or Kahn's algorithm"
            },
            {
              "pattern": "Connected Components",
              "signal": "Find groups of connected nodes",
              "example": "Social network clusters, image segmentation",
              "withoutIt": "Complex grouping logic",
              "withIt": "DFS/BFS from each unvisited node"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Graphs add complexity. Use simpler structures when relationships are hierarchical or sequential.",
          "antiPatterns": [
            {
              "situation": "Strictly Hierarchical Data",
              "why": "Graph overkill, harder to traverse",
              "useInstead": "Tree",
              "example": "File system, org chart"
            },
            {
              "situation": "Sequential Data",
              "why": "No complex relationships",
              "useInstead": "Array or Linked List",
              "example": "Time series, logs"
            },
            {
              "situation": "Key-Value Lookups",
              "why": "Graph doesn't help with direct access",
              "useInstead": "HashMap",
              "example": "Cache, config store"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Airline Route Map",
            "story": "Think of an airline route map. Airports are nodes, flights are edges. Some routes are one-way (you can fly A‚ÜíB but not B‚ÜíA). Edges have weights (flight duration, price). BFS finds fewest layovers; Dijkstra finds cheapest/fastest route considering weights.",
            "connection": "When you ask 'how do I get from here to there?', you're doing graph traversal. When you ask 'what's the shortest/cheapest way?', you're doing shortest path."
          },
          "keyInsight": "Graphs generalize trees and lists. A tree is a connected graph with no cycles. A linked list is a graph where each node has at most one outgoing edge. When relationships get complex, you need the full power of graphs.",
          "commonConfusion": [
            {
              "confusion": "Adjacency list vs matrix?",
              "clarification": "List: O(V+E) space, O(degree) neighbor lookup. Matrix: O(V¬≤) space, O(1) edge check. Use list for sparse, matrix for dense."
            },
            {
              "confusion": "BFS vs DFS?",
              "clarification": "BFS: level by level, finds shortest path (unweighted), uses queue. DFS: go deep first, uses stack/recursion, good for cycles, paths, connected components."
            },
            {
              "confusion": "Why track visited?",
              "clarification": "Unlike trees, graphs can have cycles. Without visited set, you'll loop forever."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "BFS/DFS",
                "average": "O(V+E)",
                "worst": "O(V+E)",
                "note": "Visit each vertex and edge once"
              },
              {
                "operation": "Dijkstra (binary heap)",
                "average": "O((V+E) log V)",
                "worst": "O((V+E) log V)",
                "note": "Each edge relaxation costs log V"
              },
              {
                "operation": "Add vertex",
                "average": "O(1)",
                "worst": "O(1)",
                "note": "Add to adjacency list"
              },
              {
                "operation": "Add edge",
                "average": "O(1)",
                "worst": "O(1)",
                "note": "Add to neighbor list"
              },
              {
                "operation": "Check edge exists",
                "average": "O(degree)",
                "worst": "O(V)",
                "note": "Scan neighbor list. O(1) with matrix"
              }
            ],
            "explanation": "V = vertices, E = edges. Sparse graph: E ‚âà V. Dense graph: E ‚âà V¬≤."
          },
          "space": {
            "complexity": "Adjacency list: O(V+E). Matrix: O(V¬≤)",
            "explanation": "List stores each edge once (twice for undirected). Matrix stores V√óV cells."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Adjacency list is usually Map<Node, List<Node>>. Each node maps to its neighbors.",
            "keyPoints": [
              "Adjacency list: HashMap or array of arrays",
              "Each edge stored once (directed) or twice (undirected)",
              "Node can be anything - number, string, object",
              "For weighted graphs, store [neighbor, weight] pairs"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Use Map<Node, Node[]> or object literal for adjacency list.",
              "gotchas": [
                "No built-in Graph class - always implement yourself",
                "Object keys are strings - use Map for non-string nodes",
                "Remember undirected = add edge both ways"
              ]
            },
            "python": {
              "implementation": "defaultdict(list) is perfect for adjacency lists.",
              "gotchas": [
                "collections.defaultdict(list) - auto-creates empty list",
                "For weighted: defaultdict(list) with (neighbor, weight) tuples",
                "deque for BFS, recursion or explicit stack for DFS"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "BFS finds shortest path in unweighted graph",
            "proof": {
              "step1": {
                "action": "BFS visits nodes in order of distance from source",
                "cost": "By queue property"
              },
              "step2": {
                "action": "When we first reach a node, we've taken minimum edges",
                "cost": "Earlier distances already processed"
              },
              "step3": {
                "action": "Each node visited exactly once",
                "cost": "Visited set prevents revisits"
              }
            },
            "totalCost": "O(V+E) - each vertex and edge processed once"
          }
        },
        "codeTemplates": [
          {
            "name": "Graph Representation + BFS/DFS",
            "description": "Build graph and traverse",
            "javascript": {
              "code": "// Build adjacency list from edge list\nfunction buildGraph(edges, directed = false) {\n  const graph = new Map();\n  \n  for (const [a, b] of edges) {\n    if (!graph.has(a)) graph.set(a, []);\n    if (!graph.has(b)) graph.set(b, []);\n    graph.get(a).push(b);\n    if (!directed) graph.get(b).push(a);\n  }\n  \n  return graph;\n}\n\n// BFS - shortest path in unweighted graph\nfunction bfs(graph, start, target) {\n  const queue = [[start, 0]];  // [node, distance]\n  const visited = new Set([start]);\n  \n  while (queue.length > 0) {\n    const [node, dist] = queue.shift();\n    \n    if (node === target) return dist;\n    \n    for (const neighbor of graph.get(node) || []) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push([neighbor, dist + 1]);\n      }\n    }\n  }\n  \n  return -1;  // Not reachable\n}\n\n// DFS - explore all paths, detect cycles\nfunction dfs(graph, node, visited = new Set()) {\n  if (visited.has(node)) return;\n  visited.add(node);\n  \n  console.log('Visiting:', node);\n  \n  for (const neighbor of graph.get(node) || []) {\n    dfs(graph, neighbor, visited);\n  }\n}\n\n// DFS iterative (explicit stack)\nfunction dfsIterative(graph, start) {\n  const stack = [start];\n  const visited = new Set();\n  \n  while (stack.length > 0) {\n    const node = stack.pop();\n    if (visited.has(node)) continue;\n    visited.add(node);\n    \n    console.log('Visiting:', node);\n    \n    for (const neighbor of graph.get(node) || []) {\n      if (!visited.has(neighbor)) {\n        stack.push(neighbor);\n      }\n    }\n  }\n}",
              "notes": "BFS uses queue + visited. DFS uses stack (or recursion) + visited."
            },
            "python": {
              "code": "from collections import defaultdict, deque\n\ndef build_graph(edges, directed=False):\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        if not directed:\n            graph[b].append(a)\n    return graph\n\ndef bfs(graph, start, target):\n    queue = deque([(start, 0)])  # (node, distance)\n    visited = {start}\n    \n    while queue:\n        node, dist = queue.popleft()\n        \n        if node == target:\n            return dist\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, dist + 1))\n    \n    return -1\n\ndef dfs(graph, node, visited=None):\n    if visited is None:\n        visited = set()\n    if node in visited:\n        return\n    visited.add(node)\n    \n    print(f'Visiting: {node}')\n    \n    for neighbor in graph[node]:\n        dfs(graph, neighbor, visited)\n\ndef dfs_iterative(graph, start):\n    stack = [start]\n    visited = set()\n    \n    while stack:\n        node = stack.pop()\n        if node in visited:\n            continue\n        visited.add(node)\n        \n        print(f'Visiting: {node}')\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)",
              "notes": "defaultdict(list) avoids KeyError. deque for O(1) popleft in BFS."
            }
          },
          {
            "name": "Cycle Detection",
            "description": "Detect cycle in directed graph",
            "javascript": {
              "code": "// Cycle detection in directed graph\n// Uses 3 colors: white (unvisited), gray (in progress), black (done)\nfunction hasCycle(graph, numNodes) {\n  const WHITE = 0, GRAY = 1, BLACK = 2;\n  const color = new Array(numNodes).fill(WHITE);\n  \n  function dfs(node) {\n    color[node] = GRAY;  // Start processing\n    \n    for (const neighbor of graph.get(node) || []) {\n      if (color[neighbor] === GRAY) {\n        return true;  // Back edge = cycle!\n      }\n      if (color[neighbor] === WHITE && dfs(neighbor)) {\n        return true;\n      }\n    }\n    \n    color[node] = BLACK;  // Done processing\n    return false;\n  }\n  \n  // Check all components\n  for (let i = 0; i < numNodes; i++) {\n    if (color[i] === WHITE && dfs(i)) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n\n// For undirected graph: track parent to avoid false positive\nfunction hasCycleUndirected(graph, numNodes) {\n  const visited = new Set();\n  \n  function dfs(node, parent) {\n    visited.add(node);\n    \n    for (const neighbor of graph.get(node) || []) {\n      if (!visited.has(neighbor)) {\n        if (dfs(neighbor, node)) return true;\n      } else if (neighbor !== parent) {\n        return true;  // Visited but not parent = cycle\n      }\n    }\n    return false;\n  }\n  \n  for (let i = 0; i < numNodes; i++) {\n    if (!visited.has(i) && dfs(i, -1)) {\n      return true;\n    }\n  }\n  return false;\n}",
              "notes": "Directed: use colors (gray = in current path). Undirected: track parent."
            },
            "python": {
              "code": "def has_cycle_directed(graph, num_nodes):\n    WHITE, GRAY, BLACK = 0, 1, 2\n    color = [WHITE] * num_nodes\n    \n    def dfs(node):\n        color[node] = GRAY\n        \n        for neighbor in graph[node]:\n            if color[neighbor] == GRAY:\n                return True  # Back edge\n            if color[neighbor] == WHITE and dfs(neighbor):\n                return True\n        \n        color[node] = BLACK\n        return False\n    \n    for i in range(num_nodes):\n        if color[i] == WHITE and dfs(i):\n            return True\n    return False\n\ndef has_cycle_undirected(graph, num_nodes):\n    visited = set()\n    \n    def dfs(node, parent):\n        visited.add(node)\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n    \n    for i in range(num_nodes):\n        if i not in visited and dfs(i, -1):\n            return True\n    return False",
              "notes": "Gray nodes are in current DFS path - seeing one means cycle."
            }
          },
          {
            "name": "Topological Sort",
            "description": "Order nodes by dependencies (DAG only)",
            "javascript": {
              "code": "// Topological sort using DFS (Postorder)\nfunction topologicalSort(graph, numNodes) {\n  const visited = new Set();\n  const result = [];\n  \n  function dfs(node) {\n    visited.add(node);\n    \n    for (const neighbor of graph.get(node) || []) {\n      if (!visited.has(neighbor)) {\n        dfs(neighbor);\n      }\n    }\n    \n    result.push(node);  // Add AFTER processing children (postorder)\n  }\n  \n  for (let i = 0; i < numNodes; i++) {\n    if (!visited.has(i)) {\n      dfs(i);\n    }\n  }\n  \n  return result.reverse();  // Reverse postorder = topological order\n}\n\n// Kahn's algorithm (BFS-based)\nfunction topologicalSortKahn(graph, numNodes) {\n  const indegree = new Array(numNodes).fill(0);\n  \n  // Calculate indegrees\n  for (let node = 0; node < numNodes; node++) {\n    for (const neighbor of graph.get(node) || []) {\n      indegree[neighbor]++;\n    }\n  }\n  \n  // Start with nodes that have no dependencies\n  const queue = [];\n  for (let i = 0; i < numNodes; i++) {\n    if (indegree[i] === 0) queue.push(i);\n  }\n  \n  const result = [];\n  while (queue.length > 0) {\n    const node = queue.shift();\n    result.push(node);\n    \n    for (const neighbor of graph.get(node) || []) {\n      indegree[neighbor]--;\n      if (indegree[neighbor] === 0) {\n        queue.push(neighbor);\n      }\n    }\n  }\n  \n  // If result has all nodes, valid order exists\n  return result.length === numNodes ? result : [];  // Empty if cycle\n}",
              "notes": "DFS: reverse postorder. Kahn's: process 0-indegree nodes first."
            },
            "python": {
              "code": "from collections import deque\n\ndef topological_sort_dfs(graph, num_nodes):\n    visited = set()\n    result = []\n    \n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n        result.append(node)  # Postorder\n    \n    for i in range(num_nodes):\n        if i not in visited:\n            dfs(i)\n    \n    return result[::-1]  # Reverse\n\ndef topological_sort_kahn(graph, num_nodes):\n    indegree = [0] * num_nodes\n    \n    for node in range(num_nodes):\n        for neighbor in graph[node]:\n            indegree[neighbor] += 1\n    \n    queue = deque([i for i in range(num_nodes) if indegree[i] == 0])\n    result = []\n    \n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        \n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result if len(result) == num_nodes else []",
              "notes": "Kahn's also detects cycles - if result is short, there's a cycle."
            }
          }
        ],
        "visualTrace": {
          "title": "BFS from node A in graph A-B-C-D",
          "input": {
            "edges": "A-B, A-C, B-D, C-D",
            "start": "A",
            "target": "D"
          },
          "steps": [
            {
              "queue": "[A]",
              "visited": "{A}",
              "action": "Process A, add neighbors B, C"
            },
            {
              "queue": "[B, C]",
              "visited": "{A,B,C}",
              "action": "Process B (dist 1), add D"
            },
            {
              "queue": "[C, D]",
              "visited": "{A,B,C,D}",
              "action": "Process C (dist 1), D already visited"
            },
            {
              "queue": "[D]",
              "visited": "{A,B,C,D}",
              "action": "Process D (dist 2) - FOUND!"
            }
          ],
          "output": "Shortest path from A to D = 2 edges"
        },
        "commonMistakes": [
          {
            "mistake": "Forgetting visited set in cyclic graph",
            "wrong": "for (const n of neighbors) dfs(n); // Infinite loop!",
            "right": "if (!visited.has(n)) { visited.add(n); dfs(n); }",
            "explanation": "Graphs can have cycles. Without visited tracking, you'll loop forever."
          },
          {
            "mistake": "Adding to visited after processing instead of before",
            "wrong": "queue.push(n); // Later: visited.add(n)",
            "right": "visited.add(n); queue.push(n);",
            "explanation": "Add to visited when enqueueing, not when dequeuing. Otherwise, same node added multiple times."
          },
          {
            "mistake": "Using BFS for weighted shortest path",
            "wrong": "BFS on weighted graph // Wrong distances!",
            "right": "Use Dijkstra for weighted graphs",
            "explanation": "BFS assumes all edges have weight 1. For weighted edges, use Dijkstra."
          }
        ],
        "keyTakeaways": [
          "Graph = vertices + edges. Can be directed/undirected, weighted/unweighted.",
          "Adjacency list: O(V+E) space. Matrix: O(V¬≤) space. List for sparse, matrix for dense.",
          "ALWAYS use visited set - graphs have cycles unlike trees.",
          "BFS: shortest path (unweighted), level-order. Uses queue.",
          "DFS: cycle detection, topological sort, connected components. Uses stack/recursion.",
          "Cycle detection (directed): track 'in progress' nodes (gray color)"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "queue",
              "label": "Queue",
              "why": "BFS uses queue"
            },
            {
              "id": "stack",
              "label": "Stack",
              "why": "DFS uses stack (or recursion)"
            },
            {
              "id": "hashmap",
              "label": "HashMap",
              "why": "Adjacency list uses Map"
            }
          ],
          "nextTopics": [
            {
              "id": "bfs",
              "label": "BFS Deep Dive",
              "why": "Shortest path, level order"
            },
            {
              "id": "dfs",
              "label": "DFS Deep Dive",
              "why": "Cycle detection, topological sort"
            },
            {
              "id": "dijkstra",
              "label": "Dijkstra's Algorithm",
              "why": "Weighted shortest path"
            },
            {
              "id": "union_find",
              "label": "Union-Find",
              "why": "Connected components, cycle detection"
            }
          ]
        },
        "patternChain": {
          "description": "Graph is foundation for many advanced algorithms",
          "buildsOn": [
            {
              "id": "tree",
              "relationship": "Tree is a connected acyclic graph",
              "whatToKnow": "Graph generalizes trees"
            },
            {
              "id": "hashmap",
              "relationship": "Adjacency list is Map<Node, Neighbors>",
              "whatToKnow": "Efficient neighbor lookup"
            }
          ],
          "enables": [
            {
              "id": "bfs",
              "relationship": "Level-order traversal, shortest path",
              "patternName": "BFS Traversal",
              "interviewFrequency": "Very High"
            },
            {
              "id": "dfs",
              "relationship": "Deep traversal, backtracking",
              "patternName": "DFS Traversal",
              "interviewFrequency": "Very High"
            },
            {
              "id": "topo_sort",
              "relationship": "Dependency ordering",
              "patternName": "Topo Sort",
              "interviewFrequency": "High"
            },
            {
              "id": "dijkstra",
              "relationship": "Weighted shortest path",
              "patternName": "Shortest Path",
              "interviewFrequency": "High"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    HM[HashMap] --> G[Graph]\n    TREE[Tree] --> G\n    G --> BFS[BFS]\n    G --> DFS[DFS]\n    G --> TOPO[Topological Sort]\n    G --> DIJ[Dijkstra]\n    G --> UF[Union-Find]\n    \n    style G fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "bfs",
      "label": "BFS (Breadth-First Search)",
      "type": "algo-traversal",
      "description": "Level-by-level traversal.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Breadth-first_search"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/dfsbfs"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/breadth-first-search/"
          },
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/breadth-first-search.html"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2-3 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft",
        "LinkedIn"
      ],
      "interviewFrequency": "high",
      "category": "Traversal",
      "categoryIcon": "üö∂",
      "interviewQuestions": [
        {
          "name": "Binary Tree Level Order Traversal",
          "leetcode": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Meta",
            "Google",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Classic tree BFS - level by level processing",
          "approach": "Queue with level size tracking. Process all nodes at current level before next",
          "followUps": [
            {
              "question": "Zigzag order?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Right side view?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Bottom-up order?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Rotting Oranges",
          "leetcode": "https://leetcode.com/problems/rotting-oranges/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Microsoft",
            "Flipkart",
            "Swiggy"
          ],
          "frequency": "Very High",
          "whyAsked": "Multi-source BFS - shortest time for all cells to reach state",
          "approach": "Add all rotten to queue initially. BFS level by level. Track time/minutes",
          "followUps": [
            {
              "question": "Walls of different types?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "What if some fresh never rot?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Word Ladder",
          "leetcode": "https://leetcode.com/problems/word-ladder/",
          "difficulty": "Hard",
          "companies": [
            "Amazon",
            "Meta",
            "Google",
            "Microsoft"
          ],
          "frequency": "High",
          "whyAsked": "BFS for shortest path in implicit graph (words as nodes)",
          "approach": "BFS from start. Generate neighbors by changing one char. Use set for O(1) lookup",
          "followUps": [
            {
              "question": "Return all shortest paths?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Bidirectional BFS?",
              "answer": "Search from both source and target. Meet in middle. Much faster for large graphs."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Shortest Path in Binary Matrix",
          "leetcode": "https://leetcode.com/problems/shortest-path-in-binary-matrix/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google"
          ],
          "frequency": "High",
          "whyAsked": "BFS on grid - 8 directions, shortest path",
          "approach": "BFS from (0,0). Visit 8 neighbors. First to reach (n-1,n-1) is shortest",
          "followUps": [
            {
              "question": "Weighted edges (Dijkstra)?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Multiple targets?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Open the Lock",
          "leetcode": "https://leetcode.com/problems/open-the-lock/",
          "difficulty": "Medium",
          "companies": [
            "Google",
            "Amazon",
            "Meta"
          ],
          "frequency": "Medium",
          "whyAsked": "BFS on state space - each state has 8 neighbors (4 digits √ó 2 directions)",
          "approach": "BFS from '0000'. Generate 8 neighbors per state. Skip deadends. Count steps",
          "followUps": [
            {
              "question": "Bidirectional BFS?",
              "answer": "Search from both source and target. Meet in middle. Much faster for large graphs."
            },
            {
              "question": "With weighted moves?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based categorization"
        },
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with videos"
        }
      ],
      "content": {
        "definition": {
          "simple": "BFS is like ripples in a pond - explore all neighbors at distance 1, then all at distance 2, and so on. Level by level, closest first.",
          "technical": "Breadth-First Search (BFS) is a graph/tree traversal algorithm that explores nodes level by level. It uses a queue to process nodes in FIFO order, guaranteeing the shortest path in unweighted graphs."
        },
        "howItWorks": {
          "explanation": "Imagine you're finding the closest coffee shop. You check all places 1 block away first. None? Check all places 2 blocks away. This way, the FIRST coffee shop you find is guaranteed to be the closest. That's BFS.",
          "steps": [
            {
              "step": 1,
              "title": "Initialize",
              "description": "Create queue with starting node. Create visited set with start.",
              "why": "Queue ensures FIFO. Visited prevents revisits in cyclic graphs."
            },
            {
              "step": 2,
              "title": "Dequeue",
              "description": "Remove front node from queue.",
              "why": "Process in order of discovery (closest first)."
            },
            {
              "step": 3,
              "title": "Process",
              "description": "Check if this node is the target. If yes, we're done.",
              "why": "First time we reach target = shortest path."
            },
            {
              "step": 4,
              "title": "Expand",
              "description": "Add all unvisited neighbors to queue and visited set.",
              "why": "Discover nodes at next level."
            },
            {
              "step": 5,
              "title": "Repeat",
              "description": "Continue until queue empty (explored all) or found target.",
              "why": "Empty queue = exhausted all reachable nodes."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph TD\n    subgraph Level 0\n        A((A))\n    end\n    subgraph Level 1\n        B((B))\n        C((C))\n    end\n    subgraph Level 2\n        D((D))\n        E((E))\n    end\n    A --> B\n    A --> C\n    B --> D\n    C --> E\n    \n    style A fill:#ee6c4d\n    style B fill:#98c1d9\n    style C fill:#98c1d9\n    style D fill:#3d5a80\n    style E fill:#3d5a80",
            "caption": "BFS from A: Process A (level 0), then B,C (level 1), then D,E (level 2)."
          }
        },
        "whenToUse": {
          "summary": "Use BFS when you need SHORTEST PATH in unweighted graph, or when processing level-by-level matters.",
          "patterns": [
            {
              "pattern": "Shortest Path (Unweighted)",
              "signal": "Find minimum steps/moves/edges to reach target",
              "example": "Maze solving, word ladder, minimum moves",
              "withoutIt": "DFS might find longer path first",
              "withIt": "BFS guarantees shortest path found first"
            },
            {
              "pattern": "Level Order Traversal",
              "signal": "Process tree/graph level by level",
              "example": "Level order of binary tree, rightmost node per level",
              "withoutIt": "Complex tracking of levels in DFS",
              "withIt": "Queue naturally separates levels"
            },
            {
              "pattern": "Multi-Source BFS",
              "signal": "Distance from ANY of multiple sources",
              "example": "Rotting oranges, walls and gates",
              "withoutIt": "Run BFS from each source separately",
              "withIt": "Add all sources to initial queue"
            },
            {
              "pattern": "State Space Search",
              "signal": "Transform start state to goal state with minimum moves",
              "example": "Sliding puzzle, open the lock",
              "withoutIt": "Exponential exploration",
              "withIt": "BFS finds minimum transformations"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "BFS uses more memory than DFS (stores entire level). Avoid when memory is tight or path existence matters more than length.",
          "antiPatterns": [
            {
              "situation": "Just Check if Path Exists",
              "why": "DFS uses less memory, equally fast",
              "useInstead": "DFS",
              "example": "Can we reach node B?"
            },
            {
              "situation": "Weighted Graph Shortest Path",
              "why": "BFS treats all edges as weight 1",
              "useInstead": "Dijkstra's Algorithm",
              "example": "Shortest route with distances"
            },
            {
              "situation": "Finding All Paths",
              "why": "BFS doesn't naturally backtrack",
              "useInstead": "DFS with backtracking",
              "example": "All paths from A to B"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Ripple Effect",
            "story": "Drop a stone in a pond. Ripples expand in circles - first 1 foot out, then 2 feet, then 3. The ripple reaches nearby lily pads before distant ones. If you want to find the closest lily pad, wait for the first one the ripple touches.",
            "connection": "BFS expands like ripples. Each 'ring' is a level. Nodes in the same ring are equidistant from the source. The first time we reach any node, that's the shortest path."
          },
          "keyInsight": "BFS explores in order of DISTANCE. Because queue is FIFO, we fully process distance 1 before any distance 2, distance 2 before distance 3, etc. First arrival = shortest path.",
          "commonConfusion": [
            {
              "confusion": "Why queue, not stack?",
              "clarification": "Queue = FIFO = process earlier discovered nodes first = level by level. Stack = LIFO = go deep = DFS."
            },
            {
              "confusion": "Why track visited when adding, not when processing?",
              "clarification": "If you wait until processing, same node gets added multiple times by different neighbors. Wasteful and can cause issues."
            },
            {
              "confusion": "BFS vs Dijkstra?",
              "clarification": "BFS = all edges weight 1. Dijkstra = edges have different weights. Dijkstra uses priority queue, not regular queue."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "BFS Traversal",
                "average": "O(V+E)",
                "worst": "O(V+E)",
                "note": "Visit each vertex and edge once"
              },
              {
                "operation": "Shortest Path",
                "average": "O(V+E)",
                "worst": "O(V+E)",
                "note": "Same - might traverse entire graph"
              }
            ],
            "explanation": "Each vertex enters queue once. Each edge checked once (or twice for undirected)."
          },
          "space": {
            "complexity": "O(V)",
            "explanation": "Queue can hold up to V vertices. Visited set holds V entries."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "BFS needs queue + visited set. Queue can grow to entire level width.",
            "keyPoints": [
              "Queue holds nodes to process (current frontier)",
              "Visited set prevents revisiting (crucial for graphs with cycles)",
              "Memory = O(width of graph) at peak",
              "In tree, last level can be n/2 nodes (wide)"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Array with shift() for queue. Set for visited.",
              "gotchas": [
                "shift() is O(n), but okay for most interview problems",
                "For performance-critical, use proper queue implementation",
                "Set works for primitive node values; Map for objects"
              ]
            },
            "python": {
              "implementation": "collections.deque for O(1) popleft. set for visited.",
              "gotchas": [
                "ALWAYS use deque, not list.pop(0)",
                "For matrix: visited can be set of tuples (row, col)",
                "Mark visited when adding to queue, not when popping"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "BFS finds shortest path in unweighted graph",
            "proof": {
              "step1": {
                "action": "All nodes at distance d processed before distance d+1",
                "cost": "Queue property"
              },
              "step2": {
                "action": "First time we reach target, we've traversed minimum edges",
                "cost": "FIFO order"
              },
              "step3": {
                "action": "We never revisit a node, so distance can't decrease",
                "cost": "Visited set"
              }
            },
            "totalCost": "First path found = shortest path"
          }
        },
        "codeTemplates": [
          {
            "name": "BFS Template (Graph)",
            "description": "Standard BFS with distance tracking",
            "javascript": {
              "code": "function bfs(graph, start, target) {\n  const queue = [[start, 0]];  // [node, distance]\n  const visited = new Set([start]);\n  \n  while (queue.length > 0) {\n    const [node, dist] = queue.shift();\n    \n    // Check if found target\n    if (node === target) {\n      return dist;\n    }\n    \n    // Explore neighbors\n    for (const neighbor of graph.get(node) || []) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);  // Mark visited WHEN ADDING\n        queue.push([neighbor, dist + 1]);\n      }\n    }\n  }\n  \n  return -1;  // Target not reachable\n}\n\n// BFS with path reconstruction\nfunction bfsWithPath(graph, start, target) {\n  const queue = [start];\n  const visited = new Set([start]);\n  const parent = new Map();  // Track how we reached each node\n  parent.set(start, null);\n  \n  while (queue.length > 0) {\n    const node = queue.shift();\n    \n    if (node === target) {\n      // Reconstruct path\n      const path = [];\n      let curr = target;\n      while (curr !== null) {\n        path.unshift(curr);\n        curr = parent.get(curr);\n      }\n      return path;\n    }\n    \n    for (const neighbor of graph.get(node) || []) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        parent.set(neighbor, node);\n        queue.push(neighbor);\n      }\n    }\n  }\n  \n  return [];  // No path\n}",
              "notes": "Store parent to reconstruct path. Mark visited when enqueueing, not dequeuing."
            },
            "python": {
              "code": "from collections import deque\n\ndef bfs(graph, start, target):\n    queue = deque([(start, 0)])  # (node, distance)\n    visited = {start}\n    \n    while queue:\n        node, dist = queue.popleft()\n        \n        if node == target:\n            return dist\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, dist + 1))\n    \n    return -1\n\ndef bfs_with_path(graph, start, target):\n    queue = deque([start])\n    visited = {start}\n    parent = {start: None}\n    \n    while queue:\n        node = queue.popleft()\n        \n        if node == target:\n            path = []\n            curr = target\n            while curr is not None:\n                path.append(curr)\n                curr = parent[curr]\n            return path[::-1]\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                parent[neighbor] = node\n                queue.append(neighbor)\n    \n    return []",
              "notes": "deque.popleft() is O(1). parent dict reconstructs path."
            }
          },
          {
            "name": "BFS on Matrix (Grid)",
            "description": "Common interview pattern - maze/grid problems",
            "javascript": {
              "code": "function shortestPathInGrid(grid) {\n  const rows = grid.length, cols = grid[0].length;\n  if (grid[0][0] === 1 || grid[rows-1][cols-1] === 1) return -1;\n  \n  const directions = [[0,1], [0,-1], [1,0], [-1,0]];\n  const queue = [[0, 0, 1]];  // [row, col, distance]\n  const visited = new Set(['0,0']);\n  \n  while (queue.length > 0) {\n    const [row, col, dist] = queue.shift();\n    \n    if (row === rows - 1 && col === cols - 1) {\n      return dist;\n    }\n    \n    for (const [dr, dc] of directions) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n      const key = `${newRow},${newCol}`;\n      \n      if (newRow >= 0 && newRow < rows && \n          newCol >= 0 && newCol < cols &&\n          grid[newRow][newCol] === 0 && \n          !visited.has(key)) {\n        visited.add(key);\n        queue.push([newRow, newCol, dist + 1]);\n      }\n    }\n  }\n  \n  return -1;\n}",
              "notes": "Use string key '0,0' for visited set. Check bounds + obstacles + visited."
            },
            "python": {
              "code": "from collections import deque\n\ndef shortest_path_in_grid(grid):\n    rows, cols = len(grid), len(grid[0])\n    if grid[0][0] == 1 or grid[rows-1][cols-1] == 1:\n        return -1\n    \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(0, 0, 1)])  # (row, col, distance)\n    visited = {(0, 0)}\n    \n    while queue:\n        row, col, dist = queue.popleft()\n        \n        if row == rows - 1 and col == cols - 1:\n            return dist\n        \n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            \n            if (0 <= new_row < rows and \n                0 <= new_col < cols and\n                grid[new_row][new_col] == 0 and\n                (new_row, new_col) not in visited):\n                visited.add((new_row, new_col))\n                queue.append((new_row, new_col, dist + 1))\n    \n    return -1",
              "notes": "Tuple (row, col) works directly in set. 4-directional movement."
            }
          },
          {
            "name": "Multi-Source BFS",
            "description": "BFS from multiple starting points simultaneously",
            "javascript": {
              "code": "// Rotting Oranges - LeetCode 994\n// Return minutes until all fresh oranges rot (or -1 if impossible)\nfunction orangesRotting(grid) {\n  const rows = grid.length, cols = grid[0].length;\n  const queue = [];\n  let freshCount = 0;\n  \n  // Find all rotten oranges (sources) and count fresh\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (grid[r][c] === 2) queue.push([r, c, 0]);\n      if (grid[r][c] === 1) freshCount++;\n    }\n  }\n  \n  if (freshCount === 0) return 0;\n  \n  const directions = [[0,1], [0,-1], [1,0], [-1,0]];\n  let minutes = 0;\n  \n  while (queue.length > 0) {\n    const [r, c, time] = queue.shift();\n    minutes = time;\n    \n    for (const [dr, dc] of directions) {\n      const nr = r + dr, nc = c + dc;\n      \n      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && \n          grid[nr][nc] === 1) {\n        grid[nr][nc] = 2;  // Mark as rotten (visited)\n        freshCount--;\n        queue.push([nr, nc, time + 1]);\n      }\n    }\n  }\n  \n  return freshCount === 0 ? minutes : -1;\n}",
              "notes": "Add ALL sources to initial queue. BFS spreads from all simultaneously."
            },
            "python": {
              "code": "from collections import deque\n\ndef oranges_rotting(grid):\n    rows, cols = len(grid), len(grid[0])\n    queue = deque()\n    fresh_count = 0\n    \n    # Find all rotten (sources) and count fresh\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 2:\n                queue.append((r, c, 0))\n            elif grid[r][c] == 1:\n                fresh_count += 1\n    \n    if fresh_count == 0:\n        return 0\n    \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    minutes = 0\n    \n    while queue:\n        r, c, time = queue.popleft()\n        minutes = time\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            \n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:\n                grid[nr][nc] = 2  # Mark rotten\n                fresh_count -= 1\n                queue.append((nr, nc, time + 1))\n    \n    return minutes if fresh_count == 0 else -1",
              "notes": "Multi-source: all start positions in initial queue with distance 0."
            }
          }
        ],
        "visualTrace": {
          "title": "BFS on Grid: Find shortest path from (0,0) to (2,2)",
          "input": {
            "grid": "[[0,0,0],\n [0,1,0],\n [0,0,0]]",
            "start": "(0,0)",
            "target": "(2,2)"
          },
          "steps": [
            {
              "queue": "[(0,0,1)]",
              "visited": "{(0,0)}",
              "action": "Start at top-left"
            },
            {
              "queue": "[(0,1,2),(1,0,2)]",
              "visited": "{(0,0),(0,1),(1,0)}",
              "action": "Expand to neighbors"
            },
            {
              "queue": "[(1,0,2),(0,2,3)]",
              "visited": "{...,(0,2)}",
              "action": "Process (0,1), add (0,2)"
            },
            {
              "queue": "[(0,2,3),(2,0,3)]",
              "visited": "{...,(2,0)}",
              "action": "Process (1,0), add (2,0)"
            },
            {
              "queue": "[(2,0,3),(1,2,4)]",
              "visited": "{...,(1,2)}",
              "action": "(1,1) is wall, skip"
            },
            {
              "queue": "[(1,2,4),(2,1,4)]",
              "visited": "{...,(2,1)}",
              "action": "Process (2,0)"
            },
            {
              "queue": "[(2,1,4),(2,2,5)]",
              "visited": "{...,(2,2)}",
              "action": "Add (2,2)!"
            },
            {
              "queue": "[(2,2,5)]",
              "visited": "{all}",
              "action": "Process (2,2) = TARGET!"
            }
          ],
          "output": "Shortest path = 5 cells (distance 4). Path: (0,0)‚Üí(0,1)‚Üí(0,2)‚Üí(1,2)‚Üí(2,2)"
        },
        "commonMistakes": [
          {
            "mistake": "Marking visited when dequeuing instead of enqueuing",
            "wrong": "node = queue.shift(); visited.add(node);",
            "right": "visited.add(neighbor); queue.push(neighbor);",
            "explanation": "If you wait, same node added multiple times by different parents."
          },
          {
            "mistake": "Using BFS for weighted shortest path",
            "wrong": "BFS on graph with edge weights 1,5,3...",
            "right": "Use Dijkstra's algorithm",
            "explanation": "BFS assumes all edges have equal weight. Different weights need priority queue."
          },
          {
            "mistake": "Forgetting visited set in cyclic graph",
            "wrong": "queue.push(neighbor); // No visited check",
            "right": "if (!visited.has(neighbor)) { visited.add(neighbor); queue.push(neighbor); }",
            "explanation": "Without visited, infinite loop in graphs with cycles."
          }
        ],
        "keyTakeaways": [
          "BFS = level-by-level traversal using QUEUE (FIFO)",
          "Guarantees SHORTEST PATH in unweighted graphs",
          "Mark visited when ADDING to queue, not when processing",
          "Time: O(V+E). Space: O(V) for queue + visited",
          "Multi-source BFS: add all sources to initial queue",
          "Grid BFS: use (row, col) tuples, check bounds + obstacles"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "queue",
              "label": "Queue",
              "why": "BFS uses queue for FIFO processing"
            },
            {
              "id": "graph",
              "label": "Graph Basics",
              "why": "Understanding vertices and edges"
            }
          ],
          "nextTopics": [
            {
              "id": "dfs",
              "label": "DFS",
              "why": "Alternative traversal strategy"
            },
            {
              "id": "dijkstra",
              "label": "Dijkstra",
              "why": "Weighted shortest path"
            },
            {
              "id": "bidirectional_bfs",
              "label": "Bidirectional BFS",
              "why": "Optimization for large graphs"
            }
          ]
        },
        "patternChain": {
          "description": "BFS is the go-to for shortest path in unweighted scenarios",
          "buildsOn": [
            {
              "id": "queue",
              "relationship": "FIFO queue enables level-by-level",
              "whatToKnow": "O(1) enqueue/dequeue"
            },
            {
              "id": "graph",
              "relationship": "Graph traversal algorithm",
              "whatToKnow": "Adjacency list representation"
            }
          ],
          "enables": [
            {
              "id": "shortest_path",
              "relationship": "Minimum edges to target",
              "patternName": "Shortest Path",
              "interviewFrequency": "Very High"
            },
            {
              "id": "level_order",
              "relationship": "Tree level traversal",
              "patternName": "Level Order",
              "interviewFrequency": "Very High"
            },
            {
              "id": "multi_source",
              "relationship": "Distance from any of multiple sources",
              "patternName": "Multi-Source BFS",
              "interviewFrequency": "High"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    Q[Queue] --> BFS[BFS]\n    G[Graph] --> BFS\n    BFS --> SP[Shortest Path]\n    BFS --> LVL[Level Order]\n    BFS --> MS[Multi-Source]\n    BFS --> WORD[Word Ladder]\n    \n    style BFS fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "dfs",
      "label": "DFS (Depth-First Search)",
      "type": "algo-traversal",
      "description": "Deep traversal.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Depth-first_search"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/dfsbfs"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/depth-first-search/"
          },
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/depth-first-search.html"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2-3 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft",
        "LinkedIn"
      ],
      "interviewFrequency": "high",
      "category": "Traversal",
      "categoryIcon": "üö∂",
      "interviewQuestions": [
        {
          "name": "Number of Islands",
          "leetcode": "https://leetcode.com/problems/number-of-islands/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Microsoft",
            "Bloomberg"
          ],
          "frequency": "Very High",
          "whyAsked": "Classic grid DFS - count connected components",
          "approach": "DFS from each '1', mark as visited ('0'). Count number of DFS calls",
          "followUps": [
            {
              "question": "Max area?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Number of distinct islands?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Surrounded regions?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Clone Graph",
          "leetcode": "https://leetcode.com/problems/clone-graph/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Microsoft"
          ],
          "frequency": "High",
          "whyAsked": "DFS/BFS with hash map for deep copy - handle cycles",
          "approach": "Hash map {original -> clone}. DFS: create clone, recurse on neighbors, add edges",
          "followUps": [
            {
              "question": "Clone linked list with random pointer?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Clone n-ary tree?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Course Schedule",
          "leetcode": "https://leetcode.com/problems/course-schedule/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Meta",
            "Google",
            "Microsoft",
            "Apple"
          ],
          "frequency": "Very High",
          "whyAsked": "Cycle detection in directed graph using DFS",
          "approach": "DFS with 3 states: unvisited, visiting, visited. Cycle if we reach 'visiting' node",
          "followUps": [
            {
              "question": "Return valid order (II)?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "All possible orders?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Max Area of Island",
          "leetcode": "https://leetcode.com/problems/max-area-of-island/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta"
          ],
          "frequency": "High",
          "whyAsked": "DFS with return value - count cells in component",
          "approach": "DFS returns area (1 + sum of 4 neighbors). Track max area seen",
          "followUps": [
            {
              "question": "Count perimeter?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Islands with water inside?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Surrounded Regions",
          "leetcode": "https://leetcode.com/problems/surrounded-regions/",
          "difficulty": "Medium",
          "companies": [
            "Google",
            "Amazon",
            "Meta"
          ],
          "frequency": "Medium",
          "whyAsked": "Reverse thinking - DFS from border O's to protect them",
          "approach": "DFS from border O's, mark as '#'. Flip remaining O's to X. Restore '#' to O",
          "followUps": [
            {
              "question": "Number of enclaves?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "BFS approach?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based categorization"
        },
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with videos"
        }
      ],
      "content": {
        "definition": {
          "simple": "DFS is like exploring a maze - go as deep as possible down one path, hit a dead end, backtrack, try another path. Depth first, then backtrack.",
          "technical": "Depth-First Search (DFS) is a graph/tree traversal algorithm that explores as far as possible along each branch before backtracking. It uses a stack (implicit via recursion or explicit) for LIFO processing."
        },
        "howItWorks": {
          "explanation": "Imagine exploring a cave system. You go down one tunnel as far as you can. Dead end? Backtrack to the last junction and try another tunnel. You're always going DEEP first, then backing up. That's DFS.",
          "steps": [
            {
              "step": 1,
              "title": "Start",
              "description": "Push starting node onto stack (or call recursive function).",
              "why": "Stack enables backtracking."
            },
            {
              "step": 2,
              "title": "Pop/Process",
              "description": "Pop from stack, process the node.",
              "why": "LIFO = most recently discovered first."
            },
            {
              "step": 3,
              "title": "Check Visited",
              "description": "Skip if already visited. Mark as visited.",
              "why": "Avoid infinite loops in cyclic graphs."
            },
            {
              "step": 4,
              "title": "Explore Children",
              "description": "Push all unvisited neighbors onto stack.",
              "why": "They'll be processed next (before older nodes)."
            },
            {
              "step": 5,
              "title": "Backtrack",
              "description": "When no more children, popping reveals previous node.",
              "why": "Stack naturally handles backtracking."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph TD\n    A((1)) --> B((2))\n    A --> C((5))\n    B --> D((3))\n    B --> E((4))\n    C --> F((6))\n    \n    style A fill:#ee6c4d\n    style B fill:#98c1d9\n    style D fill:#3d5a80\n    style E fill:#3d5a80\n    style C fill:#98c1d9\n    style F fill:#3d5a80",
            "caption": "DFS order: 1‚Üí2‚Üí3‚Üí(backtrack)‚Üí4‚Üí(backtrack to 1)‚Üí5‚Üí6. Go deep first."
          }
        },
        "whenToUse": {
          "summary": "Use DFS for exploring all paths, cycle detection, topological sort, or when memory is constrained (uses O(depth) vs BFS O(width)).",
          "patterns": [
            {
              "pattern": "Path Finding / All Paths",
              "signal": "Find if path exists, or enumerate all possible paths",
              "example": "All paths from source to target",
              "withoutIt": "Hard to track which paths we've explored",
              "withIt": "Natural backtracking explores all possibilities"
            },
            {
              "pattern": "Cycle Detection",
              "signal": "Check if graph has cycles",
              "example": "Detect cycle in directed graph, valid tree",
              "withoutIt": "Complex tracking of edges",
              "withIt": "Track 'in progress' nodes (gray color)"
            },
            {
              "pattern": "Topological Sort",
              "signal": "Order nodes by dependencies (DAG)",
              "example": "Course schedule, build order",
              "withoutIt": "Manual dependency resolution",
              "withIt": "DFS postorder gives reverse topological order"
            },
            {
              "pattern": "Connected Components",
              "signal": "Find groups of connected nodes",
              "example": "Number of islands, friend groups",
              "withoutIt": "Complex union tracking",
              "withIt": "DFS from each unvisited node marks a component"
            },
            {
              "pattern": "Tree Traversals",
              "signal": "Preorder, inorder, postorder",
              "example": "Serialize tree, validate BST",
              "withoutIt": "BFS doesn't give these orderings",
              "withIt": "Natural recursive structure"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "DFS doesn't guarantee shortest path. Avoid when path length matters in unweighted graph.",
          "antiPatterns": [
            {
              "situation": "Shortest Path (Unweighted)",
              "why": "DFS might find longer path first",
              "useInstead": "BFS",
              "example": "Minimum moves in maze"
            },
            {
              "situation": "Level-Order Processing",
              "why": "DFS mixes levels",
              "useInstead": "BFS",
              "example": "Right side view of tree"
            },
            {
              "situation": "Very Deep Graphs (Recursive)",
              "why": "Stack overflow risk",
              "useInstead": "Iterative DFS or BFS",
              "example": "Deep linked-list-like tree"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Maze Explorer",
            "story": "You're in a maze. At each junction, you always take the leftmost unexplored path. Go until dead end. Then backtrack to last junction and try the next path. You'll eventually cover every corridor, but you might walk past the exit multiple times before finding it.",
            "connection": "That's why DFS doesn't give shortest path - it stubbornly goes deep before exploring other options. But it WILL find a path if one exists, and it's great for 'have we explored everything?' problems."
          },
          "keyInsight": "DFS is about EXPLORATION. It asks 'what's down THIS path?' before considering alternatives. The stack (or recursion) remembers 'where we came from' so we can backtrack.",
          "commonConfusion": [
            {
              "confusion": "When recursive vs iterative?",
              "clarification": "Recursive is cleaner but can stack overflow on deep graphs. Iterative with explicit stack avoids this."
            },
            {
              "confusion": "Preorder vs postorder?",
              "clarification": "Preorder: process before children. Postorder: process after children. Postorder useful for topological sort, tree deletion."
            },
            {
              "confusion": "Why 3 colors for cycle detection?",
              "clarification": "White = unvisited. Gray = in current path (recursion stack). Black = fully processed. Gray‚ÜíGray edge = cycle."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "DFS Traversal",
                "average": "O(V+E)",
                "worst": "O(V+E)",
                "note": "Visit each vertex and edge once"
              },
              {
                "operation": "Cycle Detection",
                "average": "O(V+E)",
                "worst": "O(V+E)",
                "note": "Same traversal"
              },
              {
                "operation": "Topological Sort",
                "average": "O(V+E)",
                "worst": "O(V+E)",
                "note": "DFS + reverse postorder"
              }
            ],
            "explanation": "Each vertex pushed/popped once. Each edge examined once."
          },
          "space": {
            "complexity": "O(V) worst case, O(depth) typical",
            "explanation": "Stack can hold all vertices in worst case (long chain). For balanced tree, O(log n)."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "DFS uses stack - either the call stack (recursive) or explicit stack (iterative).",
            "keyPoints": [
              "Recursive DFS: call stack holds the 'backtrack' points",
              "Iterative DFS: explicit stack data structure",
              "Visited set: O(V) to track processed nodes",
              "Memory proportional to DEPTH, not WIDTH (unlike BFS)"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Recursive or array as stack (push/pop).",
              "gotchas": [
                "Default call stack limit ~10,000 - can overflow on deep graphs",
                "Use iterative for production code on unknown depths",
                "push/pop are O(1) - perfect for stack"
              ]
            },
            "python": {
              "implementation": "Recursive or list as stack. sys.setrecursionlimit() for deep graphs.",
              "gotchas": [
                "Default recursion limit ~1000",
                "sys.setrecursionlimit(10000) for deeper",
                "For very deep, use iterative with explicit stack"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "DFS visits each node exactly once",
            "proof": {
              "step1": {
                "action": "Node marked visited before processing children",
                "cost": "Can't revisit"
              },
              "step2": {
                "action": "Each edge examined once (directed) or twice (undirected)",
                "cost": "O(E) edges"
              },
              "step3": {
                "action": "Stack operations are O(1)",
                "cost": "O(V) pushes/pops"
              }
            },
            "totalCost": "O(V + E)"
          }
        },
        "codeTemplates": [
          {
            "name": "DFS Template (Recursive + Iterative)",
            "description": "Both approaches with visited tracking",
            "javascript": {
              "code": "// Recursive DFS\nfunction dfsRecursive(graph, node, visited = new Set()) {\n  if (visited.has(node)) return;\n  visited.add(node);\n  \n  console.log('Visiting:', node);  // Process node\n  \n  for (const neighbor of graph.get(node) || []) {\n    dfsRecursive(graph, neighbor, visited);\n  }\n}\n\n// Iterative DFS (explicit stack)\nfunction dfsIterative(graph, start) {\n  const stack = [start];\n  const visited = new Set();\n  \n  while (stack.length > 0) {\n    const node = stack.pop();\n    \n    if (visited.has(node)) continue;\n    visited.add(node);\n    \n    console.log('Visiting:', node);  // Process node\n    \n    // Add neighbors to stack (reverse for same order as recursive)\n    const neighbors = graph.get(node) || [];\n    for (let i = neighbors.length - 1; i >= 0; i--) {\n      if (!visited.has(neighbors[i])) {\n        stack.push(neighbors[i]);\n      }\n    }\n  }\n}\n\n// DFS returning result (e.g., path exists)\nfunction hasPath(graph, start, end, visited = new Set()) {\n  if (start === end) return true;\n  if (visited.has(start)) return false;\n  \n  visited.add(start);\n  \n  for (const neighbor of graph.get(start) || []) {\n    if (hasPath(graph, neighbor, end, visited)) {\n      return true;\n    }\n  }\n  \n  return false;\n}",
              "notes": "Recursive is cleaner. Iterative avoids stack overflow. Reverse neighbor order for same traversal order."
            },
            "python": {
              "code": "def dfs_recursive(graph, node, visited=None):\n    if visited is None:\n        visited = set()\n    if node in visited:\n        return\n    visited.add(node)\n    \n    print(f'Visiting: {node}')\n    \n    for neighbor in graph[node]:\n        dfs_recursive(graph, neighbor, visited)\n\ndef dfs_iterative(graph, start):\n    stack = [start]\n    visited = set()\n    \n    while stack:\n        node = stack.pop()\n        \n        if node in visited:\n            continue\n        visited.add(node)\n        \n        print(f'Visiting: {node}')\n        \n        # Add neighbors (reverse for same order as recursive)\n        for neighbor in reversed(graph[node]):\n            if neighbor not in visited:\n                stack.append(neighbor)\n\ndef has_path(graph, start, end, visited=None):\n    if visited is None:\n        visited = set()\n    if start == end:\n        return True\n    if start in visited:\n        return False\n    \n    visited.add(start)\n    \n    for neighbor in graph[start]:\n        if has_path(graph, neighbor, end, visited):\n            return True\n    \n    return False",
              "notes": "Use visited=None default to avoid mutable default argument issue."
            }
          },
          {
            "name": "Cycle Detection (Directed Graph)",
            "description": "3-color algorithm for directed graphs",
            "javascript": {
              "code": "// Cycle detection in directed graph using 3 colors\nfunction hasCycle(graph, numNodes) {\n  const WHITE = 0, GRAY = 1, BLACK = 2;\n  const color = new Array(numNodes).fill(WHITE);\n  \n  function dfs(node) {\n    color[node] = GRAY;  // Currently processing\n    \n    for (const neighbor of graph.get(node) || []) {\n      if (color[neighbor] === GRAY) {\n        // Back edge to node in current path = cycle!\n        return true;\n      }\n      if (color[neighbor] === WHITE && dfs(neighbor)) {\n        return true;\n      }\n    }\n    \n    color[node] = BLACK;  // Done with this node\n    return false;\n  }\n  \n  // Check all components\n  for (let i = 0; i < numNodes; i++) {\n    if (color[i] === WHITE && dfs(i)) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n\n// Why it works:\n// WHITE: Not yet visited\n// GRAY: In current DFS path (on recursion stack)\n// BLACK: Completely processed (all descendants explored)\n// \n// If we see a GRAY node, we've found a back edge = cycle!",
              "notes": "Gray = in current recursion stack. Black = fully done. Gray‚ÜíGray = back edge = cycle."
            },
            "python": {
              "code": "def has_cycle(graph, num_nodes):\n    WHITE, GRAY, BLACK = 0, 1, 2\n    color = [WHITE] * num_nodes\n    \n    def dfs(node):\n        color[node] = GRAY\n        \n        for neighbor in graph[node]:\n            if color[neighbor] == GRAY:\n                return True  # Back edge\n            if color[neighbor] == WHITE and dfs(neighbor):\n                return True\n        \n        color[node] = BLACK\n        return False\n    \n    for i in range(num_nodes):\n        if color[i] == WHITE and dfs(i):\n            return True\n    \n    return False\n\n# For undirected graph: track parent instead\ndef has_cycle_undirected(graph, num_nodes):\n    visited = set()\n    \n    def dfs(node, parent):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True  # Visited but not parent = cycle\n        return False\n    \n    for i in range(num_nodes):\n        if i not in visited and dfs(i, -1):\n            return True\n    return False",
              "notes": "Directed: 3 colors. Undirected: track parent (don't count edge we came from)."
            }
          },
          {
            "name": "Number of Islands (Grid DFS)",
            "description": "Classic connected components problem",
            "javascript": {
              "code": "function numIslands(grid) {\n  const rows = grid.length;\n  const cols = grid[0].length;\n  let count = 0;\n  \n  function dfs(r, c) {\n    // Bounds check and water/visited check\n    if (r < 0 || r >= rows || c < 0 || c >= cols || grid[r][c] === '0') {\n      return;\n    }\n    \n    // Mark as visited (sink the island)\n    grid[r][c] = '0';\n    \n    // Explore all 4 directions\n    dfs(r + 1, c);\n    dfs(r - 1, c);\n    dfs(r, c + 1);\n    dfs(r, c - 1);\n  }\n  \n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (grid[r][c] === '1') {\n        count++;      // Found new island\n        dfs(r, c);    // Sink entire island\n      }\n    }\n  }\n  \n  return count;\n}\n\n// Why it works:\n// - Each '1' cell belongs to exactly one island\n// - When we find a '1', we've discovered a new island\n// - DFS marks all connected '1's as visited (sinks them)\n// - Next unvisited '1' must be a different island",
              "notes": "Modify grid in-place to mark visited. Each DFS call explores one connected component."
            },
            "python": {
              "code": "def num_islands(grid):\n    if not grid:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    count = 0\n    \n    def dfs(r, c):\n        if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == '0':\n            return\n        \n        grid[r][c] = '0'  # Mark visited\n        \n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                count += 1\n                dfs(r, c)\n    \n    return count\n\n# With explicit stack (avoids recursion limit on large grids)\ndef num_islands_iterative(grid):\n    if not grid:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    count = 0\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                count += 1\n                stack = [(r, c)]\n                grid[r][c] = '0'\n                \n                while stack:\n                    cr, cc = stack.pop()\n                    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:\n                        nr, nc = cr + dr, cc + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == '1':\n                            grid[nr][nc] = '0'\n                            stack.append((nr, nc))\n    \n    return count",
              "notes": "Modify grid to mark visited (or use separate set). Iterative for large grids."
            }
          }
        ],
        "visualTrace": {
          "title": "DFS on graph: A‚ÜíB‚ÜíD‚ÜíE‚ÜíC‚ÜíF",
          "input": {
            "graph": "A-[B,C], B-[D,E], C-[F]",
            "start": "A"
          },
          "steps": [
            {
              "stack": "[A]",
              "visited": "{}",
              "action": "Pop A, visit, push B,C"
            },
            {
              "stack": "[C, B]",
              "visited": "{A}",
              "action": "Pop B, visit, push D,E"
            },
            {
              "stack": "[C, E, D]",
              "visited": "{A,B}",
              "action": "Pop D, visit (no children)"
            },
            {
              "stack": "[C, E]",
              "visited": "{A,B,D}",
              "action": "Pop E, visit (no children)"
            },
            {
              "stack": "[C]",
              "visited": "{A,B,D,E}",
              "action": "Pop C, visit, push F"
            },
            {
              "stack": "[F]",
              "visited": "{A,B,D,E,C}",
              "action": "Pop F, visit (no children)"
            },
            {
              "stack": "[]",
              "visited": "{A,B,D,E,C,F}",
              "action": "Stack empty, done!"
            }
          ],
          "output": "Visit order: A ‚Üí B ‚Üí D ‚Üí E ‚Üí C ‚Üí F (depth-first)"
        },
        "commonMistakes": [
          {
            "mistake": "No base case in recursive DFS",
            "wrong": "function dfs(node) { for neighbor: dfs(neighbor) }",
            "right": "if (visited.has(node)) return; visited.add(node);",
            "explanation": "Without base case, infinite recursion on cycles or revisits."
          },
          {
            "mistake": "Stack overflow on deep recursion",
            "wrong": "dfs(deepNode) // Crashes on depth > 10000",
            "right": "Use iterative DFS with explicit stack",
            "explanation": "Call stack has limits. For unknown/deep graphs, use iterative."
          },
          {
            "mistake": "Using DFS for shortest path",
            "wrong": "DFS to find minimum distance // Wrong!",
            "right": "Use BFS for shortest path in unweighted graph",
            "explanation": "DFS explores depth-first, might find longer path before shorter one."
          }
        ],
        "keyTakeaways": [
          "DFS = depth-first traversal using STACK (LIFO) or recursion",
          "Goes as DEEP as possible, then backtracks",
          "Time: O(V+E). Space: O(V) worst, O(depth) typical",
          "Use for: cycle detection, topological sort, connected components, all paths",
          "NOT for shortest path (use BFS instead)",
          "3 colors for directed cycle detection: white/gray/black"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "stack",
              "label": "Stack",
              "why": "DFS uses stack for backtracking"
            },
            {
              "id": "recursion",
              "label": "Recursion",
              "why": "Recursive DFS uses call stack"
            },
            {
              "id": "graph",
              "label": "Graph Basics",
              "why": "Understanding vertices and edges"
            }
          ],
          "nextTopics": [
            {
              "id": "backtracking",
              "label": "Backtracking",
              "why": "DFS with explicit undo"
            },
            {
              "id": "topo_sort",
              "label": "Topological Sort",
              "why": "DFS postorder application"
            },
            {
              "id": "tarjan",
              "label": "Tarjan's Algorithm",
              "why": "DFS for strongly connected components"
            }
          ]
        },
        "patternChain": {
          "description": "DFS is foundation for many exploration and cycle-related problems",
          "buildsOn": [
            {
              "id": "stack",
              "relationship": "LIFO enables backtracking",
              "whatToKnow": "Stack or recursion call stack"
            },
            {
              "id": "graph",
              "relationship": "Graph traversal algorithm",
              "whatToKnow": "Adjacency list representation"
            }
          ],
          "enables": [
            {
              "id": "cycle_detection",
              "relationship": "Track in-progress nodes",
              "patternName": "Cycle Detection",
              "interviewFrequency": "Very High"
            },
            {
              "id": "topo_sort",
              "relationship": "Reverse postorder",
              "patternName": "Topological Sort",
              "interviewFrequency": "High"
            },
            {
              "id": "connected_components",
              "relationship": "Mark reachable nodes",
              "patternName": "Connected Components",
              "interviewFrequency": "Very High"
            },
            {
              "id": "backtracking",
              "relationship": "DFS with state undo",
              "patternName": "Backtracking",
              "interviewFrequency": "Very High"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    S[Stack] --> DFS[DFS]\n    REC[Recursion] --> DFS\n    G[Graph] --> DFS\n    DFS --> CYC[Cycle Detection]\n    DFS --> TOPO[Topological Sort]\n    DFS --> CC[Connected Components]\n    DFS --> BT[Backtracking]\n    \n    style DFS fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "shortest_path",
      "label": "Shortest Path (Dijkstra/A*)",
      "type": "algo-graph",
      "description": "Finding optimal paths.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/sssp"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/shortest-path/"
          },
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/dijkstra.html"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "4-5 hours",
      "companies": [
        "Google",
        "Uber",
        "LinkedIn",
        "DoorDash"
      ],
      "interviewFrequency": "medium",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Dijkstra's algorithm finds the shortest path from one node to all other nodes in a weighted graph. It's like GPS navigation - always expand to the closest unvisited location, updating best-known distances as you go.",
          "technical": "Dijkstra's algorithm is a greedy algorithm that solves the single-source shortest path problem for a graph with non-negative edge weights. It maintains a set of visited nodes and repeatedly selects the unvisited node with minimum distance, relaxing edges to potentially update neighbors' distances."
        },
        "howItWorks": {
          "explanation": "Imagine you're at home and want shortest routes to all landmarks in a city. Start at home (distance 0). Look at all directly connected places and note distances. Visit the closest unvisited place. From there, check if going through it offers shorter paths to others. Repeat until all places visited.",
          "steps": [
            {
              "step": 1,
              "title": "Initialize",
              "description": "Set source distance to 0, all others to infinity.",
              "why": "We know path to source (0), don't know others yet."
            },
            {
              "step": 2,
              "title": "Priority Queue",
              "description": "Add source to min-heap with distance 0.",
              "why": "Heap ensures we always process closest node."
            },
            {
              "step": 3,
              "title": "Extract Minimum",
              "description": "Pop node with smallest distance from heap.",
              "why": "Greedy choice - closest unvisited is finalized."
            },
            {
              "step": 4,
              "title": "Relax Edges",
              "description": "For each neighbor, check if path through current is shorter.",
              "why": "Update distance if we found a better path."
            },
            {
              "step": 5,
              "title": "Repeat",
              "description": "Continue until heap is empty or target found.",
              "why": "Process all reachable nodes by distance order."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph LR\n    A((A)) -->|4| B((B))\n    A -->|1| C((C))\n    B -->|2| D((D))\n    C -->|5| B\n    C -->|3| D\n    \n    style A fill:#98c1d9\n    style D fill:#ee6c4d",
            "caption": "From A: distances are A=0, C=1, B=4, D=4. Path to D: A‚ÜíC‚ÜíD (cost 4) beats A‚ÜíB‚ÜíD (cost 6)."
          }
        },
        "whenToUse": {
          "summary": "Use for shortest paths in graphs with NON-NEGATIVE edge weights. The go-to algorithm for navigation, routing, and network problems.",
          "patterns": [
            {
              "pattern": "Single-Source Shortest Path",
              "signal": "Shortest distance from one node to all/specific others",
              "example": "GPS navigation, network routing",
              "withoutIt": "BFS only works for unweighted",
              "withIt": "Optimal O((V+E) log V) with heap"
            },
            {
              "pattern": "Cheapest Flights/Routes",
              "signal": "Find minimum cost path with constraints",
              "example": "Cheapest flights with K stops",
              "withoutIt": "Exponential path enumeration",
              "withIt": "Modified Dijkstra with state = (node, stops)"
            },
            {
              "pattern": "Network Delay",
              "signal": "Time for signal to reach all nodes",
              "example": "Network delay time problem",
              "withoutIt": "Simulate propagation",
              "withIt": "Max of all shortest paths"
            },
            {
              "pattern": "Minimum Effort Path",
              "signal": "Minimize maximum edge weight on path",
              "example": "Path of minimum effort in grid",
              "withoutIt": "Binary search + BFS/DFS",
              "withIt": "Modified Dijkstra with max instead of sum"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Dijkstra FAILS with negative edges. Cannot handle 'better path found later' scenarios.",
          "antiPatterns": [
            {
              "situation": "Negative Edge Weights",
              "why": "Greedy choice may be wrong - shorter path discovered later",
              "useInstead": "Bellman-Ford",
              "example": "Graph with -5 edge"
            },
            {
              "situation": "Unweighted Graph",
              "why": "BFS is simpler and same complexity",
              "useInstead": "BFS",
              "example": "All edges have weight 1"
            },
            {
              "situation": "All-Pairs Shortest Path",
              "why": "Running Dijkstra from each node is slow",
              "useInstead": "Floyd-Warshall (dense) or Johnson's",
              "example": "Distance between every pair of nodes"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Ripple Effect",
            "story": "Drop a stone in water. Ripples spread outward in circles. The first ripple to reach a point is the shortest path (water travels at constant speed). Dijkstra works the same way - we process nodes in order of distance from source, like ripples reaching shores.",
            "connection": "Priority queue = which point gets reached next by the 'ripple'. Once a point is reached, we know the shortest path (no faster route exists)."
          },
          "keyInsight": "The greedy choice works because all edges are non-negative. Once we've found the shortest path to a node, no later path can be shorter (adding more edges can only increase distance).",
          "commonConfusion": [
            {
              "confusion": "Why doesn't it work with negative edges?",
              "clarification": "With negative edges, a longer path now might become shorter later. Dijkstra 'finalizes' distances too early, missing these improvements."
            },
            {
              "confusion": "Why use heap instead of checking all nodes?",
              "clarification": "Heap gives O(log V) to find minimum. Without heap: O(V) per iteration ‚Üí O(V¬≤) total. With heap: O((V+E) log V)."
            },
            {
              "confusion": "Visited set: why and when?",
              "clarification": "Once we pop a node from heap, its distance is final. Skip if already visited. Alternative: lazy deletion (check if distance matches)."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Binary Heap implementation",
                "average": "O((V + E) log V)",
                "worst": "O((V + E) log V)",
                "note": "Each edge relaxation: O(log V)"
              },
              {
                "operation": "Array-based (no heap)",
                "average": "O(V¬≤)",
                "worst": "O(V¬≤)",
                "note": "Find min takes O(V)"
              },
              {
                "operation": "Fibonacci Heap",
                "average": "O(E + V log V)",
                "worst": "O(E + V log V)",
                "note": "Theoretical best, rarely used"
              }
            ],
            "explanation": "Binary heap is standard. O(V¬≤ + E) for array = O(V¬≤) for dense graphs."
          },
          "space": {
            "complexity": "O(V + E)",
            "explanation": "Adjacency list (E), distance array (V), heap (up to V)."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Distance array, predecessor array (for path reconstruction), min-heap of (distance, node) pairs.",
            "keyPoints": [
              "dist[v] = shortest known distance from source to v",
              "prev[v] = predecessor of v on shortest path (for reconstruction)",
              "Min-heap ordered by distance",
              "Lazy deletion: heap may have outdated entries, skip if already visited"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "No built-in heap. Use array sorted by distance or implement min-heap.",
              "gotchas": [
                "JavaScript has no native priority queue",
                "Can use array with sort() but O(n log n) per insert",
                "Consider @datastructures-js/priority-queue package",
                "Use Infinity for initial distances"
              ]
            },
            "python": {
              "implementation": "heapq module. Push tuples (distance, node). Min-heap by default.",
              "gotchas": [
                "heapq is min-heap (smallest first)",
                "Tuples compare by first element (distance)",
                "No decrease-key: push duplicate, skip outdated",
                "Use float('inf') for initial distances"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Dijkstra's greedy choice is correct for non-negative weights",
            "proof": {
              "step1": {
                "action": "When we pop node u with distance d[u]",
                "cost": "d[u] is smallest among unvisited"
              },
              "step2": {
                "action": "Any other path to u goes through unvisited node v",
                "cost": "d[v] ‚â• d[u] (since u is minimum)"
              },
              "step3": {
                "action": "Path through v has length ‚â• d[v] ‚â• d[u]",
                "cost": "Non-negative edges can't decrease distance"
              },
              "step4": {
                "action": "Therefore d[u] is optimal when popped",
                "cost": "Greedy choice is correct"
              }
            },
            "totalCost": "Each node processed once, each edge relaxed once ‚Üí O((V+E) log V)"
          }
        },
        "codeTemplates": [
          {
            "name": "Standard Dijkstra",
            "description": "Single-source shortest path with min-heap",
            "javascript": {
              "code": "function dijkstra(graph, source, n) {\n  // graph: adjacency list, graph[u] = [[v, weight], ...]\n  const dist = new Array(n).fill(Infinity);\n  const visited = new Set();\n  dist[source] = 0;\n  \n  // Min-heap: [distance, node]\n  // Using array with manual management (for simplicity)\n  const heap = [[0, source]];\n  \n  while (heap.length > 0) {\n    // Pop minimum (sort descending, pop from end)\n    heap.sort((a, b) => b[0] - a[0]);\n    const [d, u] = heap.pop();\n    \n    // Skip if already visited (lazy deletion)\n    if (visited.has(u)) continue;\n    visited.add(u);\n    \n    // Relax edges\n    for (const [v, weight] of graph[u] || []) {\n      if (!visited.has(v) && dist[u] + weight < dist[v]) {\n        dist[v] = dist[u] + weight;\n        heap.push([dist[v], v]);\n      }\n    }\n  }\n  \n  return dist;\n}\n\n// Usage:\n// const graph = [\n//   [[1, 4], [2, 1]],  // Node 0: edges to 1 (weight 4), 2 (weight 1)\n//   [[3, 2]],          // Node 1: edge to 3 (weight 2)\n//   [[1, 5], [3, 3]],  // Node 2: edges to 1, 3\n//   []                 // Node 3: no outgoing\n// ];\n// dijkstra(graph, 0, 4);  // [0, 4, 1, 4]\n\n// Note: For production, use a proper MinHeap implementation",
              "notes": "Sorting on each pop is O(n log n). Use proper heap for O(log n)."
            },
            "python": {
              "code": "import heapq\n\ndef dijkstra(graph, source, n):\n    # graph[u] = [(v, weight), ...]\n    dist = [float('inf')] * n\n    dist[source] = 0\n    \n    # Min-heap: (distance, node)\n    heap = [(0, source)]\n    visited = set()\n    \n    while heap:\n        d, u = heapq.heappop(heap)\n        \n        if u in visited:\n            continue\n        visited.add(u)\n        \n        for v, weight in graph[u]:\n            if v not in visited and dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heapq.heappush(heap, (dist[v], v))\n    \n    return dist\n\n# With path reconstruction\ndef dijkstra_with_path(graph, source, target, n):\n    dist = [float('inf')] * n\n    prev = [-1] * n\n    dist[source] = 0\n    \n    heap = [(0, source)]\n    visited = set()\n    \n    while heap:\n        d, u = heapq.heappop(heap)\n        \n        if u in visited:\n            continue\n        visited.add(u)\n        \n        if u == target:\n            break\n        \n        for v, weight in graph[u]:\n            if v not in visited and dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                prev[v] = u\n                heapq.heappush(heap, (dist[v], v))\n    \n    # Reconstruct path\n    path = []\n    node = target\n    while node != -1:\n        path.append(node)\n        node = prev[node]\n    \n    return dist[target], path[::-1]",
              "notes": "heapq is min-heap. Tuple (dist, node) orders by dist first."
            }
          },
          {
            "name": "Network Delay Time",
            "description": "Time for signal to reach all nodes from source",
            "javascript": {
              "code": "function networkDelayTime(times, n, k) {\n  // times[i] = [source, target, time]\n  // k = starting node (1-indexed)\n  \n  // Build adjacency list\n  const graph = new Map();\n  for (let i = 1; i <= n; i++) {\n    graph.set(i, []);\n  }\n  for (const [u, v, w] of times) {\n    graph.get(u).push([v, w]);\n  }\n  \n  // Dijkstra\n  const dist = new Map();\n  const heap = [[0, k]];\n  \n  while (heap.length > 0) {\n    heap.sort((a, b) => b[0] - a[0]);\n    const [d, u] = heap.pop();\n    \n    if (dist.has(u)) continue;\n    dist.set(u, d);\n    \n    for (const [v, w] of graph.get(u)) {\n      if (!dist.has(v)) {\n        heap.push([d + w, v]);\n      }\n    }\n  }\n  \n  // If not all nodes reached, return -1\n  if (dist.size !== n) return -1;\n  \n  // Maximum distance is when last node receives signal\n  return Math.max(...dist.values());\n}\n\n// Key insight: \"all nodes receive\" = max of shortest paths\n// If any node unreachable, return -1",
              "notes": "Max of all shortest distances = time for all to receive."
            },
            "python": {
              "code": "def network_delay_time(times, n, k):\n    # Build graph\n    graph = [[] for _ in range(n + 1)]\n    for u, v, w in times:\n        graph[u].append((v, w))\n    \n    # Dijkstra\n    dist = {}\n    heap = [(0, k)]\n    \n    while heap:\n        d, u = heapq.heappop(heap)\n        \n        if u in dist:\n            continue\n        dist[u] = d\n        \n        for v, w in graph[u]:\n            if v not in dist:\n                heapq.heappush(heap, (d + w, v))\n    \n    if len(dist) != n:\n        return -1\n    \n    return max(dist.values())",
              "notes": "1-indexed nodes. Return -1 if graph not fully connected."
            }
          },
          {
            "name": "Cheapest Flights Within K Stops",
            "description": "Modified Dijkstra with state = (cost, node, stops)",
            "javascript": {
              "code": "function findCheapestPrice(n, flights, src, dst, k) {\n  // Build graph\n  const graph = new Map();\n  for (let i = 0; i < n; i++) graph.set(i, []);\n  for (const [u, v, price] of flights) {\n    graph.get(u).push([v, price]);\n  }\n  \n  // State: (cost, node, stops used)\n  // Can visit same node multiple times with different stop counts\n  const heap = [[0, src, 0]];\n  const visited = new Map();  // node -> min stops to reach\n  \n  while (heap.length > 0) {\n    heap.sort((a, b) => b[0] - a[0]);\n    const [cost, node, stops] = heap.pop();\n    \n    if (node === dst) return cost;\n    \n    // Skip if we've reached this node with fewer stops\n    if (visited.has(node) && visited.get(node) <= stops) {\n      continue;\n    }\n    visited.set(node, stops);\n    \n    if (stops > k) continue;  // Can't use more stops\n    \n    for (const [next, price] of graph.get(node)) {\n      heap.push([cost + price, next, stops + 1]);\n    }\n  }\n  \n  return -1;\n}\n\n// Key insight: State includes stops count\n// Same node can be reached via different paths with different stop counts\n// We want cheapest with ‚â§ k stops, not just cheapest overall",
              "notes": "State = (cost, node, stops). Allows revisiting with different stops."
            },
            "python": {
              "code": "def find_cheapest_price(n, flights, src, dst, k):\n    graph = [[] for _ in range(n)]\n    for u, v, price in flights:\n        graph[u].append((v, price))\n    \n    # (cost, node, stops)\n    heap = [(0, src, 0)]\n    visited = {}  # node -> min stops when visited\n    \n    while heap:\n        cost, node, stops = heapq.heappop(heap)\n        \n        if node == dst:\n            return cost\n        \n        if node in visited and visited[node] <= stops:\n            continue\n        visited[node] = stops\n        \n        if stops > k:\n            continue\n        \n        for next_node, price in graph[node]:\n            heapq.heappush(heap, (cost + price, next_node, stops + 1))\n    \n    return -1",
              "notes": "k stops = k+1 edges. Careful with off-by-one."
            }
          }
        ],
        "visualTrace": {
          "title": "Dijkstra from A",
          "input": {
            "graph": "A‚ÜíB(4), A‚ÜíC(1), B‚ÜíD(2), C‚ÜíB(5), C‚ÜíD(3)"
          },
          "steps": [
            {
              "step": 1,
              "heap": "[(0,A)]",
              "dist": "{A:0, B:‚àû, C:‚àû, D:‚àû}",
              "action": "Start"
            },
            {
              "step": 2,
              "pop": "(0,A)",
              "heap": "[(1,C), (4,B)]",
              "dist": "{A:0, B:4, C:1, D:‚àû}",
              "action": "Process A, relax A‚ÜíB, A‚ÜíC"
            },
            {
              "step": 3,
              "pop": "(1,C)",
              "heap": "[(4,B), (4,D), (6,B)]",
              "dist": "{A:0, B:4, C:1, D:4}",
              "action": "Process C, relax C‚ÜíB(no improve), C‚ÜíD"
            },
            {
              "step": 4,
              "pop": "(4,B)",
              "heap": "[(4,D), (6,B), (6,D)]",
              "dist": "{A:0, B:4, C:1, D:4}",
              "action": "Process B, relax B‚ÜíD(no improve)"
            },
            {
              "step": 5,
              "pop": "(4,D)",
              "action": "Process D, done",
              "final": "{A:0, B:4, C:1, D:4}"
            }
          ],
          "output": "Shortest distances from A: A=0, B=4 (A‚ÜíB), C=1 (A‚ÜíC), D=4 (A‚ÜíC‚ÜíD)"
        },
        "commonMistakes": [
          {
            "mistake": "Not handling already-visited nodes",
            "wrong": "Always process popped node",
            "right": "Skip if in visited set",
            "explanation": "Heap may contain outdated entries. Skip already-finalized nodes."
          },
          {
            "mistake": "Using with negative weights",
            "wrong": "Apply Dijkstra to graph with -5 edge",
            "right": "Use Bellman-Ford for negative weights",
            "explanation": "Dijkstra's greedy assumption fails with negative edges."
          },
          {
            "mistake": "Not initializing distances to infinity",
            "wrong": "dist = [0, 0, 0, ...]",
            "right": "dist = [Inf, Inf, ...]; dist[source] = 0",
            "explanation": "Initial 0 means 'already reached', blocking proper updates."
          }
        ],
        "keyTakeaways": [
          "Dijkstra = greedy shortest path for non-negative edge weights",
          "Uses min-heap to always process closest unvisited node",
          "Relaxation: dist[v] = min(dist[v], dist[u] + weight(u,v))",
          "O((V+E) log V) with binary heap",
          "FAILS with negative edges - use Bellman-Ford instead",
          "Visited set or lazy deletion handles duplicate heap entries"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "graph",
              "label": "Graphs",
              "why": "Operates on weighted graphs"
            },
            {
              "id": "heap",
              "label": "Heap/Priority Queue",
              "why": "Efficient min extraction"
            },
            {
              "id": "bfs",
              "label": "BFS",
              "why": "Dijkstra is weighted BFS"
            }
          ],
          "nextTopics": [
            {
              "id": "bellman_ford",
              "label": "Bellman-Ford",
              "why": "Handles negative weights"
            },
            {
              "id": "a_star",
              "label": "A* Search",
              "why": "Dijkstra + heuristic"
            },
            {
              "id": "floyd_warshall",
              "label": "Floyd-Warshall",
              "why": "All-pairs shortest path"
            }
          ]
        },
        "patternChain": {
          "description": "Dijkstra is foundational for weighted graph path problems",
          "buildsOn": [
            {
              "id": "graph",
              "relationship": "Operates on weighted graphs",
              "whatToKnow": "Adjacency list with weights"
            },
            {
              "id": "heap",
              "relationship": "Min-heap for greedy selection",
              "whatToKnow": "Priority queue operations"
            },
            {
              "id": "greedy",
              "relationship": "Greedy algorithm paradigm",
              "whatToKnow": "Local optimal ‚Üí global optimal"
            }
          ],
          "enables": [
            {
              "id": "network_delay",
              "relationship": "Max of shortest paths",
              "patternName": "Network Delay Time",
              "interviewFrequency": "High"
            },
            {
              "id": "cheapest_flights",
              "relationship": "State = (cost, node, constraint)",
              "patternName": "Constrained Shortest Path",
              "interviewFrequency": "High"
            },
            {
              "id": "path_minimum_effort",
              "relationship": "Min max edge instead of sum",
              "patternName": "Min-Max Path",
              "interviewFrequency": "Medium"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    GRAPH[Graphs] --> DIJ[Dijkstra]\n    HEAP[Heap] --> DIJ\n    GREEDY[Greedy] --> DIJ\n    DIJ --> NET[Network Delay]\n    DIJ --> FLIGHTS[Cheapest Flights]\n    DIJ --> ASTAR[A* Search]\n    \n    style DIJ fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "topo_sort",
      "label": "Topological Sort",
      "type": "algo-graph",
      "description": "Linear ordering of dependencies.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Topological_sorting"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/dfsbfs"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/topological-sort/"
          },
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/topological-sort.html"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "3-4 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft"
      ],
      "interviewFrequency": "medium",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "interviewQuestions": [
        {
          "name": "Course Schedule",
          "leetcode": "https://leetcode.com/problems/course-schedule/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Meta",
            "Google",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Cycle detection = topological sort feasibility",
          "approach": "Kahn's BFS (indegree) or DFS with 3 colors. If processed != numCourses, cycle exists",
          "followUps": [
            {
              "question": "Return valid order (II)?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Minimum semesters?",
              "answer": "Topo sort by levels. Count levels = minimum semesters. Process all 0-indegree nodes together."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Course Schedule II",
          "leetcode": "https://leetcode.com/problems/course-schedule-ii/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Meta",
            "Google",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Return actual topological order",
          "approach": "Kahn's: process nodes with indegree 0, add to result. Or DFS postorder reverse",
          "followUps": [
            {
              "question": "All possible orders?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Parallel courses?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Alien Dictionary",
          "leetcode": "https://leetcode.com/problems/alien-dictionary/",
          "difficulty": "Hard",
          "companies": [
            "Meta",
            "Google",
            "Amazon",
            "Airbnb"
          ],
          "frequency": "Very High",
          "whyAsked": "Build graph from word ordering, then topo sort",
          "approach": "Compare adjacent words for edge. Topo sort. Handle invalid input (prefix violation)",
          "followUps": [
            {
              "question": "Multiple valid orderings?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Verify given order?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "teamblind"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Blind (Teamblind)",
              "url": "https://www.teamblind.com/",
              "note": "Crowdsourced FAANG interview experiences"
            }
          ]
        },
        {
          "name": "Parallel Courses",
          "leetcode": "https://leetcode.com/problems/parallel-courses/",
          "difficulty": "Medium",
          "companies": [
            "Google",
            "Amazon"
          ],
          "frequency": "Medium",
          "whyAsked": "BFS topo sort counting levels = semesters",
          "approach": "Kahn's BFS level by level. Count levels until all processed. If can't, return -1",
          "followUps": [
            {
              "question": "With course limit per semester?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Minimum Height Trees",
          "leetcode": "https://leetcode.com/problems/minimum-height-trees/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Google"
          ],
          "frequency": "Medium",
          "whyAsked": "Topological peeling from leaves to find center(s)",
          "approach": "Remove leaves layer by layer. Remaining 1-2 nodes are roots of MHTs",
          "followUps": [
            {
              "question": "Tree diameter relation?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with videos"
        },
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based categorization"
        }
      ],
      "content": {
        "definition": {
          "simple": "Topological Sort orders tasks so that every task comes after its dependencies. Like a course schedule - you can't take Advanced Math before Basic Math. It's a linear ordering where all 'prerequisites' come first.",
          "technical": "Topological sorting of a directed acyclic graph (DAG) is a linear ordering of vertices such that for every directed edge (u, v), vertex u appears before v in the ordering. Only possible when graph has no cycles."
        },
        "howItWorks": {
          "explanation": "Imagine scheduling courses with prerequisites. Start with courses that have no prerequisites (in-degree 0). Complete one, which may unlock others. Repeat until all courses are scheduled. If you can't schedule all, there's a cycle (impossible to satisfy).",
          "steps": [
            {
              "step": 1,
              "title": "Build Graph",
              "description": "Create adjacency list and track in-degrees.",
              "why": "In-degree = number of prerequisites."
            },
            {
              "step": 2,
              "title": "Initialize Queue",
              "description": "Add all nodes with in-degree 0.",
              "why": "These have no prerequisites, can start."
            },
            {
              "step": 3,
              "title": "Process Queue (BFS)",
              "description": "Remove node, add to result, decrement neighbors' in-degrees.",
              "why": "Completing a prereq unlocks dependents."
            },
            {
              "step": 4,
              "title": "Queue New Zeros",
              "description": "If neighbor's in-degree becomes 0, add to queue.",
              "why": "All its prerequisites are now met."
            },
            {
              "step": 5,
              "title": "Check Completion",
              "description": "If all nodes processed, return order. Else, cycle exists.",
              "why": "Remaining nodes have unmet dependencies (cycle)."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph LR\n    A[Math 101] --> B[Math 201]\n    A --> C[Physics 101]\n    B --> D[Math 301]\n    C --> D\n    C --> E[Physics 201]\n    \n    style A fill:#98c1d9\n    style D fill:#ee6c4d",
            "caption": "Course prereqs. Valid order: Math101 ‚Üí Math201 ‚Üí Physics101 ‚Üí Math301 ‚Üí Physics201"
          }
        },
        "whenToUse": {
          "summary": "Use when you need to order items with dependencies, or detect if such ordering is possible (cycle detection in DAG).",
          "patterns": [
            {
              "pattern": "Task Scheduling",
              "signal": "Tasks with dependencies",
              "example": "Build systems (make, webpack), CI/CD pipelines",
              "withoutIt": "Manual dependency tracking",
              "withIt": "Automatic valid order"
            },
            {
              "pattern": "Course Schedule",
              "signal": "Prerequisites for courses/modules",
              "example": "Can you finish all courses?",
              "withoutIt": "Check each course individually",
              "withIt": "Single pass detects cycles and gives order"
            },
            {
              "pattern": "Compile Order",
              "signal": "Source files with imports",
              "example": "What order to compile files?",
              "withoutIt": "Trial and error",
              "withIt": "Dependency-respecting order"
            },
            {
              "pattern": "Package Installation",
              "signal": "Packages with dependencies",
              "example": "npm, pip install order",
              "withoutIt": "May fail on missing dependency",
              "withIt": "Install deps before dependents"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Only works on DAGs. Cyclic dependencies have no valid ordering.",
          "antiPatterns": [
            {
              "situation": "Cyclic Dependencies",
              "why": "No valid topological order exists",
              "useInstead": "Detect cycle and report error",
              "example": "A requires B, B requires A"
            },
            {
              "situation": "Undirected Graphs",
              "why": "Every edge is bidirectional (cycle)",
              "useInstead": "Different problem - use tree/component algos",
              "example": "Friend relationships"
            },
            {
              "situation": "Need Shortest Path",
              "why": "Topo sort gives order, not distances",
              "useInstead": "Dijkstra or DP on DAG",
              "example": "Shortest path in DAG (though topo sort can help)"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "Getting Dressed",
            "story": "You can't put on shoes before socks, or jacket before shirt. Some items (underwear, socks) have no prerequisites - start with those. Once shirt is on, jacket becomes available. Topological sort finds A valid dressing order (not the only one).",
            "connection": "Each clothing item is a node. 'Must wear X before Y' is an edge X ‚Üí Y. In-degree 0 items can be worn now. Completing one may enable others."
          },
          "keyInsight": "Topological sort is BFS where we only process a node when ALL its dependencies are processed (in-degree becomes 0). This guarantees valid ordering.",
          "commonConfusion": [
            {
              "confusion": "Is there only one valid order?",
              "clarification": "No! Many valid orderings may exist. Topo sort gives ONE valid order. Different tie-breaking gives different orders."
            },
            {
              "confusion": "How to detect cycles?",
              "clarification": "If we can't process all nodes (some always have in-degree > 0), there's a cycle among remaining nodes."
            },
            {
              "confusion": "BFS vs DFS for topo sort?",
              "clarification": "Both work! BFS (Kahn's): process in-degree 0 nodes. DFS: post-order traversal reversed. Same result."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Build graph + in-degrees",
                "average": "O(V + E)",
                "worst": "O(V + E)",
                "note": "One pass through edges"
              },
              {
                "operation": "Kahn's BFS",
                "average": "O(V + E)",
                "worst": "O(V + E)",
                "note": "Visit each node and edge once"
              },
              {
                "operation": "DFS approach",
                "average": "O(V + E)",
                "worst": "O(V + E)",
                "note": "Standard DFS complexity"
              }
            ],
            "explanation": "Linear in graph size - optimal."
          },
          "space": {
            "complexity": "O(V + E)",
            "explanation": "Adjacency list (E) + queue/stack (V) + in-degree array (V)."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Kahn's algorithm uses queue and in-degree array. DFS uses recursion stack and visited set.",
            "keyPoints": [
              "Adjacency list: Map/Object with node ‚Üí [neighbors]",
              "In-degree array: count of incoming edges",
              "Queue (BFS) or Stack (DFS) for processing order",
              "Result array: nodes in topological order"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Map for adjacency list, Array for in-degrees and result.",
              "gotchas": [
                "Initialize in-degrees for ALL nodes (even if 0)",
                "Use shift() for queue (or better: pointer-based for O(1))",
                "Map.get() returns undefined for missing keys"
              ]
            },
            "python": {
              "implementation": "defaultdict(list) for graph, collections.deque for queue.",
              "gotchas": [
                "deque.popleft() is O(1), list.pop(0) is O(n)",
                "Initialize in_degree dict with all nodes",
                "Can use Counter for in-degrees"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Kahn's algorithm produces valid topological order",
            "proof": {
              "step1": {
                "action": "Node with in-degree 0 has no unsatisfied dependencies",
                "cost": "Can be placed first"
              },
              "step2": {
                "action": "Removing node decrements neighbors' in-degrees",
                "cost": "Simulates 'completing' the dependency"
              },
              "step3": {
                "action": "New in-degree 0 nodes had only the removed node as dependency",
                "cost": "Now safe to process"
              },
              "step4": {
                "action": "All nodes processed ‚Üí all dependencies satisfied in order",
                "cost": "Valid topological order"
              }
            },
            "totalCost": "O(V + E)"
          }
        },
        "codeTemplates": [
          {
            "name": "Kahn's Algorithm (BFS)",
            "description": "BFS-based topological sort with cycle detection",
            "javascript": {
              "code": "function topologicalSort(numNodes, edges) {\n  // Build adjacency list and in-degrees\n  const graph = new Map();\n  const inDegree = new Array(numNodes).fill(0);\n  \n  for (let i = 0; i < numNodes; i++) {\n    graph.set(i, []);\n  }\n  \n  for (const [from, to] of edges) {\n    graph.get(from).push(to);\n    inDegree[to]++;\n  }\n  \n  // Queue nodes with no dependencies\n  const queue = [];\n  for (let i = 0; i < numNodes; i++) {\n    if (inDegree[i] === 0) {\n      queue.push(i);\n    }\n  }\n  \n  const result = [];\n  \n  while (queue.length > 0) {\n    const node = queue.shift();\n    result.push(node);\n    \n    for (const neighbor of graph.get(node)) {\n      inDegree[neighbor]--;\n      if (inDegree[neighbor] === 0) {\n        queue.push(neighbor);\n      }\n    }\n  }\n  \n  // If not all nodes processed, cycle exists\n  if (result.length !== numNodes) {\n    return null;  // Or throw error\n  }\n  \n  return result;\n}\n\n// Example: Course Schedule\n// Courses 0-3, prereqs: [[1,0], [2,0], [3,1], [3,2]]\n// Means: 0 before 1, 0 before 2, 1 before 3, 2 before 3\n// Valid order: [0, 1, 2, 3] or [0, 2, 1, 3]",
              "notes": "Return null if cycle detected (can't complete all courses)."
            },
            "python": {
              "code": "from collections import deque, defaultdict\n\ndef topological_sort(num_nodes, edges):\n    graph = defaultdict(list)\n    in_degree = [0] * num_nodes\n    \n    for src, dst in edges:\n        graph[src].append(dst)\n        in_degree[dst] += 1\n    \n    queue = deque()\n    for i in range(num_nodes):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    result = []\n    \n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        \n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    if len(result) != num_nodes:\n        return None  # Cycle detected\n    \n    return result",
              "notes": "deque for O(1) popleft. defaultdict avoids KeyError."
            }
          },
          {
            "name": "Course Schedule II",
            "description": "Return order to take courses, or empty if impossible",
            "javascript": {
              "code": "function findOrder(numCourses, prerequisites) {\n  // prerequisites[i] = [course, prereq] means prereq ‚Üí course\n  const graph = new Map();\n  const inDegree = new Array(numCourses).fill(0);\n  \n  for (let i = 0; i < numCourses; i++) {\n    graph.set(i, []);\n  }\n  \n  for (const [course, prereq] of prerequisites) {\n    graph.get(prereq).push(course);\n    inDegree[course]++;\n  }\n  \n  const queue = [];\n  for (let i = 0; i < numCourses; i++) {\n    if (inDegree[i] === 0) queue.push(i);\n  }\n  \n  const order = [];\n  \n  while (queue.length > 0) {\n    const course = queue.shift();\n    order.push(course);\n    \n    for (const next of graph.get(course)) {\n      inDegree[next]--;\n      if (inDegree[next] === 0) {\n        queue.push(next);\n      }\n    }\n  }\n  \n  return order.length === numCourses ? order : [];\n}\n\n// Course Schedule I: just check if possible\nfunction canFinish(numCourses, prerequisites) {\n  return findOrder(numCourses, prerequisites).length === numCourses;\n}",
              "notes": "Edge direction: prereq ‚Üí course (prereq must come first)."
            },
            "python": {
              "code": "def find_order(num_courses, prerequisites):\n    graph = defaultdict(list)\n    in_degree = [0] * num_courses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        in_degree[course] += 1\n    \n    queue = deque(i for i in range(num_courses) if in_degree[i] == 0)\n    order = []\n    \n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        \n        for next_course in graph[course]:\n            in_degree[next_course] -= 1\n            if in_degree[next_course] == 0:\n                queue.append(next_course)\n    \n    return order if len(order) == num_courses else []\n\ndef can_finish(num_courses, prerequisites):\n    return len(find_order(num_courses, prerequisites)) == num_courses",
              "notes": "Generator expression for initial queue population."
            }
          },
          {
            "name": "DFS-based Topological Sort",
            "description": "Alternative using DFS post-order",
            "javascript": {
              "code": "function topologicalSortDFS(numNodes, edges) {\n  const graph = new Map();\n  for (let i = 0; i < numNodes; i++) {\n    graph.set(i, []);\n  }\n  for (const [from, to] of edges) {\n    graph.get(from).push(to);\n  }\n  \n  const WHITE = 0, GRAY = 1, BLACK = 2;\n  const color = new Array(numNodes).fill(WHITE);\n  const result = [];\n  let hasCycle = false;\n  \n  function dfs(node) {\n    if (hasCycle) return;\n    \n    color[node] = GRAY;  // Processing\n    \n    for (const neighbor of graph.get(node)) {\n      if (color[neighbor] === GRAY) {\n        hasCycle = true;  // Back edge = cycle\n        return;\n      }\n      if (color[neighbor] === WHITE) {\n        dfs(neighbor);\n      }\n    }\n    \n    color[node] = BLACK;  // Done\n    result.push(node);    // Post-order\n  }\n  \n  for (let i = 0; i < numNodes; i++) {\n    if (color[i] === WHITE) {\n      dfs(i);\n    }\n  }\n  \n  if (hasCycle) return null;\n  return result.reverse();  // Reverse post-order\n}\n\n// Three colors:\n// WHITE (0): unvisited\n// GRAY (1): in current DFS path (ancestor)\n// BLACK (2): fully processed\n// If we see GRAY neighbor, it's a back edge ‚Üí cycle!",
              "notes": "GRAY node in DFS path = cycle. Reverse post-order = topo order."
            },
            "python": {
              "code": "def topological_sort_dfs(num_nodes, edges):\n    graph = defaultdict(list)\n    for src, dst in edges:\n        graph[src].append(dst)\n    \n    WHITE, GRAY, BLACK = 0, 1, 2\n    color = [WHITE] * num_nodes\n    result = []\n    has_cycle = False\n    \n    def dfs(node):\n        nonlocal has_cycle\n        if has_cycle:\n            return\n        \n        color[node] = GRAY\n        \n        for neighbor in graph[node]:\n            if color[neighbor] == GRAY:\n                has_cycle = True\n                return\n            if color[neighbor] == WHITE:\n                dfs(neighbor)\n        \n        color[node] = BLACK\n        result.append(node)\n    \n    for i in range(num_nodes):\n        if color[i] == WHITE:\n            dfs(i)\n    \n    if has_cycle:\n        return None\n    \n    return result[::-1]",
              "notes": "nonlocal for modifying has_cycle in nested function."
            }
          }
        ],
        "visualTrace": {
          "title": "Kahn's Algorithm on Course Graph",
          "input": {
            "courses": 4,
            "prereqs": "[[1,0], [2,0], [3,1], [3,2]]"
          },
          "steps": [
            {
              "step": "Build",
              "graph": "{0‚Üí[1,2], 1‚Üí[3], 2‚Üí[3]}",
              "inDegree": "[0,1,1,2]"
            },
            {
              "step": "Init Queue",
              "queue": "[0]",
              "result": "[]",
              "note": "Only 0 has in-degree 0"
            },
            {
              "step": "Process 0",
              "queue": "[1,2]",
              "result": "[0]",
              "note": "Decrement 1,2 in-degrees ‚Üí both become 0"
            },
            {
              "step": "Process 1",
              "queue": "[2]",
              "result": "[0,1]",
              "note": "Decrement 3's in-degree: 2‚Üí1"
            },
            {
              "step": "Process 2",
              "queue": "[3]",
              "result": "[0,1,2]",
              "note": "Decrement 3's in-degree: 1‚Üí0"
            },
            {
              "step": "Process 3",
              "queue": "[]",
              "result": "[0,1,2,3]",
              "note": "Done!"
            }
          ],
          "output": "Valid order: [0, 1, 2, 3]. All 4 courses can be completed."
        },
        "commonMistakes": [
          {
            "mistake": "Wrong edge direction",
            "wrong": "[course, prereq] as course ‚Üí prereq",
            "right": "[course, prereq] as prereq ‚Üí course",
            "explanation": "Edge should point from dependency TO dependent."
          },
          {
            "mistake": "Not initializing all nodes",
            "wrong": "Only add nodes that appear in edges",
            "right": "Initialize all nodes 0 to n-1",
            "explanation": "Isolated nodes have in-degree 0, should be in result."
          },
          {
            "mistake": "Using list.pop(0) in Python",
            "wrong": "queue.pop(0)  # O(n)",
            "right": "collections.deque().popleft()  # O(1)",
            "explanation": "List pop from front is O(n), deque is O(1)."
          }
        ],
        "keyTakeaways": [
          "Topological sort = linear ordering respecting dependencies",
          "Only works on DAGs (Directed Acyclic Graphs)",
          "Kahn's (BFS): process in-degree 0 nodes, decrement neighbors",
          "DFS: reverse post-order gives topological order",
          "Cycle detection: if not all nodes processed, cycle exists",
          "Multiple valid orderings may exist - algorithm gives one"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "graph",
              "label": "Graphs",
              "why": "Operates on directed graphs"
            },
            {
              "id": "bfs",
              "label": "BFS",
              "why": "Kahn's algorithm is BFS-based"
            },
            {
              "id": "dfs",
              "label": "DFS",
              "why": "Alternative approach uses DFS"
            }
          ],
          "nextTopics": [
            {
              "id": "shortest_path_dag",
              "label": "Shortest Path in DAG",
              "why": "Uses topo sort + DP"
            },
            {
              "id": "critical_path",
              "label": "Critical Path Method",
              "why": "Project scheduling"
            },
            {
              "id": "scc",
              "label": "Strongly Connected Components",
              "why": "Related graph decomposition"
            }
          ]
        },
        "patternChain": {
          "description": "Topological sort is foundation for DAG-based algorithms",
          "buildsOn": [
            {
              "id": "graph",
              "relationship": "Operates on directed graphs",
              "whatToKnow": "Adjacency list representation"
            },
            {
              "id": "bfs",
              "relationship": "Kahn's uses BFS queue processing",
              "whatToKnow": "Level-order processing"
            }
          ],
          "enables": [
            {
              "id": "course_schedule",
              "relationship": "Can all courses be finished?",
              "patternName": "Course Schedule",
              "interviewFrequency": "Very High"
            },
            {
              "id": "build_order",
              "relationship": "Compile/build dependencies",
              "patternName": "Build Order",
              "interviewFrequency": "High"
            },
            {
              "id": "alien_dictionary",
              "relationship": "Derive alphabet order",
              "patternName": "Alien Dictionary",
              "interviewFrequency": "High"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    GRAPH[Graphs] --> TOPO[Topological Sort]\n    BFS[BFS] --> TOPO\n    DFS[DFS] --> TOPO\n    TOPO --> COURSE[Course Schedule]\n    TOPO --> BUILD[Build Order]\n    TOPO --> ALIEN[Alien Dictionary]\n    \n    style TOPO fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "backtracking",
      "label": "Backtracking",
      "type": "algo-pattern",
      "description": "Exploring all possibilities.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Backtracking"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/backtracking/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/backtracking-algorithms/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "4-5 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft"
      ],
      "interviewFrequency": "high",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "interviewQuestions": [
        {
          "name": "Subsets",
          "leetcode": "https://leetcode.com/problems/subsets/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Classic backtracking template - power set generation",
          "approach": "At each index, choose to include or exclude. Recurse. Base: add current subset when idx = n",
          "followUps": [
            {
              "question": "With duplicates (Subsets II)?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Iterative approach?",
              "answer": "Use explicit stack with state. More complex but avoids recursion limit issues."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Permutations",
          "leetcode": "https://leetcode.com/problems/permutations/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Core backtracking - generating all orderings",
          "approach": "Swap current with each remaining element. Recurse. Backtrack by swapping back",
          "followUps": [
            {
              "question": "With duplicates?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Next permutation?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Kth permutation?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Combination Sum",
          "leetcode": "https://leetcode.com/problems/combination-sum/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Meta",
            "Google"
          ],
          "frequency": "Very High",
          "whyAsked": "Backtracking with reuse - combinations that sum to target",
          "approach": "Start from each index, subtract from target, recurse. Same element can be reused",
          "followUps": [
            {
              "question": "Each number used once (II)?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Exactly k numbers (III)?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "N-Queens",
          "leetcode": "https://leetcode.com/problems/n-queens/",
          "difficulty": "Hard",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Microsoft"
          ],
          "frequency": "High",
          "whyAsked": "Classic constraint satisfaction with backtracking",
          "approach": "Place queen row by row. Track cols, diagonals in sets. Backtrack if no valid position",
          "followUps": [
            {
              "question": "Count solutions only?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Return any one solution?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Word Search",
          "leetcode": "https://leetcode.com/problems/word-search/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Meta",
            "Microsoft",
            "Bloomberg"
          ],
          "frequency": "Very High",
          "whyAsked": "Grid backtracking - find word path in matrix",
          "approach": "DFS from each cell. Mark visited. Backtrack by unmarking. O(m*n*4^L)",
          "followUps": [
            {
              "question": "Multiple words (Word Search II)?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Optimize with Trie?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Palindrome Partitioning",
          "leetcode": "https://leetcode.com/problems/palindrome-partitioning/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google"
          ],
          "frequency": "Medium",
          "whyAsked": "Backtracking with dynamic constraint checking",
          "approach": "For each prefix, if palindrome, add to path and recurse on remainder. Backtrack",
          "followUps": [
            {
              "question": "Minimum cuts (Palindrome Partitioning II)?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with videos"
        },
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based categorization"
        }
      ],
      "content": {
        "definition": {
          "simple": "Backtracking is trying every possibility, but abandoning a path as soon as you know it won't work. It's like navigating a maze - if you hit a dead end, you back up and try another path.",
          "technical": "Backtracking is a recursive algorithmic paradigm that incrementally builds candidates to solutions and abandons ('backtracks') a candidate as soon as it determines the candidate cannot possibly lead to a valid solution."
        },
        "howItWorks": {
          "explanation": "Imagine solving a Sudoku. You try a number in an empty cell. If it works so far, you move to the next cell. If you get stuck (no valid number), you go back and try a different number in the previous cell. This 'try-fail-undo-try again' is backtracking.",
          "steps": [
            {
              "step": 1,
              "title": "Choose",
              "description": "Make a choice from available options.",
              "why": "Commit to trying one path."
            },
            {
              "step": 2,
              "title": "Constraint Check",
              "description": "Verify the choice doesn't violate constraints.",
              "why": "Prune invalid paths early."
            },
            {
              "step": 3,
              "title": "Recurse",
              "description": "Proceed to the next decision point.",
              "why": "Continue building the solution."
            },
            {
              "step": 4,
              "title": "Goal Check",
              "description": "If solution complete, record it.",
              "why": "Found valid solution!"
            },
            {
              "step": 5,
              "title": "Backtrack",
              "description": "Undo the choice and try next option.",
              "why": "Explore alternative paths."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph TD\n    START[Start] --> A{Choose A}\n    A -->|Try| AB{Choose B}\n    AB -->|Invalid| A\n    A -->|Try| AC{Choose C}\n    AC -->|Valid| SUCCESS[Solution Found]\n    A -->|No more options| BACK[Backtrack to parent]\n    \n    style SUCCESS fill:#98c1d9\n    style BACK fill:#ee6c4d",
            "caption": "Backtracking tree: choose ‚Üí validate ‚Üí recurse or backtrack"
          }
        },
        "whenToUse": {
          "summary": "Use when you need to find ALL solutions or the FIRST valid solution among many possibilities with constraints.",
          "patterns": [
            {
              "pattern": "Permutations/Combinations",
              "signal": "Generate all arrangements",
              "example": "All permutations of [1,2,3]",
              "withoutIt": "n! nested loops (impossible)",
              "withIt": "Recursive enumeration with pruning"
            },
            {
              "pattern": "Constraint Satisfaction",
              "signal": "Fill in values satisfying rules",
              "example": "Sudoku, N-Queens, crossword",
              "withoutIt": "Brute force all 9^81 combinations",
              "withIt": "Prune invalid branches early"
            },
            {
              "pattern": "Path Finding",
              "signal": "Find path through maze/graph",
              "example": "Maze solving, word search",
              "withoutIt": "Visit same cells repeatedly",
              "withIt": "Mark visited, backtrack, unmark"
            },
            {
              "pattern": "Subset Sum/Partition",
              "signal": "Find subset satisfying condition",
              "example": "Subset sum, partition equal subset sum",
              "withoutIt": "2^n subsets to check",
              "withIt": "Prune when sum exceeds target"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Backtracking is exhaustive search - exponential in worst case. Avoid when DP or greedy gives optimal solution.",
          "antiPatterns": [
            {
              "situation": "Optimization with Optimal Substructure",
              "why": "DP is more efficient",
              "useInstead": "Dynamic Programming",
              "example": "Shortest path, knapsack"
            },
            {
              "situation": "Greedy Choice Property",
              "why": "Greedy is O(n log n)",
              "useInstead": "Greedy Algorithm",
              "example": "Activity selection, Huffman"
            },
            {
              "situation": "Only Need ONE Solution (and it's structured)",
              "why": "BFS/DFS may find faster",
              "useInstead": "BFS/DFS",
              "example": "First path in graph"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Maze Explorer",
            "story": "You're in a maze. At each junction, you pick a path and drop a breadcrumb. If you hit a dead end, you follow breadcrumbs back to the last junction and try a different path. You pick up breadcrumbs as you backtrack so you don't revisit dead ends.",
            "connection": "In code: 'drop breadcrumb' = add to current path, 'follow back' = recursive call returns, 'pick up breadcrumb' = remove from path (backtrack)."
          },
          "keyInsight": "The power of backtracking is PRUNING. By checking constraints early, we avoid exploring vast numbers of invalid paths. Without pruning, it's just brute force.",
          "commonConfusion": [
            {
              "confusion": "Backtracking vs DFS?",
              "clarification": "Backtracking IS DFS, but with constraint checking and state restoration. DFS just visits all nodes; backtracking abandons invalid branches."
            },
            {
              "confusion": "When to use vs DP?",
              "clarification": "DP for optimization (min/max) with overlapping subproblems. Backtracking for enumeration (find ALL) or satisfaction (find ANY valid)."
            },
            {
              "confusion": "How to design the recursion?",
              "clarification": "Identify: What's a decision? What are constraints? When is solution complete? Template: for each choice { make it ‚Üí recurse ‚Üí undo it }"
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Permutations",
                "average": "O(n!)",
                "worst": "O(n!)",
                "note": "n choices √ó (n-1) √ó ... √ó 1"
              },
              {
                "operation": "Subsets",
                "average": "O(2^n)",
                "worst": "O(2^n)",
                "note": "Include or exclude each element"
              },
              {
                "operation": "N-Queens",
                "average": "O(n!)",
                "worst": "O(n!)",
                "note": "With heavy pruning in practice"
              }
            ],
            "explanation": "Exponential or factorial, but pruning reduces actual work dramatically."
          },
          "space": {
            "complexity": "O(n) for recursion depth + O(n) for current path",
            "explanation": "Stack depth is at most n (one decision per level)."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Backtracking maintains 'current state' during exploration. Key is proper state restoration.",
            "keyPoints": [
              "Current path/solution stored (array or set)",
              "Each recursive call modifies state",
              "On return, state MUST be restored (backtrack)",
              "Pruning conditions check validity before recursing"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Typically use array for path, Set for 'used' tracking.",
              "gotchas": [
                "Clone arrays when saving solutions: result.push([...path])",
                "Remember to pop() after recursion returns",
                "For objects, may need deep clone"
              ]
            },
            "python": {
              "implementation": "Lists for paths, sets for visited/used.",
              "gotchas": [
                "Append path.copy() or path[:] to results",
                "list.pop() to backtrack",
                "set.add() and set.remove() for membership"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Backtracking with pruning < Brute force",
            "proof": {
              "step1": {
                "action": "Brute force checks ALL possible configurations",
                "cost": "Exponential (2^n, n!, etc.)"
              },
              "step2": {
                "action": "Backtracking adds constraint checks at each step",
                "cost": "O(constraint check) per node"
              },
              "step3": {
                "action": "Invalid branches are never explored",
                "cost": "Saves all work in that subtree"
              },
              "step4": {
                "action": "Good pruning can eliminate 99%+ of search space",
                "cost": "Practical speedup enormous"
              }
            },
            "totalCost": "Still exponential worst case, but average case much better"
          }
        },
        "codeTemplates": [
          {
            "name": "Backtracking Template",
            "description": "The universal pattern for all backtracking problems",
            "javascript": {
              "code": "function backtrack(result, current, choices, constraints) {\n  // Base case: solution complete\n  if (isSolution(current)) {\n    result.push([...current]);  // CLONE!\n    return;\n  }\n  \n  // Try each choice\n  for (const choice of choices) {\n    // Pruning: skip invalid choices\n    if (!isValid(choice, current, constraints)) {\n      continue;\n    }\n    \n    // 1. Choose\n    current.push(choice);\n    markUsed(choice);\n    \n    // 2. Explore\n    backtrack(result, current, choices, constraints);\n    \n    // 3. Unchoose (BACKTRACK!)\n    current.pop();\n    unmarkUsed(choice);\n  }\n}\n\n// Key insight: The 3-step pattern\n// CHOOSE ‚Üí EXPLORE ‚Üí UNCHOOSE\n// This is the heart of backtracking.",
              "notes": "Template: choose, explore, unchoose. Clone when saving solutions!"
            },
            "python": {
              "code": "def backtrack(result, current, choices, constraints):\n    # Base case: solution complete\n    if is_solution(current):\n        result.append(current[:])  # COPY!\n        return\n    \n    # Try each choice\n    for choice in choices:\n        # Pruning: skip invalid choices\n        if not is_valid(choice, current, constraints):\n            continue\n        \n        # 1. Choose\n        current.append(choice)\n        mark_used(choice)\n        \n        # 2. Explore\n        backtrack(result, current, choices, constraints)\n        \n        # 3. Unchoose (BACKTRACK!)\n        current.pop()\n        unmark_used(choice)",
              "notes": "Use current[:] or current.copy() to avoid reference issues."
            }
          },
          {
            "name": "N-Queens Problem",
            "description": "Place N queens on NxN board with no attacks",
            "javascript": {
              "code": "function solveNQueens(n) {\n  const result = [];\n  const board = Array.from({ length: n }, () => \n    Array(n).fill('.')\n  );\n  \n  // Track which columns and diagonals are attacked\n  const cols = new Set();\n  const diag1 = new Set();  // row - col\n  const diag2 = new Set();  // row + col\n  \n  function backtrack(row) {\n    // Base: placed all queens\n    if (row === n) {\n      result.push(board.map(r => r.join('')));\n      return;\n    }\n    \n    for (let col = 0; col < n; col++) {\n      // Pruning: check if position is attacked\n      if (cols.has(col) || \n          diag1.has(row - col) || \n          diag2.has(row + col)) {\n        continue;\n      }\n      \n      // Choose\n      board[row][col] = 'Q';\n      cols.add(col);\n      diag1.add(row - col);\n      diag2.add(row + col);\n      \n      // Explore\n      backtrack(row + 1);\n      \n      // Unchoose\n      board[row][col] = '.';\n      cols.delete(col);\n      diag1.delete(row - col);\n      diag2.delete(row + col);\n    }\n  }\n  \n  backtrack(0);\n  return result;\n}\n\n// N-Queens insight:\n// - Go row by row (each queen in different row)\n// - Track columns and both diagonals\n// - row - col identifies one diagonal direction\n// - row + col identifies other diagonal direction",
              "notes": "Diagonal trick: cells on same diagonal have same row-col or row+col."
            },
            "python": {
              "code": "def solve_n_queens(n):\n    result = []\n    board = [['.' for _ in range(n)] for _ in range(n)]\n    \n    cols = set()\n    diag1 = set()  # row - col\n    diag2 = set()  # row + col\n    \n    def backtrack(row):\n        if row == n:\n            result.append([''.join(r) for r in board])\n            return\n        \n        for col in range(n):\n            if col in cols or row - col in diag1 or row + col in diag2:\n                continue\n            \n            board[row][col] = 'Q'\n            cols.add(col)\n            diag1.add(row - col)\n            diag2.add(row + col)\n            \n            backtrack(row + 1)\n            \n            board[row][col] = '.'\n            cols.remove(col)\n            diag1.remove(row - col)\n            diag2.remove(row + col)\n    \n    backtrack(0)\n    return result",
              "notes": "Sets for O(1) lookup of attacked positions."
            }
          },
          {
            "name": "Word Search",
            "description": "Find if word exists in grid by adjacent letters",
            "javascript": {
              "code": "function exist(board, word) {\n  const rows = board.length;\n  const cols = board[0].length;\n  \n  function backtrack(r, c, index) {\n    // Base: found complete word\n    if (index === word.length) return true;\n    \n    // Bounds check + character match\n    if (r < 0 || r >= rows || c < 0 || c >= cols) return false;\n    if (board[r][c] !== word[index]) return false;\n    \n    // Mark visited (modify in place)\n    const temp = board[r][c];\n    board[r][c] = '#';\n    \n    // Explore 4 directions\n    const found = \n      backtrack(r + 1, c, index + 1) ||\n      backtrack(r - 1, c, index + 1) ||\n      backtrack(r, c + 1, index + 1) ||\n      backtrack(r, c - 1, index + 1);\n    \n    // Restore (backtrack)\n    board[r][c] = temp;\n    \n    return found;\n  }\n  \n  // Try starting from each cell\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (backtrack(r, c, 0)) return true;\n    }\n  }\n  \n  return false;\n}\n\n// Key techniques:\n// 1. Modify grid to mark visited (temporary)\n// 2. Restore after backtrack\n// 3. Early return on success (no need to find all)",
              "notes": "In-place marking avoids extra visited set. Restore is crucial!"
            },
            "python": {
              "code": "def exist(board, word):\n    rows, cols = len(board), len(board[0])\n    \n    def backtrack(r, c, index):\n        if index == len(word):\n            return True\n        \n        if r < 0 or r >= rows or c < 0 or c >= cols:\n            return False\n        if board[r][c] != word[index]:\n            return False\n        \n        temp = board[r][c]\n        board[r][c] = '#'\n        \n        found = (backtrack(r + 1, c, index + 1) or\n                 backtrack(r - 1, c, index + 1) or\n                 backtrack(r, c + 1, index + 1) or\n                 backtrack(r, c - 1, index + 1))\n        \n        board[r][c] = temp\n        \n        return found\n    \n    for r in range(rows):\n        for c in range(cols):\n            if backtrack(r, c, 0):\n                return True\n    \n    return False",
              "notes": "Short-circuit OR returns early on success."
            }
          }
        ],
        "visualTrace": {
          "title": "Generating [1,2,3] Permutations",
          "input": {
            "array": "[1, 2, 3]"
          },
          "steps": [
            {
              "step": 1,
              "path": "[]",
              "available": "[1,2,3]",
              "action": "Choose 1"
            },
            {
              "step": 2,
              "path": "[1]",
              "available": "[2,3]",
              "action": "Choose 2"
            },
            {
              "step": 3,
              "path": "[1,2]",
              "available": "[3]",
              "action": "Choose 3"
            },
            {
              "step": 4,
              "path": "[1,2,3]",
              "available": "[]",
              "action": "‚úì Complete! Save [1,2,3]"
            },
            {
              "step": 5,
              "path": "[1,2]",
              "available": "[3]",
              "action": "Backtrack (remove 3)"
            },
            {
              "step": 6,
              "path": "[1]",
              "available": "[2,3]",
              "action": "Backtrack (remove 2)"
            },
            {
              "step": 7,
              "path": "[1]",
              "available": "[2,3]",
              "action": "Choose 3"
            },
            {
              "step": 8,
              "path": "[1,3]",
              "available": "[2]",
              "action": "Choose 2"
            },
            {
              "step": 9,
              "path": "[1,3,2]",
              "available": "[]",
              "action": "‚úì Complete! Save [1,3,2]"
            }
          ],
          "output": "Continues until all 6 permutations found: [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]"
        },
        "commonMistakes": [
          {
            "mistake": "Forgetting to backtrack (undo)",
            "wrong": "path.push(x); recurse();  // x stays!",
            "right": "path.push(x); recurse(); path.pop();",
            "explanation": "Without undo, path accumulates all choices ever made."
          },
          {
            "mistake": "Not cloning when saving result",
            "wrong": "results.push(path);  // All refs point to same array!",
            "right": "results.push([...path]);  // Clone it",
            "explanation": "Push reference = all results show final (empty) path."
          },
          {
            "mistake": "Missing pruning",
            "wrong": "Always recurse, check validity at end",
            "right": "Check validity BEFORE recursing",
            "explanation": "Early pruning avoids exponential wasted work."
          }
        ],
        "keyTakeaways": [
          "Backtracking = recursion with choose-explore-unchoose pattern",
          "Template: for each choice { choose ‚Üí recurse ‚Üí unchoose }",
          "Pruning is critical: check constraints BEFORE recursing",
          "Clone solutions when saving (arrays are references)",
          "Time is exponential but pruning helps dramatically",
          "Use for: permutations, combinations, constraint satisfaction, path finding"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "recursion",
              "label": "Recursion",
              "why": "Backtracking is recursive"
            },
            {
              "id": "dfs",
              "label": "DFS",
              "why": "Backtracking is constrained DFS"
            }
          ],
          "nextTopics": [
            {
              "id": "dp",
              "label": "Dynamic Programming",
              "why": "When subproblems overlap"
            },
            {
              "id": "constraint_satisfaction",
              "label": "Constraint Propagation",
              "why": "Advanced pruning"
            },
            {
              "id": "branch_bound",
              "label": "Branch and Bound",
              "why": "Optimization + pruning"
            }
          ]
        },
        "patternChain": {
          "description": "Backtracking bridges recursion to advanced search and DP",
          "buildsOn": [
            {
              "id": "recursion",
              "relationship": "Recursive exploration",
              "whatToKnow": "How recursion works"
            },
            {
              "id": "dfs",
              "relationship": "Depth-first exploration",
              "whatToKnow": "DFS traversal pattern"
            }
          ],
          "enables": [
            {
              "id": "n_queens",
              "relationship": "Constraint satisfaction",
              "patternName": "Backtracking Search",
              "interviewFrequency": "High"
            },
            {
              "id": "sudoku_solver",
              "relationship": "Cell-by-cell backtracking",
              "patternName": "Constraint Propagation",
              "interviewFrequency": "High"
            },
            {
              "id": "word_search",
              "relationship": "Grid backtracking",
              "patternName": "2D Backtracking",
              "interviewFrequency": "Very High"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    REC[Recursion] --> BT[Backtracking]\n    DFS[DFS] --> BT\n    BT --> NQ[N-Queens]\n    BT --> WS[Word Search]\n    BT --> PERM[Permutations/Subsets]\n    \n    style BT fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "dp",
      "label": "Dynamic Programming",
      "type": "algo-pattern",
      "description": "Optimization via caching.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Dynamic_programming"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/dynamic-programming/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/dynamic-programming/"
          },
          {
            "title": "Codeforces Blog",
            "url": "https://codeforces.com/blog/entry/43256"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "6-10 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft"
      ],
      "interviewFrequency": "high",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "interviewQuestions": [
        {
          "name": "Climbing Stairs",
          "leetcode": "https://leetcode.com/problems/climbing-stairs/",
          "difficulty": "Easy",
          "companies": [
            "Amazon",
            "Google",
            "Apple"
          ],
          "frequency": "High",
          "whyAsked": "Intro to DP - Fibonacci pattern",
          "approach": "dp[i] = dp[i-1] + dp[i-2]. Can optimize to O(1) space with two variables",
          "followUps": [
            {
              "question": "k steps at a time?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "With cost per step?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Minimum cost climbing?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "House Robber",
          "leetcode": "https://leetcode.com/problems/house-robber/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Microsoft"
          ],
          "frequency": "High",
          "whyAsked": "Classic DP with non-adjacent constraint",
          "approach": "dp[i] = max(dp[i-1], dp[i-2] + nums[i]). Rob or skip current house",
          "followUps": [
            {
              "question": "Circular houses?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Binary tree of houses?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan by Yangshun (ex-Meta)"
            }
          ]
        },
        {
          "name": "Coin Change",
          "leetcode": "https://leetcode.com/problems/coin-change/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Classic unbounded knapsack - minimum coins to make amount",
          "approach": "dp[i] = min coins for amount i. For each coin, dp[i] = min(dp[i], 1 + dp[i-coin])",
          "followUps": [
            {
              "question": "Number of ways to make amount?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Limited coin supply?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Longest Increasing Subsequence",
          "leetcode": "https://leetcode.com/problems/longest-increasing-subsequence/",
          "difficulty": "Medium",
          "companies": [
            "Google",
            "Amazon",
            "Meta",
            "Microsoft",
            "Flipkart",
            "Meesho"
          ],
          "frequency": "Very High",
          "whyAsked": "Classic DP or binary search + patience sorting",
          "approach": "O(n¬≤) DP or O(n log n) with binary search on tails array",
          "followUps": [
            {
              "question": "Print the LIS?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Number of LIS?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Longest bitonic?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Word Break",
          "leetcode": "https://leetcode.com/problems/word-break/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Apple"
          ],
          "frequency": "Very High",
          "whyAsked": "DP with string matching - can string be segmented?",
          "approach": "dp[i] = true if s[0:i] can be segmented. Check all j < i where dp[j] && s[j:i] in dict",
          "followUps": [
            {
              "question": "Return all valid segmentations?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "With memoization/backtracking?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Longest Common Subsequence",
          "leetcode": "https://leetcode.com/problems/longest-common-subsequence/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Microsoft"
          ],
          "frequency": "High",
          "whyAsked": "2D DP classic - foundation for edit distance, diff algorithms",
          "approach": "dp[i][j] = LCS of s1[0:i] and s2[0:j]. Match: 1 + dp[i-1][j-1]. Else: max of skip either",
          "followUps": [
            {
              "question": "Print the LCS?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Edit distance?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Space optimization?",
              "answer": "Usually can't optimize bitmask DP space - need previous states arbitrarily."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        },
        {
          "name": "Unique Paths",
          "leetcode": "https://leetcode.com/problems/unique-paths/",
          "difficulty": "Medium",
          "companies": [
            "Google",
            "Amazon",
            "Meta"
          ],
          "frequency": "High",
          "whyAsked": "Grid DP introduction - count paths",
          "approach": "dp[i][j] = dp[i-1][j] + dp[i][j-1]. Can also use math: C(m+n-2, m-1)",
          "followUps": [
            {
              "question": "With obstacles?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Minimum path sum?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Count paths with exactly k turns?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Curated list by a Facebook engineer - most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with video explanations"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based problem categorization"
        },
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with video explanations"
        },
        {
          "name": "InterviewBit",
          "url": "https://www.interviewbit.com/",
          "note": "Structured interview prep with company-wise questions"
        }
      ],
      "content": {
        "definition": {
          "simple": "Dynamic Programming is solving a problem by breaking it into smaller subproblems, solving each once, and storing the results to avoid redoing work. It's recursion + memoization = efficiency.",
          "technical": "Dynamic Programming (DP) is an optimization technique for problems with overlapping subproblems and optimal substructure. It avoids redundant computation by storing solutions to subproblems (memoization) or building solutions bottom-up (tabulation)."
        },
        "howItWorks": {
          "explanation": "Imagine calculating Fibonacci. fib(5) needs fib(4) and fib(3). fib(4) needs fib(3) and fib(2). Notice fib(3) is calculated TWICE! DP says: calculate fib(3) once, store it, reuse. That's the magic - turning exponential into polynomial time.",
          "steps": [
            {
              "step": 1,
              "title": "Identify Overlapping Subproblems",
              "description": "Notice same smaller problems being solved repeatedly.",
              "why": "If subproblems don't overlap, DP won't help (use divide-and-conquer instead)."
            },
            {
              "step": 2,
              "title": "Define State",
              "description": "What variables uniquely define a subproblem? This becomes dp[i] or dp[i][j].",
              "why": "State is the 'key' for storing solutions."
            },
            {
              "step": 3,
              "title": "Define Recurrence",
              "description": "How does dp[i] relate to smaller subproblems?",
              "why": "The transition formula - heart of the algorithm."
            },
            {
              "step": 4,
              "title": "Identify Base Cases",
              "description": "What are the smallest subproblems we can solve directly?",
              "why": "Starting points for bottom-up or base for recursion."
            },
            {
              "step": 5,
              "title": "Choose Approach",
              "description": "Top-down (memoization) or bottom-up (tabulation).",
              "why": "Both work. Top-down often easier to write; bottom-up often more efficient."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph TD\n    F5[\"fib(5)\"] --> F4[\"fib(4)\"]\n    F5 --> F3a[\"fib(3)\"]\n    F4 --> F3b[\"fib(3)\"]\n    F4 --> F2a[\"fib(2)\"]\n    F3a --> F2b[\"fib(2)\"]\n    F3a --> F1a[\"fib(1)\"]\n    \n    style F3a fill:#ee6c4d\n    style F3b fill:#ee6c4d\n    style F2a fill:#98c1d9\n    style F2b fill:#98c1d9",
            "caption": "Overlapping subproblems: fib(3) calculated twice (red). With DP, calculate once, reuse."
          }
        },
        "whenToUse": {
          "summary": "Use DP when you see overlapping subproblems + optimal substructure. Keywords: 'minimum', 'maximum', 'count ways', 'is it possible'.",
          "patterns": [
            {
              "pattern": "Optimization (Min/Max)",
              "signal": "Find minimum cost, maximum value, shortest path",
              "example": "Coin change, house robber, longest increasing subsequence",
              "withoutIt": "Exponential exploration of all possibilities",
              "withIt": "Polynomial time by reusing subproblem solutions"
            },
            {
              "pattern": "Counting",
              "signal": "Count number of ways, combinations, arrangements",
              "example": "Climbing stairs, unique paths, decode ways",
              "withoutIt": "Exponential enumeration",
              "withIt": "Sum counts from subproblems"
            },
            {
              "pattern": "Decision Making",
              "signal": "At each step, choose option that optimizes result",
              "example": "Knapsack, stock buy/sell, partition equal subset",
              "withoutIt": "Try all 2^n combinations",
              "withIt": "Build optimal solution from subproblems"
            },
            {
              "pattern": "String/Sequence",
              "signal": "Compare/transform strings, subsequences",
              "example": "Edit distance, LCS, palindrome problems",
              "withoutIt": "Exponential string comparisons",
              "withIt": "dp[i][j] for prefixes of both strings"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "DP requires overlapping subproblems. If each subproblem is unique, DP adds overhead without benefit.",
          "antiPatterns": [
            {
              "situation": "No Overlapping Subproblems",
              "why": "Nothing to cache - every subproblem unique",
              "useInstead": "Divide and Conquer",
              "example": "Merge sort, quick sort"
            },
            {
              "situation": "Greedy Works",
              "why": "Local optimal = global optimal, no need for DP",
              "useInstead": "Greedy Algorithm",
              "example": "Activity selection, interval scheduling"
            },
            {
              "situation": "Simple Iteration Suffices",
              "why": "No need for complex state tracking",
              "useInstead": "Simple loop",
              "example": "Finding max in array"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Lazy Contractor",
            "story": "You're building a staircase. To know the cost of 10 steps, you need the cost of 9 steps (add one more) or 8 steps (add two more). Instead of recalculating from scratch each time, you write down the cost for 1 step, 2 steps, 3 steps... as you go. When asked for 10 steps, you just look up 8 and 9, calculate 10, done.",
            "connection": "That's bottom-up DP. Build solutions to small problems first, use them to solve bigger problems. Never redo work."
          },
          "keyInsight": "DP trades space for time. We store O(states) solutions to avoid O(exponential) recomputation. The key is identifying what 'state' uniquely defines each subproblem.",
          "commonConfusion": [
            {
              "confusion": "How to define the state?",
              "clarification": "Ask: 'What do I need to know to make a decision?' For strings: current indices. For knapsack: index + remaining capacity."
            },
            {
              "confusion": "Top-down vs bottom-up?",
              "clarification": "Top-down: recursive with cache, easier to write. Bottom-up: iterative, can optimize space, often faster."
            },
            {
              "confusion": "How to find the recurrence?",
              "clarification": "Ask: 'What decisions can I make at this step? How does each choice affect the subproblem?'"
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Fibonacci (DP)",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Calculate each of n states once"
              },
              {
                "operation": "Coin Change",
                "average": "O(n * amount)",
                "worst": "O(n * amount)",
                "note": "States = amounts, transitions = coins"
              },
              {
                "operation": "LCS",
                "average": "O(n * m)",
                "worst": "O(n * m)",
                "note": "2D table for two strings"
              },
              {
                "operation": "Knapsack",
                "average": "O(n * W)",
                "worst": "O(n * W)",
                "note": "Items √ó capacity"
              }
            ],
            "explanation": "Time = O(states √ó transitions). States = unique subproblems. Transitions = work per state."
          },
          "space": {
            "complexity": "O(states), often optimizable",
            "explanation": "Store solution for each state. Often can reduce to O(previous row) for 2D DP."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "DP stores subproblem solutions in array (1D or 2D), HashMap for memoization, or just previous values if optimizing space.",
            "keyPoints": [
              "1D DP: dp[i] = solution for subproblem i",
              "2D DP: dp[i][j] = solution for state (i, j)",
              "Space optimization: often only need previous row/values",
              "Top-down: HashMap or array for memoization"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Arrays for tabulation, Map or object for memoization.",
              "gotchas": [
                "Use new Array(n).fill(0) for 1D, Array.from for 2D",
                "Object keys are strings - use Map for complex keys",
                "No tuple keys - use 'i,j' string or Map with JSON.stringify"
              ]
            },
            "python": {
              "implementation": "Lists for tabulation, dict or @lru_cache for memoization.",
              "gotchas": [
                "@functools.lru_cache(maxsize=None) for automatic memoization",
                "Tuple keys work directly in dict: dp[(i, j)]",
                "Use [[0]*n for _ in range(m)] for 2D (not [[0]*n]*m!)"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Fibonacci with DP is O(n) instead of O(2^n)",
            "proof": {
              "step1": {
                "action": "Without DP: T(n) = T(n-1) + T(n-2) + O(1)",
                "cost": "Solves to O(2^n)"
              },
              "step2": {
                "action": "With DP: Each fib(i) calculated exactly once",
                "cost": "n unique subproblems"
              },
              "step3": {
                "action": "Each calculation is O(1): lookup two values, add",
                "cost": "O(1) per subproblem"
              },
              "step4": {
                "action": "Total: n subproblems √ó O(1) each",
                "cost": "O(n)"
              }
            },
            "totalCost": "O(n) - exponential collapse!"
          }
        },
        "codeTemplates": [
          {
            "name": "Fibonacci (Both Approaches)",
            "description": "Classic DP example showing memoization vs tabulation",
            "javascript": {
              "code": "// Top-Down (Memoization)\nfunction fibMemo(n, memo = {}) {\n  if (n <= 1) return n;\n  if (n in memo) return memo[n];\n  \n  memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);\n  return memo[n];\n}\n\n// Bottom-Up (Tabulation)\nfunction fibTab(n) {\n  if (n <= 1) return n;\n  \n  const dp = new Array(n + 1);\n  dp[0] = 0;\n  dp[1] = 1;\n  \n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n  \n  return dp[n];\n}\n\n// Space Optimized (O(1) space)\nfunction fibOptimized(n) {\n  if (n <= 1) return n;\n  \n  let prev2 = 0, prev1 = 1;\n  \n  for (let i = 2; i <= n; i++) {\n    const curr = prev1 + prev2;\n    prev2 = prev1;\n    prev1 = curr;\n  }\n  \n  return prev1;\n}",
              "notes": "Memo = cache results. Tabulation = build table. Optimized = only keep what you need."
            },
            "python": {
              "code": "from functools import lru_cache\n\n# Top-Down with @lru_cache\n@lru_cache(maxsize=None)\ndef fib_memo(n):\n    if n <= 1:\n        return n\n    return fib_memo(n - 1) + fib_memo(n - 2)\n\n# Bottom-Up\ndef fib_tab(n):\n    if n <= 1:\n        return n\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n\n# Space Optimized\ndef fib_optimized(n):\n    if n <= 1:\n        return n\n    \n    prev2, prev1 = 0, 1\n    \n    for _ in range(2, n + 1):\n        curr = prev1 + prev2\n        prev2, prev1 = prev1, curr\n    \n    return prev1",
              "notes": "@lru_cache is Python's built-in memoization. Very convenient!"
            }
          },
          {
            "name": "Coin Change (Classic DP)",
            "description": "Minimum coins to make amount",
            "javascript": {
              "code": "function coinChange(coins, amount) {\n  // dp[i] = minimum coins to make amount i\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;  // Base case: 0 coins for amount 0\n  \n  for (let i = 1; i <= amount; i++) {\n    for (const coin of coins) {\n      if (coin <= i && dp[i - coin] !== Infinity) {\n        dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n      }\n    }\n  }\n  \n  return dp[amount] === Infinity ? -1 : dp[amount];\n}\n\n// The recurrence:\n// dp[amount] = min(dp[amount - coin] + 1) for each coin\n// \n// Why it works:\n// - If we use coin c, remaining amount is (amount - c)\n// - dp[amount - c] tells us optimal for remainder\n// - We try all coins and take minimum",
              "notes": "State: amount. Transition: try each coin. Fill table left to right."
            },
            "python": {
              "code": "def coin_change(coins, amount):\n    # dp[i] = min coins for amount i\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i and dp[i - coin] != float('inf'):\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1\n\n# Alternative: Top-down\nfrom functools import lru_cache\n\ndef coin_change_memo(coins, amount):\n    @lru_cache(maxsize=None)\n    def dp(remaining):\n        if remaining == 0:\n            return 0\n        if remaining < 0:\n            return float('inf')\n        \n        return 1 + min((dp(remaining - c) for c in coins), default=float('inf'))\n    \n    result = dp(amount)\n    return result if result != float('inf') else -1",
              "notes": "Both approaches work. Bottom-up often cleaner for this problem."
            }
          },
          {
            "name": "Longest Increasing Subsequence (LIS)",
            "description": "Classic O(n¬≤) DP and O(n log n) optimization",
            "javascript": {
              "code": "// O(n¬≤) DP\nfunction lengthOfLIS(nums) {\n  const n = nums.length;\n  // dp[i] = length of LIS ending at index i\n  const dp = new Array(n).fill(1);\n  \n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (nums[j] < nums[i]) {\n        dp[i] = Math.max(dp[i], dp[j] + 1);\n      }\n    }\n  }\n  \n  return Math.max(...dp);\n}\n\n// O(n log n) with binary search\nfunction lengthOfLIS_Fast(nums) {\n  const tails = [];  // tails[i] = smallest tail for LIS of length i+1\n  \n  for (const num of nums) {\n    let left = 0, right = tails.length;\n    \n    // Binary search for position\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      if (tails[mid] < num) {\n        left = mid + 1;\n      } else {\n        right = mid;\n      }\n    }\n    \n    if (left === tails.length) {\n      tails.push(num);  // Extend LIS\n    } else {\n      tails[left] = num;  // Replace with smaller value\n    }\n  }\n  \n  return tails.length;\n}",
              "notes": "O(n¬≤): dp[i] = max(dp[j] + 1) for all j < i where nums[j] < nums[i]. O(n log n): patience sorting."
            },
            "python": {
              "code": "def length_of_lis(nums):\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n# O(n log n) with bisect\nfrom bisect import bisect_left\n\ndef length_of_lis_fast(nums):\n    tails = []\n    \n    for num in nums:\n        pos = bisect_left(tails, num)\n        if pos == len(tails):\n            tails.append(num)\n        else:\n            tails[pos] = num\n    \n    return len(tails)",
              "notes": "tails array maintains smallest tail for each LIS length. Binary search finds position."
            }
          },
          {
            "name": "House Robber (Linear DP)",
            "description": "Maximum sum with no adjacent elements",
            "javascript": {
              "code": "function rob(nums) {\n  const n = nums.length;\n  if (n === 0) return 0;\n  if (n === 1) return nums[0];\n  \n  // dp[i] = max money robbing houses 0..i\n  // Choice at i: rob it (nums[i] + dp[i-2]) or skip (dp[i-1])\n  \n  let prev2 = 0;         // dp[i-2]\n  let prev1 = nums[0];   // dp[i-1]\n  \n  for (let i = 1; i < n; i++) {\n    const curr = Math.max(\n      nums[i] + prev2,   // Rob this house\n      prev1              // Skip this house\n    );\n    prev2 = prev1;\n    prev1 = curr;\n  }\n  \n  return prev1;\n}\n\n// The key insight:\n// At each house, we decide: ROB or SKIP\n// ROB: take this house's value + best from 2 houses ago (can't take adjacent)\n// SKIP: take best from previous house",
              "notes": "Classic 'take or skip' pattern. Space optimized to O(1)."
            },
            "python": {
              "code": "def rob(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    prev2, prev1 = 0, nums[0]\n    \n    for i in range(1, len(nums)):\n        curr = max(nums[i] + prev2, prev1)\n        prev2, prev1 = prev1, curr\n    \n    return prev1\n\n# Full DP array version (clearer logic)\ndef rob_full(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i-1], nums[i] + dp[i-2])\n    \n    return dp[-1]",
              "notes": "Take or skip pattern. dp[i] depends only on dp[i-1] and dp[i-2]."
            }
          }
        ],
        "visualTrace": {
          "title": "Coin Change: coins = [1,2,5], amount = 11",
          "input": {
            "coins": "[1, 2, 5]",
            "amount": 11
          },
          "steps": [
            {
              "amount": 0,
              "dp[0]": 0,
              "reasoning": "Base case: 0 coins for 0 amount"
            },
            {
              "amount": 1,
              "dp[1]": 1,
              "reasoning": "Only coin 1 works: dp[0] + 1 = 1"
            },
            {
              "amount": 2,
              "dp[2]": 1,
              "reasoning": "Coin 2: dp[0] + 1 = 1 (better than dp[1] + 1 = 2)"
            },
            {
              "amount": 5,
              "dp[5]": 1,
              "reasoning": "Coin 5: dp[0] + 1 = 1"
            },
            {
              "amount": 11,
              "dp[11]": 3,
              "reasoning": "5+5+1: dp[6] + 1 = 2 + 1 = 3"
            }
          ],
          "output": "3 coins (5 + 5 + 1). dp array: [0,1,1,2,2,1,2,2,3,3,2,3]"
        },
        "commonMistakes": [
          {
            "mistake": "Mutable default argument in Python memoization",
            "wrong": "def fib(n, memo={})",
            "right": "def fib(n, memo=None): if memo is None: memo = {}",
            "explanation": "Default dict is shared across calls - breaks on reuse."
          },
          {
            "mistake": "Wrong 2D array initialization",
            "wrong": "[[0]*n]*m // All rows are same reference!",
            "right": "[[0]*n for _ in range(m)]",
            "explanation": "Multiplication creates references, not copies."
          },
          {
            "mistake": "Forgetting base cases",
            "wrong": "dp[i] = dp[i-1] + dp[i-2] // Crashes for i=0,1",
            "right": "dp[0] = 0; dp[1] = 1; for i from 2...",
            "explanation": "Always define base cases before recurrence."
          },
          {
            "mistake": "Wrong direction in tabulation",
            "wrong": "for i = n to 0: dp[i] = ... dp[i+1]",
            "right": "Ensure dependencies calculated before use",
            "explanation": "Bottom-up must process subproblems before problems that depend on them."
          }
        ],
        "keyTakeaways": [
          "DP = recursion + memoization (avoid redoing work)",
          "Need: overlapping subproblems + optimal substructure",
          "Identify STATE: what defines a subproblem uniquely",
          "Find RECURRENCE: how dp[i] relates to smaller states",
          "Top-down (memoization): easier to write, recursive",
          "Bottom-up (tabulation): often more efficient, can optimize space",
          "Common patterns: min/max optimization, counting ways, string comparison"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "recursion",
              "label": "Recursion",
              "why": "DP is optimized recursion"
            },
            {
              "id": "array",
              "label": "Array",
              "why": "DP tables are arrays"
            }
          ],
          "nextTopics": [
            {
              "id": "dp_patterns",
              "label": "DP Patterns",
              "why": "Knapsack, LCS, interval DP"
            },
            {
              "id": "memoization",
              "label": "Memoization",
              "why": "Top-down approach"
            },
            {
              "id": "tabulation",
              "label": "Tabulation",
              "why": "Bottom-up approach"
            }
          ]
        },
        "patternChain": {
          "description": "DP is the 'hard part' - foundation for optimization problems",
          "buildsOn": [
            {
              "id": "recursion",
              "relationship": "DP is recursion with caching",
              "whatToKnow": "Break problem into subproblems"
            },
            {
              "id": "divide_conquer",
              "relationship": "Similar subproblem breakdown",
              "whatToKnow": "But DP has overlapping subproblems"
            }
          ],
          "enables": [
            {
              "id": "knapsack",
              "relationship": "Classic DP problem family",
              "patternName": "0/1 Knapsack",
              "interviewFrequency": "Very High"
            },
            {
              "id": "lis",
              "relationship": "Subsequence optimization",
              "patternName": "LIS Pattern",
              "interviewFrequency": "High"
            },
            {
              "id": "lcs",
              "relationship": "String comparison",
              "patternName": "LCS Pattern",
              "interviewFrequency": "High"
            },
            {
              "id": "edit_distance",
              "relationship": "String transformation",
              "patternName": "Edit Distance",
              "interviewFrequency": "High"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    REC[Recursion] --> DP[Dynamic Programming]\n    DP --> FIB[Fibonacci/Stairs]\n    DP --> COIN[Coin Change]\n    DP --> KNAP[Knapsack]\n    DP --> LIS[LIS]\n    DP --> LCS[LCS/Edit Distance]\n    DP --> GRID[Grid DP]\n    \n    style DP fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "greedy",
      "label": "Greedy Algorithms",
      "type": "algo-pattern",
      "description": "Locally optimal choices.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Greedy_algorithm"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/greedy/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/greedy-algorithms/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "3-4 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft"
      ],
      "interviewFrequency": "high",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "interviewQuestions": [
        {
          "name": "Jump Game",
          "leetcode": "https://leetcode.com/problems/jump-game/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Microsoft",
            "Flipkart"
          ],
          "frequency": "Very High",
          "whyAsked": "Greedy - track farthest reachable position",
          "approach": "Track maxReach. At each index, update maxReach = max(maxReach, i + nums[i])",
          "followUps": [
            {
              "question": "Minimum jumps (Jump Game II)?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "With costs?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Jump Game II",
          "leetcode": "https://leetcode.com/problems/jump-game-ii/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta"
          ],
          "frequency": "High",
          "whyAsked": "BFS-style greedy - minimum jumps to reach end",
          "approach": "Track current range end and farthest. When reaching range end, jump++, update range",
          "followUps": [
            {
              "question": "Return actual path?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "With obstacles?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Gas Station",
          "leetcode": "https://leetcode.com/problems/gas-station/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Bloomberg"
          ],
          "frequency": "High",
          "whyAsked": "Greedy with running sum - find valid starting point",
          "approach": "If total gas >= total cost, solution exists. Track where tank goes negative, start after that",
          "followUps": [
            {
              "question": "Prove uniqueness",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Multiple cars?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Merge Intervals",
          "leetcode": "https://leetcode.com/problems/merge-intervals/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Microsoft",
            "Bloomberg"
          ],
          "frequency": "Very High",
          "whyAsked": "Sort + greedy merge - fundamental interval problem",
          "approach": "Sort by start. Merge overlapping by extending end. O(n log n)",
          "followUps": [
            {
              "question": "Insert interval?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Non-overlapping intervals?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Meeting rooms?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Non-overlapping Intervals",
          "leetcode": "https://leetcode.com/problems/non-overlapping-intervals/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta"
          ],
          "frequency": "High",
          "whyAsked": "Activity selection - minimize removals (maximize kept)",
          "approach": "Sort by end time. Greedily keep earliest ending non-overlapping intervals",
          "followUps": [
            {
              "question": "With weights?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Maximum meetings?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Partition Labels",
          "leetcode": "https://leetcode.com/problems/partition-labels/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google"
          ],
          "frequency": "Medium",
          "whyAsked": "Greedy with last occurrence tracking",
          "approach": "Track last index of each char. Extend partition end to max(end, lastIndex[char])",
          "followUps": [
            {
              "question": "Minimize partitions?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Return actual partitions?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based categorization"
        },
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with videos"
        }
      ],
      "content": {
        "definition": {
          "simple": "Greedy algorithms make the locally optimal choice at each step, hoping this leads to a globally optimal solution. It's like always taking the biggest bill when making change - sometimes it works, sometimes it doesn't.",
          "technical": "A greedy algorithm is an algorithmic paradigm that builds a solution piece by piece, always choosing the next piece that offers the most immediate benefit (local optimum), without considering the global structure of the problem."
        },
        "howItWorks": {
          "explanation": "Imagine you're at a buffet with limited plate space. Greedy approach: at each station, take as much of the best-looking food as fits. You make local decisions without planning the whole plate. Sometimes this gives the best plate, sometimes you miss something great at the end.",
          "steps": [
            {
              "step": 1,
              "title": "Define 'Best'",
              "description": "Determine what makes a choice locally optimal.",
              "why": "Need a clear criterion for comparison."
            },
            {
              "step": 2,
              "title": "Sort/Prioritize",
              "description": "Often sort choices by the 'best' criterion.",
              "why": "Ensures we consider best options first."
            },
            {
              "step": 3,
              "title": "Choose Greedily",
              "description": "Take the best available choice.",
              "why": "Local optimum selection."
            },
            {
              "step": 4,
              "title": "Check Feasibility",
              "description": "Verify the choice doesn't violate constraints.",
              "why": "Some 'best' choices may be invalid."
            },
            {
              "step": 5,
              "title": "Repeat",
              "description": "Continue until solution is complete.",
              "why": "Build solution incrementally."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart LR\n    A[Choices] --> B[Sort by 'Best']\n    B --> C{Pick Best}\n    C --> D{Feasible?}\n    D -->|Yes| E[Add to Solution]\n    D -->|No| C\n    E --> F{Done?}\n    F -->|No| C\n    F -->|Yes| G[Return Solution]\n    \n    style C fill:#ee6c4d\n    style G fill:#98c1d9",
            "caption": "Greedy loop: pick best feasible option, repeat until done"
          }
        },
        "whenToUse": {
          "summary": "Use when local optimum leads to global optimum. Requires PROOF of correctness - don't assume greedy works!",
          "patterns": [
            {
              "pattern": "Activity Selection",
              "signal": "Maximize non-overlapping intervals",
              "example": "Meeting room scheduling, job scheduling",
              "withoutIt": "2^n subset enumeration",
              "withIt": "Sort by end time, greedily pick"
            },
            {
              "pattern": "Fractional Knapsack",
              "signal": "Maximize value with divisible items",
              "example": "Loading truck with divisible goods",
              "withoutIt": "Complex optimization",
              "withIt": "Sort by value/weight, take greedily"
            },
            {
              "pattern": "Huffman Coding",
              "signal": "Optimal prefix-free codes",
              "example": "Data compression",
              "withoutIt": "Exponential tree enumeration",
              "withIt": "Merge two smallest frequencies"
            },
            {
              "pattern": "Minimum Spanning Tree",
              "signal": "Connect all nodes, minimize weight",
              "example": "Network wiring, road construction",
              "withoutIt": "Exponential tree enumeration",
              "withIt": "Kruskal's or Prim's greedy"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Greedy FAILS when local optimal ‚â† global optimal. Classic example: 0/1 Knapsack.",
          "antiPatterns": [
            {
              "situation": "0/1 Knapsack (indivisible)",
              "why": "Taking highest value/weight item may block better combinations",
              "useInstead": "Dynamic Programming",
              "example": "Items: [(60,10), (100,20), (120,30)], capacity 50"
            },
            {
              "situation": "Shortest Path with Negative Edges",
              "why": "Greedy Dijkstra fails with negative weights",
              "useInstead": "Bellman-Ford",
              "example": "Graph with negative edge weights"
            },
            {
              "situation": "Coin Change (arbitrary denominations)",
              "why": "Greedy may not use minimum coins",
              "useInstead": "DP",
              "example": "Coins [1,3,4], amount 6: greedy gives 4+1+1=3 coins, optimal is 3+3=2 coins"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Shortsighted Traveler",
            "story": "You're walking through a mountain range trying to reach the highest peak. A greedy traveler always walks uphill. This works if there's one big mountain - you'll reach the top. But if there are multiple peaks, you might climb a small hill and get stuck, missing the tallest mountain nearby.",
            "connection": "Greedy works when the problem has no 'false peaks' - when local uphill always leads to global maximum."
          },
          "keyInsight": "Greedy works when two properties hold: (1) Greedy Choice Property - local optimal choice is part of global optimal, (2) Optimal Substructure - optimal solution contains optimal solutions to subproblems.",
          "commonConfusion": [
            {
              "confusion": "When is greedy correct?",
              "clarification": "You must PROVE it. Exchange argument or induction. Don't assume greedy works because it seems intuitive."
            },
            {
              "confusion": "Greedy vs DP?",
              "clarification": "Both use optimal substructure. DP considers all subproblems; greedy commits to one choice immediately. DP = exhaustive, Greedy = one-shot."
            },
            {
              "confusion": "How to identify greedy problems?",
              "clarification": "Look for: sorting helps, interval scheduling, graph MST/shortest path, and problems where 'best first' intuitively can't hurt."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Activity Selection",
                "average": "O(n log n)",
                "worst": "O(n log n)",
                "note": "Sort + linear scan"
              },
              {
                "operation": "Huffman Coding",
                "average": "O(n log n)",
                "worst": "O(n log n)",
                "note": "Heap operations"
              },
              {
                "operation": "Kruskal's MST",
                "average": "O(E log E)",
                "worst": "O(E log E)",
                "note": "Sort edges + Union-Find"
              }
            ],
            "explanation": "Usually O(n log n) due to sorting. The greedy selection itself is often O(n)."
          },
          "space": {
            "complexity": "O(1) to O(n)",
            "explanation": "Often just sorting in-place, no extra structures needed."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Greedy algorithms typically sort input, then iterate once. Very cache-friendly.",
            "keyPoints": [
              "Usually sort the input (or use heap)",
              "Single pass after sorting",
              "No recursion or backtracking",
              "Minimal extra memory (often in-place)"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Use array.sort() with custom comparator. Watch for sort instability.",
              "gotchas": [
                "Default sort is lexicographic: [10, 2, 1].sort() ‚Üí [1, 10, 2]",
                "Use .sort((a, b) => a - b) for numeric sort",
                "Sort returns same array (mutates in place)"
              ]
            },
            "python": {
              "implementation": "sorted() or list.sort(). Use key= for custom ordering.",
              "gotchas": [
                "sorted() returns new list, .sort() mutates",
                "Use key=lambda x: x[1] for custom sort keys",
                "heapq module for priority queue greedy"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Activity Selection greedy is optimal",
            "proof": {
              "step1": {
                "action": "Sort by end time",
                "cost": "O(n log n)"
              },
              "step2": {
                "action": "Greedy: pick first ending, skip overlapping",
                "cost": "O(n)"
              },
              "step3": {
                "action": "Exchange argument: if optimal picks activity A instead of greedy's B, and B ends earlier, replacing A with B still valid (B ends before A, so no new conflicts)",
                "cost": "Logical proof"
              },
              "step4": {
                "action": "Therefore greedy = optimal",
                "cost": "QED"
              }
            },
            "totalCost": "O(n log n)"
          }
        },
        "codeTemplates": [
          {
            "name": "Activity Selection / Interval Scheduling",
            "description": "Maximum non-overlapping intervals",
            "javascript": {
              "code": "// Given intervals [start, end], find max non-overlapping\nfunction maxNonOverlapping(intervals) {\n  if (!intervals.length) return 0;\n  \n  // Sort by END time (greedy criterion)\n  intervals.sort((a, b) => a[1] - b[1]);\n  \n  let count = 1;\n  let prevEnd = intervals[0][1];\n  \n  for (let i = 1; i < intervals.length; i++) {\n    const [start, end] = intervals[i];\n    \n    // If this interval starts after previous ends, take it\n    if (start >= prevEnd) {\n      count++;\n      prevEnd = end;\n    }\n  }\n  \n  return count;\n}\n\n// WHY sort by end time?\n// Picking earliest-ending activity leaves MAXIMUM room\n// for future activities. This is the greedy choice property.\n\n// Example:\n// [[1,3], [2,4], [3,5]] ‚Üí sort by end: same\n// Pick [1,3], skip [2,4] (overlaps), pick [3,5]\n// Answer: 2 non-overlapping intervals",
              "notes": "Sort by END time, not start time. Classic greedy proof."
            },
            "python": {
              "code": "def max_non_overlapping(intervals):\n    if not intervals:\n        return 0\n    \n    # Sort by end time\n    intervals.sort(key=lambda x: x[1])\n    \n    count = 1\n    prev_end = intervals[0][1]\n    \n    for start, end in intervals[1:]:\n        if start >= prev_end:\n            count += 1\n            prev_end = end\n    \n    return count\n\n# Variant: Erase minimum to make non-overlapping\ndef erase_overlap_intervals(intervals):\n    if not intervals:\n        return 0\n    \n    intervals.sort(key=lambda x: x[1])\n    count = 1\n    prev_end = intervals[0][1]\n    \n    for start, end in intervals[1:]:\n        if start >= prev_end:\n            count += 1\n            prev_end = end\n    \n    # Erase = total - max_non_overlapping\n    return len(intervals) - count",
              "notes": "min_erasures = total - max_non_overlapping"
            }
          },
          {
            "name": "Jump Game (Greedy Reachability)",
            "description": "Can you reach the end jumping at most nums[i] from position i?",
            "javascript": {
              "code": "// Jump Game I: Can reach end?\nfunction canJump(nums) {\n  let maxReach = 0;\n  \n  for (let i = 0; i < nums.length; i++) {\n    if (i > maxReach) return false;  // Can't reach this position\n    maxReach = Math.max(maxReach, i + nums[i]);\n  }\n  \n  return true;\n}\n\n// Jump Game II: Minimum jumps to reach end\nfunction jump(nums) {\n  let jumps = 0;\n  let currentEnd = 0;   // End of current jump range\n  let farthest = 0;     // Farthest we can reach\n  \n  // Don't need to jump from last position\n  for (let i = 0; i < nums.length - 1; i++) {\n    farthest = Math.max(farthest, i + nums[i]);\n    \n    // Must jump when we reach end of current range\n    if (i === currentEnd) {\n      jumps++;\n      currentEnd = farthest;\n      \n      // Optimization: already can reach end\n      if (currentEnd >= nums.length - 1) break;\n    }\n  }\n  \n  return jumps;\n}\n\n// Greedy insight: At each \"jump point\", we've explored\n// all positions in current range and know the farthest\n// we can reach. Jump to that farthest point.",
              "notes": "Track max reachable at each step. Greedy: always extend farthest."
            },
            "python": {
              "code": "def can_jump(nums):\n    max_reach = 0\n    \n    for i in range(len(nums)):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + nums[i])\n    \n    return True\n\ndef min_jumps(nums):\n    if len(nums) <= 1:\n        return 0\n    \n    jumps = 0\n    current_end = 0\n    farthest = 0\n    \n    for i in range(len(nums) - 1):\n        farthest = max(farthest, i + nums[i])\n        \n        if i == current_end:\n            jumps += 1\n            current_end = farthest\n            \n            if current_end >= len(nums) - 1:\n                break\n    \n    return jumps",
              "notes": "BFS-like level logic, but greedy makes it O(n)."
            }
          },
          {
            "name": "Fractional Knapsack",
            "description": "Maximize value with divisible items",
            "javascript": {
              "code": "// Items: [{value, weight}, ...]\n// Can take fractions of items\nfunction fractionalKnapsack(items, capacity) {\n  // Sort by value-to-weight ratio (descending)\n  items.sort((a, b) => (b.value / b.weight) - (a.value / a.weight));\n  \n  let totalValue = 0;\n  let remainingCapacity = capacity;\n  \n  for (const item of items) {\n    if (item.weight <= remainingCapacity) {\n      // Take whole item\n      totalValue += item.value;\n      remainingCapacity -= item.weight;\n    } else {\n      // Take fraction\n      const fraction = remainingCapacity / item.weight;\n      totalValue += item.value * fraction;\n      break;  // Knapsack full\n    }\n  }\n  \n  return totalValue;\n}\n\n// WHY greedy works here but not 0/1 Knapsack?\n// Fractional: we can always take \"more value per weight\"\n// 0/1: taking one item may block better combinations\n// The divisibility allows greedy choice property",
              "notes": "Greedy works because items are divisible. 0/1 version needs DP."
            },
            "python": {
              "code": "def fractional_knapsack(items, capacity):\n    # Sort by value/weight ratio descending\n    items.sort(key=lambda x: x[0] / x[1], reverse=True)\n    \n    total_value = 0\n    remaining = capacity\n    \n    for value, weight in items:\n        if weight <= remaining:\n            total_value += value\n            remaining -= weight\n        else:\n            fraction = remaining / weight\n            total_value += value * fraction\n            break\n    \n    return total_value\n\n# Example:\n# items = [(60, 10), (100, 20), (120, 30)]  # (value, weight)\n# capacity = 50\n# Ratios: 6, 5, 4 ‚Üí take all of first (10), all of second (20)\n#         remaining 20 of capacity, take 20/30 of third\n# Total: 60 + 100 + 120*(20/30) = 60 + 100 + 80 = 240",
              "notes": "items as (value, weight) tuples."
            }
          }
        ],
        "visualTrace": {
          "title": "Activity Selection",
          "input": {
            "intervals": "[[1,4], [3,5], [0,6], [5,7], [3,9], [5,9], [6,10], [8,11], [8,12], [2,14], [12,16]]"
          },
          "steps": [
            {
              "step": 1,
              "action": "Sort by end time",
              "result": "[[1,4], [3,5], [0,6], [5,7], [3,9], [5,9], [6,10], [8,11], [8,12], [2,14], [12,16]]"
            },
            {
              "step": 2,
              "select": "[1,4]",
              "reason": "First activity (earliest end)",
              "count": 1
            },
            {
              "step": 3,
              "skip": "[3,5]",
              "reason": "Starts at 3 < 4 (overlaps)",
              "count": 1
            },
            {
              "step": 4,
              "skip": "[0,6]",
              "reason": "Starts at 0 < 4 (overlaps)",
              "count": 1
            },
            {
              "step": 5,
              "select": "[5,7]",
              "reason": "Starts at 5 >= 4 (no overlap)",
              "count": 2
            },
            {
              "step": 6,
              "skip": "[3,9], [5,9], [6,10]",
              "reason": "All overlap with [5,7]",
              "count": 2
            },
            {
              "step": 7,
              "select": "[8,11]",
              "reason": "Starts at 8 >= 7",
              "count": 3
            },
            {
              "step": 8,
              "skip": "[8,12], [2,14]",
              "reason": "Overlap with [8,11]",
              "count": 3
            },
            {
              "step": 9,
              "select": "[12,16]",
              "reason": "Starts at 12 >= 11",
              "count": 4
            }
          ],
          "output": "Maximum 4 non-overlapping activities: [1,4], [5,7], [8,11], [12,16]"
        },
        "commonMistakes": [
          {
            "mistake": "Assuming greedy works without proof",
            "wrong": "Coin change with [1,3,4]: greedy for 6 = 4+1+1",
            "right": "DP gives 3+3 = 2 coins",
            "explanation": "Greedy requires proof! Counter-examples exist."
          },
          {
            "mistake": "Wrong greedy criterion",
            "wrong": "Activity selection: sort by START time",
            "right": "Sort by END time",
            "explanation": "Wrong criterion gives suboptimal solution."
          },
          {
            "mistake": "Not checking feasibility",
            "wrong": "Take best item without checking constraints",
            "right": "if (item.weight <= remaining) take it",
            "explanation": "Best choice might violate constraints."
          }
        ],
        "keyTakeaways": [
          "Greedy = always make locally optimal choice",
          "Requires PROOF: Greedy Choice Property + Optimal Substructure",
          "Usually involves sorting by some criterion",
          "Fast: typically O(n log n) due to sorting",
          "FAILS on 0/1 Knapsack, some Coin Change, negative edge Shortest Path",
          "Works for: Interval scheduling, Huffman, MST, Fractional Knapsack"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "sorting",
              "label": "Sorting",
              "why": "Most greedy solutions start with sorting"
            },
            {
              "id": "heap",
              "label": "Heap/Priority Queue",
              "why": "Some greedy uses heap for 'best' selection"
            }
          ],
          "nextTopics": [
            {
              "id": "dp",
              "label": "Dynamic Programming",
              "why": "When greedy fails, use DP"
            },
            {
              "id": "mst",
              "label": "Minimum Spanning Tree",
              "why": "Graph greedy algorithms"
            },
            {
              "id": "dijkstra",
              "label": "Dijkstra's Algorithm",
              "why": "Greedy shortest path"
            }
          ]
        },
        "patternChain": {
          "description": "Greedy is a decision-making strategy, often combined with sorting",
          "buildsOn": [
            {
              "id": "sorting",
              "relationship": "Sort to enable greedy selection",
              "whatToKnow": "How to sort efficiently"
            },
            {
              "id": "heap",
              "relationship": "Dynamic 'best' selection",
              "whatToKnow": "Priority queue operations"
            }
          ],
          "enables": [
            {
              "id": "interval_scheduling",
              "relationship": "Sort by end, pick first",
              "patternName": "Interval Greedy",
              "interviewFrequency": "Very High"
            },
            {
              "id": "huffman",
              "relationship": "Merge smallest frequencies",
              "patternName": "Huffman Coding",
              "interviewFrequency": "Medium"
            },
            {
              "id": "mst",
              "relationship": "Kruskal/Prim greedy edge selection",
              "patternName": "MST Algorithms",
              "interviewFrequency": "Medium"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    SORT[Sorting] --> GREEDY[Greedy Algorithms]\n    HEAP[Heap] --> GREEDY\n    GREEDY --> INT[Interval Scheduling]\n    GREEDY --> HUFF[Huffman Coding]\n    GREEDY --> MST[Min Spanning Tree]\n    GREEDY --> JUMP[Jump Game]\n    \n    style GREEDY fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "trie",
      "label": "Trie",
      "type": "ds-specialized",
      "description": "Prefix tree for strings.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Trie"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/dfsbfs"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/trie/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/trie-insert-and-search/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-4 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft",
        "Uber"
      ],
      "interviewFrequency": "medium",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "interviewQuestions": [
        {
          "name": "Implement Trie (Prefix Tree)",
          "leetcode": "https://leetcode.com/problems/implement-trie-prefix-tree/",
          "difficulty": "Medium",
          "companies": [
            "Google",
            "Amazon",
            "Meta",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Tests understanding of Trie data structure - insert, search, prefix operations",
          "approach": "TrieNode with children map/array. insert: add nodes. search: traverse all chars. startsWith: same but no end check",
          "followUps": [
            {
              "question": "Delete word?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Count words with prefix?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Memory optimization?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Word Search II",
          "leetcode": "https://leetcode.com/problems/word-search-ii/",
          "difficulty": "Hard",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Combines Trie with DFS backtracking - finding multiple words in grid",
          "approach": "Build Trie from words. DFS from each cell, prune branches. Remove found words to optimize",
          "followUps": [
            {
              "question": "Stream of words?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Time complexity analysis",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "teamblind"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Blind (Teamblind)",
              "url": "https://www.teamblind.com/",
              "note": "Crowdsourced FAANG interview experiences"
            }
          ]
        },
        {
          "name": "Design Add and Search Words Data Structure",
          "leetcode": "https://leetcode.com/problems/design-add-and-search-words-data-structure/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google"
          ],
          "frequency": "High",
          "whyAsked": "Trie with wildcard matching using DFS/backtracking",
          "approach": "Standard Trie insert. For search with '.', try all children recursively",
          "followUps": [
            {
              "question": "Support more wildcards like '*'?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Case insensitive?",
              "answer": "Convert both strings to lowercase (or uppercase) before comparing. Or normalize in hash map key."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Replace Words",
          "leetcode": "https://leetcode.com/problems/replace-words/",
          "difficulty": "Medium",
          "companies": [
            "Uber",
            "Amazon"
          ],
          "frequency": "Medium",
          "whyAsked": "Practical Trie application - finding shortest prefix",
          "approach": "Build Trie of roots. For each word, find shortest matching prefix in Trie",
          "followUps": [
            {
              "question": "Handle multiple matching roots?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with videos"
        },
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based categorization"
        }
      ],
      "content": {
        "definition": {
          "simple": "A Trie (pronounced 'try') is a tree where each path from root to a node spells out a word prefix. It's like a dictionary organized by spelling - all words starting with 'app' share the same path until they diverge.",
          "technical": "A Trie (prefix tree) is a tree-based data structure that stores strings character by character. Each node represents a prefix, edges represent characters, and paths from root to marked nodes represent complete strings. Enables O(m) operations where m is string length."
        },
        "howItWorks": {
          "explanation": "Imagine a filing cabinet for words. Instead of one drawer per word, you organize by first letter, then second letter, etc. To find 'apple', open drawer 'a', then 'p', then 'p', then 'l', then 'e'. If each step exists, the word is there.",
          "steps": [
            {
              "step": 1,
              "title": "Start at Root",
              "description": "Root represents empty string (all prefixes start here).",
              "why": "Common starting point for all words."
            },
            {
              "step": 2,
              "title": "Follow/Create Path",
              "description": "For each character, follow existing edge or create new node.",
              "why": "Path represents prefix built so far."
            },
            {
              "step": 3,
              "title": "Mark End of Word",
              "description": "When word ends, mark that node as 'end of word'.",
              "why": "Distinguish 'app' from 'apple' - both share path to 'p'."
            },
            {
              "step": 4,
              "title": "Search by Path",
              "description": "To search, follow edges for each character.",
              "why": "O(m) lookup regardless of dictionary size."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph TD\n    ROOT((root)) --> A((a))\n    ROOT --> B((b))\n    A --> P((p))\n    P --> P2((p))\n    P2 --> L((l))\n    L --> E((e*))\n    P2 --> S((s*))\n    B --> A2((a))\n    A2 --> T((t*))\n    \n    style E fill:#98c1d9\n    style S fill:#98c1d9\n    style T fill:#98c1d9",
            "caption": "Trie storing: 'apple', 'apps', 'bat'. * marks end of word."
          }
        },
        "whenToUse": {
          "summary": "Use Trie when you need prefix-based operations on strings: autocomplete, spell check, prefix matching.",
          "patterns": [
            {
              "pattern": "Autocomplete",
              "signal": "Find all words with given prefix",
              "example": "Search suggestions as user types",
              "withoutIt": "O(n * m) scan all words",
              "withIt": "O(prefix) to reach node, then DFS for completions"
            },
            {
              "pattern": "Spell Checker",
              "signal": "Check if word exists in dictionary",
              "example": "Word processor spell check",
              "withoutIt": "HashSet works but no prefix info",
              "withIt": "O(m) lookup + can suggest similar words"
            },
            {
              "pattern": "IP Routing (Longest Prefix Match)",
              "signal": "Find longest matching prefix",
              "example": "Network routing tables",
              "withoutIt": "Compare all prefixes",
              "withIt": "Single traversal finds longest match"
            },
            {
              "pattern": "Word Games",
              "signal": "Validate words, find all words in grid",
              "example": "Boggle, Scrabble word validation",
              "withoutIt": "Check each candidate against dictionary",
              "withIt": "Prune impossible paths early"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Trie trades space for speed. High memory usage, especially for sparse character sets.",
          "antiPatterns": [
            {
              "situation": "Exact Match Only (no prefix ops)",
              "why": "HashSet is simpler and often faster",
              "useInstead": "HashSet/HashMap",
              "example": "Simple word lookup"
            },
            {
              "situation": "Large Alphabet",
              "why": "Each node has alphabet_size pointers",
              "useInstead": "HashMap at each node or radix tree",
              "example": "Unicode strings"
            },
            {
              "situation": "Memory-Constrained",
              "why": "Trie can use 10-50x more memory than string list",
              "useInstead": "Sorted array + binary search",
              "example": "Embedded systems"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Multi-Story Library",
            "story": "Imagine a library where floor 1 has 26 rooms (A-Z) for first letter. Each room on floor 1 leads to 26 rooms on floor 2 for second letter, and so on. To find 'CAT', go to room C (floor 1) ‚Üí room A (floor 2) ‚Üí room T (floor 3). If that path exists and room T is marked as 'book here', the word exists.",
            "connection": "Trie structure: each level is one character position. Following edges spells out the word. Memory used only for paths that exist."
          },
          "keyInsight": "Trie lookup is O(m) where m is word length - completely independent of how many words are stored. This is why it beats HashSet for prefix operations.",
          "commonConfusion": [
            {
              "confusion": "Why not just use HashMap<String, Boolean>?",
              "clarification": "HashMap is O(m) for exact match too, but can't do prefix operations. 'Find all words starting with pre' requires scanning all keys in HashMap."
            },
            {
              "confusion": "How much memory does Trie use?",
              "clarification": "Worst case: O(alphabet_size * total_characters). For 26 lowercase letters, each node has 26 pointers. Optimizations exist (compressed trie, map instead of array)."
            },
            {
              "confusion": "What's the difference from suffix tree?",
              "clarification": "Trie stores words from start. Suffix tree stores all suffixes of a string - used for substring search, not prefix search."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Insert word",
                "average": "O(m)",
                "worst": "O(m)",
                "note": "m = word length"
              },
              {
                "operation": "Search word",
                "average": "O(m)",
                "worst": "O(m)",
                "note": "Independent of dictionary size"
              },
              {
                "operation": "StartsWith (prefix check)",
                "average": "O(p)",
                "worst": "O(p)",
                "note": "p = prefix length"
              },
              {
                "operation": "Autocomplete (all with prefix)",
                "average": "O(p + k)",
                "worst": "O(p + k)",
                "note": "k = total chars in matching words"
              }
            ],
            "explanation": "All operations are O(word length), not O(dictionary size). This is Trie's superpower."
          },
          "space": {
            "complexity": "O(total_characters * alphabet_size) worst case",
            "explanation": "Each character in all words needs a node. Each node has alphabet_size child pointers."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Each node typically stores: children array/map, isEndOfWord flag, optionally value.",
            "keyPoints": [
              "Array-based: children[26] for lowercase - fast but wastes space",
              "Map-based: children = {} - saves space for sparse nodes",
              "Compressed/Radix Trie: merge single-child chains into one node",
              "isEndOfWord distinguishes prefix from complete word"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Use Map for children (sparse), or array[26] for lowercase only.",
              "gotchas": [
                "Use charCodeAt(i) - 97 for 'a'=0 indexing",
                "Object vs Map: Map is cleaner for children",
                "Remember to mark isEndOfWord on insert"
              ]
            },
            "python": {
              "implementation": "Dict for children is idiomatic. Can use defaultdict(TrieNode).",
              "gotchas": [
                "ord(char) - ord('a') for indexing",
                "Use collections.defaultdict for auto-creating children",
                "Consider __slots__ for memory optimization"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Trie search is O(m) independent of n words",
            "proof": {
              "step1": {
                "action": "For each character in search word",
                "cost": "O(1) - follow one edge"
              },
              "step2": {
                "action": "Check if edge exists (array index or map lookup)",
                "cost": "O(1)"
              },
              "step3": {
                "action": "Repeat for m characters",
                "cost": "O(m)"
              },
              "step4": {
                "action": "Check isEndOfWord flag",
                "cost": "O(1)"
              }
            },
            "totalCost": "O(m) regardless of dictionary size n"
          }
        },
        "codeTemplates": [
          {
            "name": "Basic Trie (Insert, Search, StartsWith)",
            "description": "Standard Trie implementation",
            "javascript": {
              "code": "class TrieNode {\n  constructor() {\n    this.children = new Map();\n    this.isEndOfWord = false;\n  }\n}\n\nclass Trie {\n  constructor() {\n    this.root = new TrieNode();\n  }\n  \n  insert(word) {\n    let node = this.root;\n    for (const char of word) {\n      if (!node.children.has(char)) {\n        node.children.set(char, new TrieNode());\n      }\n      node = node.children.get(char);\n    }\n    node.isEndOfWord = true;\n  }\n  \n  search(word) {\n    const node = this._traverse(word);\n    return node !== null && node.isEndOfWord;\n  }\n  \n  startsWith(prefix) {\n    return this._traverse(prefix) !== null;\n  }\n  \n  _traverse(str) {\n    let node = this.root;\n    for (const char of str) {\n      if (!node.children.has(char)) {\n        return null;\n      }\n      node = node.children.get(char);\n    }\n    return node;\n  }\n}\n\n// Usage:\n// const trie = new Trie();\n// trie.insert('apple');\n// trie.search('apple');   // true\n// trie.search('app');     // false (prefix, not complete word)\n// trie.startsWith('app'); // true",
              "notes": "Map-based children for flexibility. _traverse is shared helper."
            },
            "python": {
              "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n    \n    def search(self, word: str) -> bool:\n        node = self._traverse(word)\n        return node is not None and node.is_end_of_word\n    \n    def starts_with(self, prefix: str) -> bool:\n        return self._traverse(prefix) is not None\n    \n    def _traverse(self, s: str):\n        node = self.root\n        for char in s:\n            if char not in node.children:\n                return None\n            node = node.children[char]\n        return node",
              "notes": "Dict-based children. Pythonic and memory-efficient."
            }
          },
          {
            "name": "Autocomplete (Find All Words with Prefix)",
            "description": "Return all words starting with given prefix",
            "javascript": {
              "code": "class Trie {\n  // ... (previous implementation)\n  \n  autocomplete(prefix) {\n    const node = this._traverse(prefix);\n    if (!node) return [];\n    \n    const results = [];\n    this._collect(node, prefix, results);\n    return results;\n  }\n  \n  _collect(node, prefix, results) {\n    if (node.isEndOfWord) {\n      results.push(prefix);\n    }\n    \n    for (const [char, child] of node.children) {\n      this._collect(child, prefix + char, results);\n    }\n  }\n}\n\n// Usage:\n// trie.insert('apple');\n// trie.insert('application');\n// trie.insert('apply');\n// trie.insert('banana');\n// trie.autocomplete('app');  // ['apple', 'application', 'apply']",
              "notes": "DFS from prefix node to collect all complete words."
            },
            "python": {
              "code": "class Trie:\n    # ... (previous implementation)\n    \n    def autocomplete(self, prefix: str) -> list:\n        node = self._traverse(prefix)\n        if not node:\n            return []\n        \n        results = []\n        self._collect(node, prefix, results)\n        return results\n    \n    def _collect(self, node, prefix, results):\n        if node.is_end_of_word:\n            results.append(prefix)\n        \n        for char, child in node.children.items():\n            self._collect(child, prefix + char, results)",
              "notes": "Recursive DFS collects all words under prefix node."
            }
          },
          {
            "name": "Word Search II (Trie + Backtracking)",
            "description": "Find all dictionary words in a grid",
            "javascript": {
              "code": "function findWords(board, words) {\n  const trie = new Trie();\n  for (const word of words) {\n    trie.insert(word);\n  }\n  \n  const result = new Set();\n  const rows = board.length;\n  const cols = board[0].length;\n  \n  function backtrack(r, c, node, path) {\n    if (r < 0 || r >= rows || c < 0 || c >= cols) return;\n    \n    const char = board[r][c];\n    if (char === '#' || !node.children.has(char)) return;\n    \n    const nextNode = node.children.get(char);\n    const newPath = path + char;\n    \n    if (nextNode.isEndOfWord) {\n      result.add(newPath);\n      // Don't return - might have longer words\n    }\n    \n    // Mark visited\n    board[r][c] = '#';\n    \n    // Explore 4 directions\n    backtrack(r + 1, c, nextNode, newPath);\n    backtrack(r - 1, c, nextNode, newPath);\n    backtrack(r, c + 1, nextNode, newPath);\n    backtrack(r, c - 1, nextNode, newPath);\n    \n    // Restore\n    board[r][c] = char;\n  }\n  \n  // Start from every cell\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      backtrack(r, c, trie.root, '');\n    }\n  }\n  \n  return [...result];\n}\n\n// Trie prunes impossible paths early:\n// If current prefix isn't in Trie, stop exploring\n// Much faster than checking each word separately",
              "notes": "Trie enables early pruning during grid exploration."
            },
            "python": {
              "code": "def find_words(board, words):\n    trie = Trie()\n    for word in words:\n        trie.insert(word)\n    \n    result = set()\n    rows, cols = len(board), len(board[0])\n    \n    def backtrack(r, c, node, path):\n        if r < 0 or r >= rows or c < 0 or c >= cols:\n            return\n        \n        char = board[r][c]\n        if char == '#' or char not in node.children:\n            return\n        \n        next_node = node.children[char]\n        new_path = path + char\n        \n        if next_node.is_end_of_word:\n            result.add(new_path)\n        \n        board[r][c] = '#'\n        \n        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n            backtrack(r + dr, c + dc, next_node, new_path)\n        \n        board[r][c] = char\n    \n    for r in range(rows):\n        for c in range(cols):\n            backtrack(r, c, trie.root, '')\n    \n    return list(result)",
              "notes": "Set avoids duplicates. Continue after finding word for longer matches."
            }
          }
        ],
        "visualTrace": {
          "title": "Insert 'app', 'apple', 'apt' into Trie",
          "input": {
            "words": "['app', 'apple', 'apt']"
          },
          "steps": [
            {
              "word": "app",
              "action": "Create path: root ‚Üí a ‚Üí p ‚Üí p*",
              "trie": "a-p-p*"
            },
            {
              "word": "apple",
              "action": "Extend: p* ‚Üí l ‚Üí e*",
              "trie": "a-p-p*-l-e*"
            },
            {
              "word": "apt",
              "action": "Branch at 'p': p ‚Üí t*",
              "trie": "a-p-(p*-l-e*, t*)"
            }
          ],
          "output": "Trie shares 'ap' prefix for all three words. 'app', 'apple', 'apt' all accessible."
        },
        "commonMistakes": [
          {
            "mistake": "Forgetting isEndOfWord flag",
            "wrong": "Only check if path exists",
            "right": "Check node.isEndOfWord at path end",
            "explanation": "'app' path exists in trie with 'apple', but 'app' might not be a word."
          },
          {
            "mistake": "Not handling empty string",
            "wrong": "Assume word has at least 1 char",
            "right": "Empty string = check root.isEndOfWord",
            "explanation": "Edge case: some tries store empty string as valid."
          },
          {
            "mistake": "Memory leak - not cleaning up",
            "wrong": "Delete word but leave orphan nodes",
            "right": "Remove nodes with no children after delete",
            "explanation": "Deleted words leave empty branches without cleanup."
          }
        ],
        "keyTakeaways": [
          "Trie = prefix tree, O(m) operations independent of dictionary size",
          "Perfect for: autocomplete, spell check, prefix matching",
          "Each path from root spells a prefix; marked nodes are complete words",
          "Space trade-off: can use 10-50x more memory than word list",
          "Use Map for children (flexible) or array[26] (fast, lowercase only)",
          "Trie + backtracking is powerful pattern for word grid problems"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "tree",
              "label": "Trees",
              "why": "Trie is a specialized tree"
            },
            {
              "id": "hashmap",
              "label": "HashMap",
              "why": "Alternative for exact match; children often stored as map"
            }
          ],
          "nextTopics": [
            {
              "id": "suffix_tree",
              "label": "Suffix Tree/Array",
              "why": "For substring (not prefix) operations"
            },
            {
              "id": "aho_corasick",
              "label": "Aho-Corasick",
              "why": "Multiple pattern matching"
            },
            {
              "id": "radix_tree",
              "label": "Radix Tree",
              "why": "Compressed trie for memory efficiency"
            }
          ]
        },
        "patternChain": {
          "description": "Trie bridges string processing with tree algorithms",
          "buildsOn": [
            {
              "id": "tree",
              "relationship": "Tree structure with character edges",
              "whatToKnow": "Tree traversal"
            },
            {
              "id": "hashmap",
              "relationship": "Often uses map for children",
              "whatToKnow": "O(1) lookups"
            }
          ],
          "enables": [
            {
              "id": "autocomplete",
              "relationship": "Prefix ‚Üí all completions",
              "patternName": "Autocomplete",
              "interviewFrequency": "High"
            },
            {
              "id": "word_search_ii",
              "relationship": "Trie + grid backtracking",
              "patternName": "Word Search II",
              "interviewFrequency": "Very High"
            },
            {
              "id": "longest_prefix",
              "relationship": "Network routing",
              "patternName": "Longest Prefix Match",
              "interviewFrequency": "Medium"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    TREE[Trees] --> TRIE[Trie]\n    HASH[HashMap] --> TRIE\n    TRIE --> AUTO[Autocomplete]\n    TRIE --> WS[Word Search II]\n    TRIE --> IP[IP Routing]\n    \n    style TRIE fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "union_find",
      "label": "Union-Find",
      "type": "ds-specialized",
      "description": "Disjoint set data structure.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Disjoint-set_data_structure"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/ufds"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/union-find/"
          },
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/data_structures/disjoint_set_union.html"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "3-4 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon"
      ],
      "interviewFrequency": "medium",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "interviewQuestions": [
        {
          "name": "Number of Connected Components",
          "leetcode": "https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "LinkedIn"
          ],
          "frequency": "Very High",
          "whyAsked": "Basic Union-Find application - count disjoint sets",
          "approach": "Initialize n components. For each edge, union. Decrement count on successful union",
          "followUps": [
            {
              "question": "Dynamic connectivity?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Add/remove edges?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Redundant Connection",
          "leetcode": "https://leetcode.com/problems/redundant-connection/",
          "difficulty": "Medium",
          "companies": [
            "Google",
            "Amazon",
            "Meta"
          ],
          "frequency": "High",
          "whyAsked": "Find cycle using Union-Find - edge that creates cycle is redundant",
          "approach": "Process edges in order. If union returns false (same component), that's the answer",
          "followUps": [
            {
              "question": "Directed graph version (II)?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Multiple redundant edges?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Accounts Merge",
          "leetcode": "https://leetcode.com/problems/accounts-merge/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google"
          ],
          "frequency": "Very High",
          "whyAsked": "Union-Find with string keys - merge accounts sharing emails",
          "approach": "Map emails to index. Union emails in same account. Group by root, attach name",
          "followUps": [
            {
              "question": "Stream of accounts?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Fuzzy matching?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "teamblind"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Blind (Teamblind)",
              "url": "https://www.teamblind.com/",
              "note": "Crowdsourced FAANG interview experiences"
            }
          ]
        },
        {
          "name": "Longest Consecutive Sequence",
          "leetcode": "https://leetcode.com/problems/longest-consecutive-sequence/",
          "difficulty": "Medium",
          "companies": [
            "Google",
            "Amazon",
            "Meta",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Can use Union-Find (or hash set) for O(n) solution",
          "approach": "Union consecutive numbers. Or: hash set, only start count from sequence start",
          "followUps": [
            {
              "question": "With duplicates?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Subsequence version?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Graph Valid Tree",
          "leetcode": "https://leetcode.com/problems/graph-valid-tree/",
          "difficulty": "Medium",
          "companies": [
            "Google",
            "Meta",
            "Amazon"
          ],
          "frequency": "High",
          "whyAsked": "Tree = connected + no cycles. Union-Find detects both",
          "approach": "n-1 edges required. Union all edges. If any union fails (cycle), return false",
          "followUps": [
            {
              "question": "Minimum edges to make tree?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Forest of trees?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with videos"
        },
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based categorization"
        }
      ],
      "content": {
        "definition": {
          "simple": "Union-Find tracks which elements belong to the same group. It answers: 'Are these two things connected?' and can efficiently merge groups. Think of it like tracking friend circles - you can quickly check if two people are in the same circle and merge circles when they become friends.",
          "technical": "Disjoint Set Union (DSU), also called Union-Find, is a data structure that tracks a partition of elements into disjoint (non-overlapping) subsets. It supports near-constant time operations for union (merging sets) and find (determining set membership), achieving O(Œ±(n)) amortized time with path compression and union by rank."
        },
        "howItWorks": {
          "explanation": "Each set is represented as a tree. Each element points to a parent. The root of the tree is the 'representative' of that set. To check if two elements are in the same set, find their roots. To merge sets, make one root point to another.",
          "steps": [
            {
              "step": 1,
              "title": "Initialize",
              "description": "Each element is its own parent (its own set).",
              "why": "Start with n sets of size 1."
            },
            {
              "step": 2,
              "title": "Find",
              "description": "Follow parent pointers until reaching root.",
              "why": "Root identifies which set element belongs to."
            },
            {
              "step": 3,
              "title": "Path Compression",
              "description": "During find, point all nodes directly to root.",
              "why": "Flattens tree for future O(1) finds."
            },
            {
              "step": 4,
              "title": "Union",
              "description": "Find roots of both elements, make one root point to other.",
              "why": "Merges two sets into one."
            },
            {
              "step": 5,
              "title": "Union by Rank",
              "description": "Attach smaller tree under larger tree's root.",
              "why": "Keeps trees shallow for fast finds."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph TD\n    subgraph Before Union\n        A1((1)) --> A0((0))\n        A2((2)) --> A0\n        B4((4)) --> B3((3))\n    end\n    subgraph After Union 1,4\n        C1((1)) --> C0((0))\n        C2((2)) --> C0\n        C4((4)) --> C3((3))\n        C3 --> C0\n    end\n    \n    style A0 fill:#ee6c4d\n    style B3 fill:#ee6c4d\n    style C0 fill:#98c1d9",
            "caption": "Union(1,4): Find roots (0 and 3), attach 3 under 0"
          }
        },
        "whenToUse": {
          "summary": "Use when you need to track connectivity and merge groups dynamically. Perfect for graph connectivity problems.",
          "patterns": [
            {
              "pattern": "Dynamic Connectivity",
              "signal": "Are X and Y connected? (edges added over time)",
              "example": "Social network friend connections",
              "withoutIt": "BFS/DFS for each query - O(V+E)",
              "withIt": "O(Œ±(n)) ‚âà O(1) per query"
            },
            {
              "pattern": "Kruskal's MST",
              "signal": "Minimum spanning tree",
              "example": "Network wiring, road construction",
              "withoutIt": "Check for cycles with DFS - slow",
              "withIt": "O(1) cycle check with Union-Find"
            },
            {
              "pattern": "Connected Components",
              "signal": "Group nodes into connected sets",
              "example": "Number of islands, friend circles",
              "withoutIt": "Multiple DFS traversals",
              "withIt": "Single pass with unions"
            },
            {
              "pattern": "Cycle Detection (Undirected)",
              "signal": "Does adding edge create cycle?",
              "example": "Redundant connection problems",
              "withoutIt": "DFS to check path exists",
              "withIt": "If same root before union ‚Üí cycle"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "Union-Find doesn't support split/disconnect. Also not for directed graph connectivity.",
          "antiPatterns": [
            {
              "situation": "Need to Split Sets",
              "why": "Union-Find only merges, never splits",
              "useInstead": "Maintain explicit graph",
              "example": "Unfriend operation"
            },
            {
              "situation": "Directed Graph Connectivity",
              "why": "A‚ÜíB doesn't mean B‚ÜíA reachable",
              "useInstead": "Tarjan's SCC algorithm",
              "example": "Strongly connected components"
            },
            {
              "situation": "Path Finding",
              "why": "Only knows IF connected, not HOW",
              "useInstead": "BFS/DFS",
              "example": "Find actual path between nodes"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Tribal Chiefs",
            "story": "Imagine scattered tribes, each with a chief. When tribes ally, one chief bows to the other (union). To check if two people are in the same tribe, ask 'who is your chief?' If same chief, same tribe. Over time, everyone learns to report directly to the ultimate chief (path compression).",
            "connection": "parent[x] = 'who does x report to'. find(x) = 'find ultimate chief'. union(x,y) = 'ally the tribes of x and y'."
          },
          "keyInsight": "The magic is in the two optimizations: (1) Path compression makes find() nearly O(1) by flattening trees, (2) Union by rank keeps trees balanced by always attaching shorter tree to taller one.",
          "commonConfusion": [
            {
              "confusion": "What is Œ±(n)?",
              "clarification": "Inverse Ackermann function. Grows incredibly slowly - Œ±(10^80) < 5. For practical purposes, O(Œ±(n)) = O(1)."
            },
            {
              "confusion": "Why can't we delete/split?",
              "clarification": "Path compression destroys the original structure. We only know current root, not the path that got us there."
            },
            {
              "confusion": "Union by rank vs union by size?",
              "clarification": "Both work. Rank ‚âà tree height estimate. Size = actual elements. Both achieve O(Œ±(n)) with path compression."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Find (with path compression)",
                "average": "O(Œ±(n))",
                "worst": "O(Œ±(n))",
                "note": "Œ±(n) ‚âà O(1) practically"
              },
              {
                "operation": "Union (with rank)",
                "average": "O(Œ±(n))",
                "worst": "O(Œ±(n))",
                "note": "Two finds + O(1) link"
              },
              {
                "operation": "m operations total",
                "average": "O(m Œ±(n))",
                "worst": "O(m Œ±(n))",
                "note": "Nearly linear"
              }
            ],
            "explanation": "Œ±(n) is inverse Ackermann - effectively constant for any realistic input."
          },
          "space": {
            "complexity": "O(n)",
            "explanation": "Two arrays of size n: parent[] and rank[]."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Two arrays: parent[i] = parent of i, rank[i] = upper bound on height of subtree rooted at i.",
            "keyPoints": [
              "parent[i] = i means i is a root",
              "Path compression: during find, set parent directly to root",
              "Rank only updated during union, not affected by compression",
              "Can add size[] array if need to track set sizes"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Arrays for parent and rank. Initialize parent[i] = i.",
              "gotchas": [
                "Array.from({length: n}, (_, i) => i) for initialization",
                "Path compression: parent[x] = find(parent[x])",
                "Be careful with 0-indexed vs 1-indexed problems"
              ]
            },
            "python": {
              "implementation": "Lists for parent and rank. Can also use dict for non-integer keys.",
              "gotchas": [
                "list(range(n)) for parent initialization",
                "Dict-based DSU for string/object keys",
                "Python recursion limit may matter for very deep finds without compression"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "With both optimizations, operations are O(Œ±(n))",
            "proof": {
              "step1": {
                "action": "Union by rank: tree height ‚â§ log n",
                "cost": "Without compression, find is O(log n)"
              },
              "step2": {
                "action": "Path compression: nodes point directly to root",
                "cost": "Future finds on same path are O(1)"
              },
              "step3": {
                "action": "Combined: amortized analysis via potential function",
                "cost": "Proves O(Œ±(n)) per operation"
              },
              "step4": {
                "action": "Œ±(n) = inverse Ackermann, practically ‚â§ 4 for n < 10^600",
                "cost": "Effectively O(1)"
              }
            },
            "totalCost": "O(m Œ±(n)) for m operations on n elements"
          }
        },
        "codeTemplates": [
          {
            "name": "Union-Find with Path Compression & Rank",
            "description": "Optimal implementation with both optimizations",
            "javascript": {
              "code": "class UnionFind {\n  constructor(n) {\n    this.parent = Array.from({ length: n }, (_, i) => i);\n    this.rank = new Array(n).fill(0);\n    this.count = n;  // Number of disjoint sets\n  }\n  \n  find(x) {\n    if (this.parent[x] !== x) {\n      // Path compression: point directly to root\n      this.parent[x] = this.find(this.parent[x]);\n    }\n    return this.parent[x];\n  }\n  \n  union(x, y) {\n    const rootX = this.find(x);\n    const rootY = this.find(y);\n    \n    if (rootX === rootY) return false;  // Already same set\n    \n    // Union by rank: attach smaller tree under larger\n    if (this.rank[rootX] < this.rank[rootY]) {\n      this.parent[rootX] = rootY;\n    } else if (this.rank[rootX] > this.rank[rootY]) {\n      this.parent[rootY] = rootX;\n    } else {\n      this.parent[rootY] = rootX;\n      this.rank[rootX]++;\n    }\n    \n    this.count--;\n    return true;  // Union performed\n  }\n  \n  connected(x, y) {\n    return this.find(x) === this.find(y);\n  }\n  \n  getCount() {\n    return this.count;\n  }\n}\n\n// Usage:\n// const uf = new UnionFind(5);  // 5 elements: 0,1,2,3,4\n// uf.union(0, 1);  // Connect 0 and 1\n// uf.union(2, 3);  // Connect 2 and 3\n// uf.connected(0, 1);  // true\n// uf.connected(0, 2);  // false\n// uf.getCount();  // 3 sets: {0,1}, {2,3}, {4}",
              "notes": "Track count for 'number of components' problems. union() returns false if already connected."
            },
            "python": {
              "code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.count = n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        \n        if root_x == root_y:\n            return False\n        \n        if self.rank[root_x] < self.rank[root_y]:\n            self.parent[root_x] = root_y\n        elif self.rank[root_x] > self.rank[root_y]:\n            self.parent[root_y] = root_x\n        else:\n            self.parent[root_y] = root_x\n            self.rank[root_x] += 1\n        \n        self.count -= 1\n        return True\n    \n    def connected(self, x, y):\n        return self.find(x) == self.find(y)",
              "notes": "list(range(n)) initializes parent[i] = i efficiently."
            }
          },
          {
            "name": "Number of Connected Components",
            "description": "Count disjoint sets after processing edges",
            "javascript": {
              "code": "function countComponents(n, edges) {\n  const uf = new UnionFind(n);\n  \n  for (const [a, b] of edges) {\n    uf.union(a, b);\n  }\n  \n  return uf.getCount();\n}\n\n// Example: Number of Islands (grid version)\nfunction numIslands(grid) {\n  const rows = grid.length;\n  const cols = grid[0].length;\n  const uf = new UnionFind(rows * cols);\n  let water = 0;\n  \n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (grid[r][c] === '0') {\n        water++;\n        continue;\n      }\n      \n      // Connect with right and down neighbors\n      if (c + 1 < cols && grid[r][c + 1] === '1') {\n        uf.union(r * cols + c, r * cols + c + 1);\n      }\n      if (r + 1 < rows && grid[r + 1][c] === '1') {\n        uf.union(r * cols + c, (r + 1) * cols + c);\n      }\n    }\n  }\n  \n  return uf.getCount() - water;\n}\n\n// 2D ‚Üí 1D index: r * cols + c\n// This flattens grid for Union-Find",
              "notes": "Grid problems: flatten 2D to 1D index. Subtract water cells from count."
            },
            "python": {
              "code": "def count_components(n, edges):\n    uf = UnionFind(n)\n    \n    for a, b in edges:\n        uf.union(a, b)\n    \n    return uf.count\n\ndef num_islands(grid):\n    if not grid:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    uf = UnionFind(rows * cols)\n    water = 0\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '0':\n                water += 1\n                continue\n            \n            idx = r * cols + c\n            if c + 1 < cols and grid[r][c + 1] == '1':\n                uf.union(idx, idx + 1)\n            if r + 1 < rows and grid[r + 1][c] == '1':\n                uf.union(idx, idx + cols)\n    \n    return uf.count - water",
              "notes": "Union-Find alternative to DFS flood fill for Number of Islands."
            }
          },
          {
            "name": "Detect Cycle / Redundant Connection",
            "description": "Find edge that creates a cycle",
            "javascript": {
              "code": "// Find the edge that, if removed, makes graph a tree\n// (Graph has exactly one extra edge creating a cycle)\nfunction findRedundantConnection(edges) {\n  const n = edges.length;\n  const uf = new UnionFind(n + 1);  // 1-indexed\n  \n  for (const [a, b] of edges) {\n    // If a and b already connected, this edge creates cycle\n    if (uf.connected(a, b)) {\n      return [a, b];\n    }\n    uf.union(a, b);\n  }\n  \n  return [];\n}\n\n// Key insight:\n// Before union: if find(a) === find(b), they're already connected\n// Adding edge [a, b] would create a cycle\n// This is the redundant edge!",
              "notes": "If already connected before union, adding edge creates cycle."
            },
            "python": {
              "code": "def find_redundant_connection(edges):\n    n = len(edges)\n    uf = UnionFind(n + 1)  # 1-indexed nodes\n    \n    for a, b in edges:\n        if uf.connected(a, b):\n            return [a, b]\n        uf.union(a, b)\n    \n    return []\n\n# Application: Kruskal's MST\ndef kruskal_mst(n, edges):\n    # edges: [(weight, u, v), ...]\n    edges.sort()  # Sort by weight\n    uf = UnionFind(n)\n    mst = []\n    total_weight = 0\n    \n    for weight, u, v in edges:\n        if not uf.connected(u, v):\n            uf.union(u, v)\n            mst.append((u, v, weight))\n            total_weight += weight\n            \n            if len(mst) == n - 1:\n                break\n    \n    return mst, total_weight",
              "notes": "Kruskal: sort edges by weight, greedily add if doesn't create cycle."
            }
          }
        ],
        "visualTrace": {
          "title": "Union-Find Operations",
          "input": {
            "n": 5,
            "operations": "union(0,1), union(2,3), union(1,3), find(0), find(2)"
          },
          "steps": [
            {
              "op": "init",
              "parent": "[0,1,2,3,4]",
              "sets": "{0},{1},{2},{3},{4}"
            },
            {
              "op": "union(0,1)",
              "parent": "[0,0,2,3,4]",
              "sets": "{0,1},{2},{3},{4}",
              "note": "1's parent = 0"
            },
            {
              "op": "union(2,3)",
              "parent": "[0,0,2,2,4]",
              "sets": "{0,1},{2,3},{4}",
              "note": "3's parent = 2"
            },
            {
              "op": "union(1,3)",
              "parent": "[0,0,0,2,4]",
              "sets": "{0,1,2,3},{4}",
              "note": "find(1)=0, find(3)=2, 2's parent = 0"
            },
            {
              "op": "find(0)",
              "result": "0",
              "note": "0 is root"
            },
            {
              "op": "find(2)",
              "result": "0",
              "parent": "[0,0,0,0,4]",
              "note": "Path compression: 2‚Üí0 and 3‚Üí0"
            }
          ],
          "output": "Two sets: {0,1,2,3} and {4}. Path compression flattened tree."
        },
        "commonMistakes": [
          {
            "mistake": "Forgetting path compression",
            "wrong": "return parent[x]",
            "right": "parent[x] = find(parent[x]); return parent[x]",
            "explanation": "Without compression, find degrades to O(n) in worst case."
          },
          {
            "mistake": "Union without rank/size",
            "wrong": "parent[rootX] = rootY always",
            "right": "Attach smaller to larger",
            "explanation": "Unbalanced trees lead to O(log n) instead of O(Œ±(n))."
          },
          {
            "mistake": "Wrong initialization",
            "wrong": "parent = [0, 0, 0, ...]",
            "right": "parent[i] = i for all i",
            "explanation": "Each element starts as its own root."
          }
        ],
        "keyTakeaways": [
          "Union-Find tracks connectivity in disjoint sets",
          "Two operations: find(x) ‚Üí root, union(x,y) ‚Üí merge sets",
          "Path compression + union by rank = O(Œ±(n)) ‚âà O(1)",
          "Perfect for: connectivity queries, Kruskal MST, cycle detection",
          "Cannot split sets - only merge",
          "Return value of union() indicates if sets were different (cycle detection)"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Arrays",
              "why": "Parent and rank stored in arrays"
            },
            {
              "id": "tree",
              "label": "Trees",
              "why": "Sets are represented as trees"
            }
          ],
          "nextTopics": [
            {
              "id": "mst",
              "label": "Minimum Spanning Tree",
              "why": "Kruskal uses Union-Find"
            },
            {
              "id": "graph",
              "label": "Graph Algorithms",
              "why": "Connectivity applications"
            },
            {
              "id": "percolation",
              "label": "Percolation",
              "why": "Classic Union-Find application"
            }
          ]
        },
        "patternChain": {
          "description": "Union-Find is essential for graph connectivity problems",
          "buildsOn": [
            {
              "id": "array",
              "relationship": "Arrays for parent/rank storage",
              "whatToKnow": "Array indexing"
            },
            {
              "id": "tree",
              "relationship": "Sets represented as trees",
              "whatToKnow": "Tree structure"
            }
          ],
          "enables": [
            {
              "id": "kruskal",
              "relationship": "Cycle detection for MST",
              "patternName": "Kruskal's Algorithm",
              "interviewFrequency": "Medium"
            },
            {
              "id": "connected_components",
              "relationship": "Count/find components",
              "patternName": "Dynamic Connectivity",
              "interviewFrequency": "High"
            },
            {
              "id": "redundant_connection",
              "relationship": "Detect cycle-forming edge",
              "patternName": "Cycle Detection",
              "interviewFrequency": "High"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    ARR[Arrays] --> UF[Union-Find]\n    TREE[Trees] --> UF\n    UF --> MST[Kruskal MST]\n    UF --> CC[Connected Components]\n    UF --> CYCLE[Cycle Detection]\n    \n    style UF fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "vector_db",
      "label": "Vector Database",
      "type": "ds-modern",
      "description": "High-dimensional similarity search.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Vector_database"
          }
        ],
        "community": [
          {
            "title": "Pinecone: Vector Database",
            "url": "https://www.pinecone.io/learn/vector-database/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "4-5 hours",
      "companies": [
        "OpenAI",
        "Google",
        "Meta"
      ],
      "interviewFrequency": "medium",
      "category": "Modern DS",
      "categoryIcon": "üöÄ",
      "content": {
        "definition": {
          "simple": "Database optimized for storing and searching high-dimensional vectors. Powers AI/ML similarity search.",
          "technical": "Stores embeddings. Uses ANN algorithms (HNSW, IVF) for approximate nearest neighbor search."
        },
        "keyTakeaways": [
          "Stores high-dimensional vectors",
          "Approximate nearest neighbor search",
          "Powers semantic search, RAG",
          "Uses HNSW, IVF, PQ algorithms"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "hashing",
              "label": "Hashing",
              "why": "LSH for similarity"
            }
          ],
          "nextTopics": [
            {
              "id": "hnsw",
              "label": "HNSW",
              "why": "Core algorithm"
            }
          ]
        }
      }
    },
    {
      "id": "dynamic_array",
      "label": "Dynamic Array",
      "type": "ds-linear",
      "description": "Resizable array with amortized O(1) append.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Dynamic_array"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/how-do-dynamic-arrays-work/"
          }
        ]
      },
      "difficulty": 2,
      "timeEstimate": "1-2 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Linear DS",
      "categoryIcon": "üìä",
      "content": {
        "definition": {
          "simple": "An array that grows automatically when full. ArrayList in Java, vector in C++, list in Python.",
          "technical": "Doubles capacity when full. Amortized O(1) append despite occasional O(n) resize."
        },
        "keyTakeaways": [
          "Auto-resizes when full",
          "Doubles capacity (growth factor)",
          "Amortized O(1) append",
          "O(n) insert at beginning"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Arrays",
              "why": "Dynamic array wraps array"
            }
          ],
          "nextTopics": [
            {
              "id": "amortized_analysis",
              "label": "Amortized Analysis",
              "why": "Explains O(1) append"
            }
          ]
        }
      }
    },
    {
      "id": "amortized_analysis",
      "label": "Amortized Analysis",
      "type": "concept",
      "description": "Average cost over a sequence of operations (e.g., dynamic array resize).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Amortized_analysis"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/analysis-algorithm-set-5-amortized-analysis-introduction/"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2-3 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Concept",
      "categoryIcon": "üí°",
      "content": {
        "definition": {
          "simple": "Average cost per operation over a sequence, even if some operations are expensive.",
          "technical": "Total cost / number of operations. Accounts for occasional expensive ops amortized over many cheap ones."
        },
        "keyTakeaways": [
          "Average over sequence of ops",
          "Expensive ops are rare",
          "Dynamic array: amortized O(1) append",
          "Three methods: aggregate, accounting, potential"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "big_o",
              "label": "Big O",
              "why": "Understanding complexity"
            }
          ],
          "nextTopics": [
            {
              "id": "dynamic_array",
              "label": "Dynamic Array",
              "why": "Classic example"
            }
          ]
        }
      }
    },
    {
      "id": "set",
      "label": "Set",
      "type": "ds-hybrid",
      "description": "Unique elements; often implemented via hashing or trees.",
      "references": {
        "official": [
          {
            "title": "MDN Web Docs",
            "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/hash-table/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/set-in-cpp-stl/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "2-3 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft"
      ],
      "interviewFrequency": "high",
      "category": "Hybrid DS",
      "categoryIcon": "üîÄ",
      "content": {
        "definition": {
          "simple": "A collection of unique elements. No duplicates allowed.",
          "technical": "Typically implemented as hash set (O(1) ops) or tree set (O(log n) ops, ordered)."
        },
        "keyTakeaways": [
          "No duplicates",
          "Hash set: O(1) avg lookup",
          "Tree set: O(log n), maintains order",
          "Used for membership testing"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "hash_map",
              "label": "Hash Maps",
              "why": "Hash set uses similar structure"
            }
          ],
          "nextTopics": [
            {
              "id": "bloom",
              "label": "Bloom Filter",
              "why": "Probabilistic set"
            }
          ]
        }
      }
    },
    {
      "id": "deque",
      "label": "Deque",
      "type": "ds-abstract",
      "description": "Double-ended queue: push/pop from both ends.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Double-ended_queue"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/queue/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/deque-set-1-introduction-applications/"
          }
        ]
      },
      "difficulty": 2,
      "timeEstimate": "1-2 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon"
      ],
      "interviewFrequency": "medium",
      "category": "Abstract DS",
      "categoryIcon": "üì¶",
      "content": {
        "definition": {
          "simple": "Double-ended queue. Add/remove from both front and back in O(1).",
          "technical": "Supports push/pop at both ends. Implemented as circular buffer or doubly linked list."
        },
        "keyTakeaways": [
          "O(1) push/pop both ends",
          "Generalizes stack and queue",
          "Circular buffer implementation common",
          "Used in sliding window problems"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "queue",
              "label": "Queue",
              "why": "Deque extends queue"
            }
          ],
          "nextTopics": [
            {
              "id": "monotonic_queue",
              "label": "Monotonic Queue",
              "why": "Uses deque"
            }
          ]
        }
      }
    },
    {
      "id": "dll",
      "label": "Doubly Linked List",
      "type": "ds-linear",
      "description": "Linked list with prev/next pointers; enables O(1) removals with node handle.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Doubly_linked_list"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/list"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/doubly-linked-list/"
          }
        ]
      },
      "difficulty": 2,
      "timeEstimate": "1-2 hours",
      "companies": [
        "Meta",
        "Amazon"
      ],
      "interviewFrequency": "medium",
      "category": "Linear DS",
      "categoryIcon": "üìä",
      "content": {
        "definition": {
          "simple": "Linked list where each node points to both next AND previous nodes.",
          "technical": "Each node has prev and next pointers. O(1) insertion/deletion at known position. O(n) search."
        },
        "keyTakeaways": [
          "Bidirectional traversal",
          "O(1) delete if you have the node",
          "More memory per node (2 pointers)",
          "Used in LRU cache, undo systems"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "linked_list",
              "label": "Linked List",
              "why": "DLL extends singly linked"
            }
          ],
          "nextTopics": [
            {
              "id": "lru_cache",
              "label": "LRU Cache",
              "why": "Classic DLL application"
            }
          ]
        }
      }
    },
    {
      "id": "prefix_sum",
      "label": "Prefix Sum",
      "type": "algo-pattern",
      "description": "Precompute cumulative sums to answer range queries fast.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Prefix_sum"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/prefix-sum/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/prefix-sum-array-implementation-applications-competitive-programming/"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2-3 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon"
      ],
      "interviewFrequency": "medium",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "interviewQuestions": [
        {
          "name": "Range Sum Query - Immutable",
          "leetcode": "https://leetcode.com/problems/range-sum-query-immutable/",
          "difficulty": "Easy",
          "companies": [
            "Amazon",
            "Google"
          ],
          "frequency": "High",
          "whyAsked": "Basic prefix sum - precompute for O(1) range queries",
          "approach": "prefix[i] = sum of nums[0..i-1]. Range sum = prefix[right+1] - prefix[left]",
          "followUps": [
            {
              "question": "2D range sum?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "With updates (mutable)?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Subarray Sum Equals K",
          "leetcode": "https://leetcode.com/problems/subarray-sum-equals-k/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Google",
            "Amazon"
          ],
          "frequency": "Very High",
          "whyAsked": "Prefix sum + hash map - count subarrays technique",
          "approach": "Store prefix sum counts. For current prefix p, count += map[p - k]",
          "followUps": [
            {
              "question": "Longest subarray with sum k?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Divisible by k?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "teamblind"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Blind (Teamblind)",
              "url": "https://www.teamblind.com/",
              "note": "Crowdsourced FAANG interview experiences"
            }
          ]
        },
        {
          "name": "Continuous Subarray Sum",
          "leetcode": "https://leetcode.com/problems/continuous-subarray-sum/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon"
          ],
          "frequency": "High",
          "whyAsked": "Prefix sum with modulo - check divisibility",
          "approach": "Store (prefix % k) -> index. If same mod seen at distance >= 2, return true",
          "followUps": [
            {
              "question": "Count such subarrays?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Multiple k values?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Product of Array Except Self",
          "leetcode": "https://leetcode.com/problems/product-of-array-except-self/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Apple",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Prefix and suffix products without division",
          "approach": "First pass: prefix products. Second pass: multiply by suffix products",
          "followUps": [
            {
              "question": "Handle zeros?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "With division allowed?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Range Sum Query 2D - Immutable",
          "leetcode": "https://leetcode.com/problems/range-sum-query-2d-immutable/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Meta"
          ],
          "frequency": "Medium",
          "whyAsked": "2D prefix sum with inclusion-exclusion",
          "approach": "prefix[i][j] = sum of rectangle (0,0) to (i-1,j-1). Use inclusion-exclusion for query",
          "followUps": [
            {
              "question": "With updates?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Maximum sum rectangle?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based categorization"
        },
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with videos"
        }
      ],
      "content": {
        "definition": {
          "simple": "A prefix sum array stores cumulative sums. prefix[i] = sum of arr[0..i]. This lets you calculate ANY range sum in O(1) using prefix[right] - prefix[left-1].",
          "technical": "A prefix sum (cumulative sum) array is a preprocessed data structure where each element i contains the sum of all elements from index 0 to i in the original array. This enables O(1) range sum queries after O(n) preprocessing, trading space for query time."
        },
        "howItWorks": {
          "explanation": "Imagine a running total as you walk through an array. If you want the sum from index 3 to 7, you take the total at 7 and subtract the total at 2 (before 3). That difference is your range sum!",
          "steps": [
            {
              "step": 1,
              "title": "Build Prefix Array",
              "description": "prefix[0] = arr[0], then prefix[i] = prefix[i-1] + arr[i]",
              "why": "Accumulate sums left to right."
            },
            {
              "step": 2,
              "title": "Handle Edge Cases",
              "description": "Often use prefix[i] = sum of first i elements, with prefix[0] = 0",
              "why": "Simplifies range queries (no special case for left=0)."
            },
            {
              "step": 3,
              "title": "Query Range Sum",
              "description": "sum(L, R) = prefix[R+1] - prefix[L]",
              "why": "Subtract 'before L' from 'through R'."
            },
            {
              "step": 4,
              "title": "Extend to 2D",
              "description": "2D prefix sums enable O(1) submatrix sum queries",
              "why": "Same idea: include-exclude with rectangle corners."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph TD\n    subgraph \"Array: [2, 4, 1, 3, 5]\"\n        A0[2] --> A1[4] --> A2[1] --> A3[3] --> A4[5]\n    end\n    subgraph \"Prefix: [0, 2, 6, 7, 10, 15]\"\n        P0[0] --> P1[2] --> P2[6] --> P3[7] --> P4[10] --> P5[15]\n    end\n    \n    subgraph \"Query: sum(1,3) = prefix[4] - prefix[1] = 10 - 2 = 8\"\n        Q[\"4 + 1 + 3 = 8 ‚úì\"]\n    end",
            "caption": "Prefix[0]=0 for easier math. Range sum = difference of prefix values."
          }
        },
        "whenToUse": {
          "summary": "Use when you need multiple range sum queries on a static array.",
          "patterns": [
            {
              "pattern": "Range Sum Queries",
              "signal": "Multiple queries asking sum of subarrays",
              "example": "Sum of elements from index L to R",
              "withoutIt": "O(n) per query = O(n*q) for q queries",
              "withIt": "O(n) build + O(1) per query = O(n+q)"
            },
            {
              "pattern": "Subarray Sum Equals K",
              "signal": "Count/find subarrays with specific sum",
              "example": "How many subarrays sum to K?",
              "withoutIt": "O(n¬≤) checking all pairs",
              "withIt": "O(n) with prefix sum + hash map"
            },
            {
              "pattern": "Equilibrium Index",
              "signal": "Find where left sum = right sum",
              "example": "Split array into equal sum parts",
              "withoutIt": "O(n¬≤) computing both sums repeatedly",
              "withIt": "O(n) with prefix sums"
            },
            {
              "pattern": "2D Range Sum",
              "signal": "Sum of submatrix",
              "example": "Sum of rectangle in 2D grid",
              "withoutIt": "O(rows * cols) per query",
              "withIt": "O(1) per query after O(mn) build"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "When array is frequently updated or when you need more than sums.",
          "antiPatterns": [
            {
              "situation": "Frequent Updates",
              "why": "Updating one element requires rebuilding entire prefix array",
              "useInstead": "Segment Tree or Fenwick Tree",
              "example": "Array changes between queries"
            },
            {
              "situation": "Non-Sum Aggregations",
              "why": "Prefix sum only works for addition (not max, min, gcd)",
              "useInstead": "Segment Tree for range max/min",
              "example": "Range maximum query"
            },
            {
              "situation": "Single Query",
              "why": "O(n) build for one O(n) query - no benefit",
              "useInstead": "Direct summation",
              "example": "One-time sum calculation"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Odometer Trick",
            "story": "Your car odometer shows total miles traveled. To find miles driven on a trip, you don't need to track every mile - just subtract starting odometer from ending odometer. prefix[end] - prefix[start] gives you the 'distance traveled' (sum) in that range.",
            "connection": "Prefix sums are running totals. Any segment sum = total at end - total at start."
          },
          "keyInsight": "The magic of prefix sums: any contiguous sum can be expressed as a DIFFERENCE of two cumulative sums. This turns O(n) range sum into O(1) subtraction.",
          "commonConfusion": [
            {
              "confusion": "Off-by-one errors",
              "clarification": "Use prefix[0]=0 convention. Then sum(L,R) = prefix[R+1] - prefix[L]. This handles L=0 naturally."
            },
            {
              "confusion": "When to use hash map with prefix sum?",
              "clarification": "When looking for subarrays with sum K: if prefix[i] - prefix[j] = K, then prefix[j] = prefix[i] - K. Hash map stores seen prefix sums."
            },
            {
              "confusion": "2D prefix sum formula?",
              "clarification": "Include-exclude: sum(r1,c1,r2,c2) = P[r2][c2] - P[r1-1][c2] - P[r2][c1-1] + P[r1-1][c1-1]"
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Build Prefix Array",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Single pass through array"
              },
              {
                "operation": "Range Sum Query",
                "average": "O(1)",
                "worst": "O(1)",
                "note": "Just subtraction"
              },
              {
                "operation": "Subarray Sum = K",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "With hash map"
              },
              {
                "operation": "2D Prefix Build",
                "average": "O(mn)",
                "worst": "O(mn)",
                "note": "Process each cell once"
              }
            ],
            "explanation": "Build once, query many times in O(1)."
          },
          "space": {
            "complexity": "O(n) or O(mn) for 2D",
            "explanation": "Extra array of same size as input."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Prefix array is typically one element larger than original for cleaner indexing.",
            "keyPoints": [
              "prefix[0] = 0 (sentinel) makes formula uniform",
              "prefix[i] = sum of arr[0..i-1] (first i elements)",
              "Query: sum(L, R) = prefix[R+1] - prefix[L]",
              "For 2D: prefix[i][j] = sum of submatrix (0,0) to (i-1,j-1)"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Use Array with reduce or explicit loop",
              "gotchas": [
                "Initialize with size n+1 and prefix[0] = 0",
                "BigInt may be needed for large sums",
                "0-indexing requires careful bounds"
              ]
            },
            "python": {
              "implementation": "Use itertools.accumulate or manual loop",
              "gotchas": [
                "itertools.accumulate returns iterator, convert to list",
                "Add [0] at start for sentinel",
                "Use defaultdict(int) for subarray sum counting"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Range sum query is O(1) after O(n) preprocessing",
            "proof": {
              "step1": {
                "action": "Build: compute prefix[i] = prefix[i-1] + arr[i-1]",
                "cost": "O(n) - one pass"
              },
              "step2": {
                "action": "Query: sum(L,R) = prefix[R+1] - prefix[L]",
                "cost": "O(1) - two lookups, one subtraction"
              },
              "step3": {
                "action": "Mathematical correctness",
                "cost": "prefix[R+1] = Œ£arr[0..R], prefix[L] = Œ£arr[0..L-1]"
              },
              "step4": {
                "action": "Difference = Œ£arr[L..R]",
                "cost": "‚úì Correct range sum"
              }
            },
            "totalCost": "O(n) build + O(1) per query"
          }
        },
        "codeTemplates": [
          {
            "name": "Prefix Sum Basics",
            "description": "Build prefix array and query range sums",
            "javascript": {
              "code": "function buildPrefixSum(arr) {\n  const n = arr.length;\n  const prefix = new Array(n + 1).fill(0);\n  \n  for (let i = 0; i < n; i++) {\n    prefix[i + 1] = prefix[i] + arr[i];\n  }\n  \n  return prefix;\n}\n\nfunction rangeSum(prefix, left, right) {\n  // Sum of arr[left..right] inclusive\n  return prefix[right + 1] - prefix[left];\n}\n\n// Example\nconst arr = [2, 4, 1, 3, 5];\nconst prefix = buildPrefixSum(arr);  // [0, 2, 6, 7, 10, 15]\n\nconsole.log(rangeSum(prefix, 1, 3));  // 4+1+3 = 8\nconsole.log(rangeSum(prefix, 0, 4));  // 2+4+1+3+5 = 15\nconsole.log(rangeSum(prefix, 2, 2));  // 1",
              "notes": "prefix[0]=0 is the key to clean code. No special cases!"
            },
            "python": {
              "code": "from itertools import accumulate\n\ndef build_prefix_sum(arr):\n    # [0] + cumulative sums\n    return [0] + list(accumulate(arr))\n\ndef range_sum(prefix, left, right):\n    return prefix[right + 1] - prefix[left]\n\n# Manual version (clearer)\ndef build_prefix_sum_manual(arr):\n    n = len(arr)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + arr[i]\n    return prefix\n\n# Example\narr = [2, 4, 1, 3, 5]\nprefix = build_prefix_sum(arr)  # [0, 2, 6, 7, 10, 15]\n\nprint(range_sum(prefix, 1, 3))  # 8\nprint(range_sum(prefix, 0, 4))  # 15",
              "notes": "itertools.accumulate is Pythonic. Add [0] at start."
            }
          },
          {
            "name": "Subarray Sum Equals K",
            "description": "Count subarrays with sum exactly K",
            "javascript": {
              "code": "function subarraySum(nums, k) {\n  let count = 0;\n  let prefixSum = 0;\n  const prefixCounts = new Map([[0, 1]]);  // Sum 0 seen once (empty prefix)\n  \n  for (const num of nums) {\n    prefixSum += num;\n    \n    // If (prefixSum - k) was seen before, those are valid subarrays\n    if (prefixCounts.has(prefixSum - k)) {\n      count += prefixCounts.get(prefixSum - k);\n    }\n    \n    // Record this prefix sum\n    prefixCounts.set(prefixSum, (prefixCounts.get(prefixSum) || 0) + 1);\n  }\n  \n  return count;\n}\n\n// Why it works:\n// If prefix[j] - prefix[i] = k, then subarray [i+1..j] sums to k\n// We look for prefix[i] = prefix[j] - k\n// Hash map counts how many times each prefix sum appeared\n\n// Example: nums = [1, 1, 1], k = 2\n// i=0: prefix=1, need 1-2=-1, not found, map={0:1, 1:1}\n// i=1: prefix=2, need 2-2=0, found 1 time! count=1, map={0:1, 1:1, 2:1}\n// i=2: prefix=3, need 3-2=1, found 1 time! count=2, map={0:1, 1:1, 2:1, 3:1}",
              "notes": "Key: map[0]=1 handles subarrays starting at index 0."
            },
            "python": {
              "code": "from collections import defaultdict\n\ndef subarray_sum(nums, k):\n    count = 0\n    prefix_sum = 0\n    prefix_counts = defaultdict(int)\n    prefix_counts[0] = 1  # Empty prefix sum = 0\n    \n    for num in nums:\n        prefix_sum += num\n        \n        # Count subarrays ending here with sum k\n        count += prefix_counts[prefix_sum - k]\n        \n        # Record this prefix sum\n        prefix_counts[prefix_sum] += 1\n    \n    return count\n\n# Alternative: find if any subarray sums to k (boolean)\ndef has_subarray_sum(nums, k):\n    seen = {0}\n    prefix = 0\n    \n    for num in nums:\n        prefix += num\n        if prefix - k in seen:\n            return True\n        seen.add(prefix)\n    \n    return False",
              "notes": "defaultdict(int) avoids get() checks. Cleaner code."
            }
          },
          {
            "name": "2D Prefix Sum (Submatrix Sum)",
            "description": "O(1) submatrix sum queries",
            "javascript": {
              "code": "class NumMatrix {\n  constructor(matrix) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    \n    // prefix[i][j] = sum of matrix[0..i-1][0..j-1]\n    this.prefix = Array.from({ length: m + 1 }, \n                    () => new Array(n + 1).fill(0));\n    \n    for (let i = 0; i < m; i++) {\n      for (let j = 0; j < n; j++) {\n        this.prefix[i + 1][j + 1] = matrix[i][j]\n          + this.prefix[i][j + 1]\n          + this.prefix[i + 1][j]\n          - this.prefix[i][j];\n      }\n    }\n  }\n  \n  sumRegion(row1, col1, row2, col2) {\n    // Include-exclude principle\n    return this.prefix[row2 + 1][col2 + 1]\n         - this.prefix[row1][col2 + 1]\n         - this.prefix[row2 + 1][col1]\n         + this.prefix[row1][col1];\n  }\n}\n\n// Visual of 2D include-exclude:\n// +---+---+\n// | A | B |   Sum of D = Total - A - B - C + (corner double-subtracted)\n// +---+---+   sumRegion(r1,c1,r2,c2) = P[r2+1][c2+1] - P[r1][c2+1] \n// | C | D |                          - P[r2+1][c1] + P[r1][c1]\n// +---+---+",
              "notes": "Include-exclude: add corner back that was subtracted twice."
            },
            "python": {
              "code": "class NumMatrix:\n    def __init__(self, matrix):\n        m, n = len(matrix), len(matrix[0])\n        self.prefix = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m):\n            for j in range(n):\n                self.prefix[i+1][j+1] = (matrix[i][j] \n                    + self.prefix[i][j+1] \n                    + self.prefix[i+1][j] \n                    - self.prefix[i][j])\n    \n    def sum_region(self, row1, col1, row2, col2):\n        return (self.prefix[row2+1][col2+1]\n              - self.prefix[row1][col2+1]\n              - self.prefix[row2+1][col1]\n              + self.prefix[row1][col1])\n\n# Example usage:\n# matrix = [[3,0,1,4,2],\n#           [5,6,3,2,1],\n#           [1,2,0,1,5],\n#           [4,1,0,1,7],\n#           [1,0,3,0,5]]\n# nm = NumMatrix(matrix)\n# nm.sum_region(2, 1, 4, 3)  # Sum of submatrix [2:4][1:3] = 8",
              "notes": "Build O(mn), query O(1). Space O(mn)."
            }
          }
        ],
        "visualTrace": {
          "title": "Subarray Sum Equals K for [1, 2, 3] with k=3",
          "input": {
            "array": "[1, 2, 3]",
            "k": 3
          },
          "steps": [
            {
              "i": 0,
              "val": 1,
              "prefixSum": 1,
              "need": "1-3=-2",
              "found": 0,
              "count": 0,
              "map": "{0:1, 1:1}"
            },
            {
              "i": 1,
              "val": 2,
              "prefixSum": 3,
              "need": "3-3=0",
              "found": 1,
              "count": 1,
              "map": "{0:1, 1:1, 3:1}"
            },
            {
              "i": 2,
              "val": 3,
              "prefixSum": 6,
              "need": "6-3=3",
              "found": 1,
              "count": 2,
              "map": "{0:1, 1:1, 3:1, 6:1}"
            }
          ],
          "output": "2 subarrays: [1,2] (1+2=3) and [3] (3=3)"
        },
        "commonMistakes": [
          {
            "mistake": "Off-by-one in range query",
            "wrong": "prefix[right] - prefix[left]",
            "right": "prefix[right+1] - prefix[left]",
            "explanation": "With prefix[0]=0 convention, indices shift by 1."
          },
          {
            "mistake": "Forgetting prefix[0]=1 in subarray sum",
            "wrong": "Start with empty map",
            "right": "map[0] = 1",
            "explanation": "Handles subarrays that start from index 0."
          },
          {
            "mistake": "2D formula wrong",
            "wrong": "Just subtract two rectangles",
            "right": "Include-exclude with 4 terms",
            "explanation": "Corner is subtracted twice, must add back once."
          }
        ],
        "keyTakeaways": [
          "Prefix sum: prefix[i] = sum of arr[0..i-1]",
          "Range sum: O(1) via prefix[right+1] - prefix[left]",
          "prefix[0]=0 convention eliminates edge case handling",
          "Subarray sum = K: use hash map of seen prefix sums",
          "2D: include-exclude principle with 4 corner terms",
          "Trade O(n) space for O(1) query time (after O(n) build)"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Arrays",
              "why": "Prefix sum built on arrays"
            },
            {
              "id": "hashmap",
              "label": "Hash Map",
              "why": "Often used together for O(n) solutions"
            }
          ],
          "nextTopics": [
            {
              "id": "difference_array",
              "label": "Difference Array",
              "why": "Inverse operation - range updates"
            },
            {
              "id": "fenwick",
              "label": "Fenwick Tree",
              "why": "Prefix sum with updates"
            },
            {
              "id": "dp",
              "label": "Dynamic Programming",
              "why": "Prefix sums are a form of DP"
            }
          ]
        },
        "patternChain": {
          "description": "Prefix sum enables O(1) range queries and subarray sum problems",
          "buildsOn": [
            {
              "id": "array",
              "relationship": "Preprocessed array for fast queries",
              "whatToKnow": "Array traversal"
            },
            {
              "id": "hashmap",
              "relationship": "HashMap stores seen prefix sums",
              "whatToKnow": "O(1) lookup"
            }
          ],
          "enables": [
            {
              "id": "subarray_sum",
              "relationship": "Count subarrays with sum K",
              "patternName": "Prefix + HashMap",
              "interviewFrequency": "Very High"
            },
            {
              "id": "range_query",
              "relationship": "O(1) range sum",
              "patternName": "Prefix Sum",
              "interviewFrequency": "High"
            },
            {
              "id": "2d_prefix",
              "relationship": "O(1) submatrix sum",
              "patternName": "2D Prefix",
              "interviewFrequency": "Medium"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    ARR[Arrays] --> PS[Prefix Sum]\n    HM[Hash Map] --> PS\n    PS --> RSQ[Range Sum Query]\n    PS --> SUB[Subarray Sum = K]\n    PS --> 2D[2D Prefix Sum]\n    PS --> DIFF[Difference Array]\n    \n    style PS fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "difference_array",
      "label": "Difference Array",
      "type": "algo-pattern",
      "description": "Efficient range updates using diff representation.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Prefix_sum"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/difference-array-range-update-query-o1/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "content": {
        "definition": {
          "simple": "Store differences between consecutive elements. Allows O(1) range updates.",
          "technical": "diff[i] = arr[i] - arr[i-1]. Range update [l,r] by +k: diff[l]+=k, diff[r+1]-=k. Reconstruct with prefix sum."
        },
        "keyTakeaways": [
          "O(1) range updates",
          "O(n) to reconstruct array",
          "Prefix sum of diff = original",
          "Used for range increment queries"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "prefix_sum",
              "label": "Prefix Sum",
              "why": "Inverse relationship"
            }
          ],
          "nextTopics": [
            {
              "id": "fenwick",
              "label": "Fenwick Tree",
              "why": "Advanced range queries"
            }
          ]
        }
      }
    },
    {
      "id": "monotonic_stack",
      "label": "Monotonic Stack",
      "type": "algo-pattern",
      "description": "Stack maintaining monotonic order to solve next/prev greater/smaller.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Stack_(abstract_data_type)"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/monotonic-stack/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/introduction-to-monotonic-stack-data-structure-and-algorithm-tutorials/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-5 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Bloomberg"
      ],
      "interviewFrequency": "medium",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "interviewQuestions": [
        {
          "name": "Daily Temperatures",
          "leetcode": "https://leetcode.com/problems/daily-temperatures/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google"
          ],
          "frequency": "Very High",
          "whyAsked": "Classic monotonic decreasing stack - next greater element pattern",
          "approach": "Stack of indices. Pop when current > stack top. Answer = curr_idx - popped_idx",
          "followUps": [
            {
              "question": "Next greater element I/II?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Circular array?",
              "answer": "Max of: normal Kadane, or total_sum - min_subarray_sum. Handle all-negative case."
            }
          ],
          "sources": [
            "neetcode150",
            "seanprashad"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Sean Prashad's Patterns",
              "url": "https://seanprashad.com/leetcode-patterns/",
              "note": "Pattern-based categorization"
            }
          ]
        },
        {
          "name": "Next Greater Element I",
          "leetcode": "https://leetcode.com/problems/next-greater-element-i/",
          "difficulty": "Easy",
          "companies": [
            "Amazon",
            "Google"
          ],
          "frequency": "High",
          "whyAsked": "Basic monotonic stack introduction",
          "approach": "Build next greater map for nums2 using stack. Query for nums1 elements",
          "followUps": [
            {
              "question": "Next Greater Element II (circular)?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Next Smaller Element?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Largest Rectangle in Histogram",
          "leetcode": "https://leetcode.com/problems/largest-rectangle-in-histogram/",
          "difficulty": "Hard",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Microsoft",
            "Flipkart"
          ],
          "frequency": "Very High",
          "whyAsked": "Advanced monotonic increasing stack - finding spans",
          "approach": "Stack of increasing heights. On smaller bar, pop and calculate area with width",
          "followUps": [
            {
              "question": "Maximal rectangle in binary matrix?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Trapping rain water?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "teamblind"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Blind (Teamblind)",
              "url": "https://www.teamblind.com/",
              "note": "Crowdsourced FAANG interview experiences"
            }
          ]
        },
        {
          "name": "Maximal Rectangle",
          "leetcode": "https://leetcode.com/problems/maximal-rectangle/",
          "difficulty": "Hard",
          "companies": [
            "Amazon",
            "Google",
            "Meta"
          ],
          "frequency": "High",
          "whyAsked": "Histogram problem applied row by row",
          "approach": "Build histogram per row. Apply Largest Rectangle in Histogram to each row",
          "followUps": [
            {
              "question": "Count all rectangles?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Largest square?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "teamblind"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Blind (Teamblind)",
              "url": "https://www.teamblind.com/",
              "note": "Crowdsourced FAANG interview experiences"
            }
          ]
        },
        {
          "name": "Trapping Rain Water",
          "leetcode": "https://leetcode.com/problems/trapping-rain-water/",
          "difficulty": "Hard",
          "companies": [
            "Amazon",
            "Google",
            "Meta",
            "Goldman Sachs"
          ],
          "frequency": "Very High",
          "whyAsked": "Can use monotonic stack OR two pointers",
          "approach": "Stack: pop when higher bar found, calculate water. Or two-pointer with maxL/maxR",
          "followUps": [
            {
              "question": "3D version?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "With obstacles?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Remove K Digits",
          "leetcode": "https://leetcode.com/problems/remove-k-digits/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Microsoft",
            "Google"
          ],
          "frequency": "Medium",
          "whyAsked": "Monotonic increasing stack to build smallest number",
          "approach": "Pop larger digits when smaller one comes. Limit pops to k. Handle leading zeros",
          "followUps": [
            {
              "question": "Create maximum number?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Remove to make palindrome?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based categorization"
        },
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with videos"
        }
      ],
      "content": {
        "definition": {
          "simple": "A monotonic stack is a stack that maintains elements in sorted order (increasing or decreasing). When you push, you pop elements that would break the order. It's perfect for 'next greater/smaller element' problems.",
          "technical": "A monotonic stack is a stack data structure that maintains elements in strictly increasing or decreasing order. On each insertion, elements violating the monotonic property are popped. This enables O(n) solutions for problems requiring next greater/smaller elements, as each element is pushed and popped at most once."
        },
        "howItWorks": {
          "explanation": "Imagine people standing in line by height. A 'monotonically decreasing stack' means each person is shorter than the one before. When a tall person arrives, shorter people in front leave (pop) until finding someone taller. The person just popped found their 'next taller' - it's the newcomer!",
          "steps": [
            {
              "step": 1,
              "title": "Choose Monotonic Type",
              "description": "Increasing for 'next smaller', decreasing for 'next greater'.",
              "why": "Determines what we're looking for."
            },
            {
              "step": 2,
              "title": "Iterate Through Elements",
              "description": "For each element, compare with stack top.",
              "why": "Check if monotonic property violated."
            },
            {
              "step": 3,
              "title": "Pop While Violated",
              "description": "Pop elements that break monotonic order.",
              "why": "Current element is the 'answer' for popped elements."
            },
            {
              "step": 4,
              "title": "Record Answer",
              "description": "For each popped element, current element is its next greater/smaller.",
              "why": "We found what they were 'waiting' for."
            },
            {
              "step": 5,
              "title": "Push Current",
              "description": "Add current element to stack.",
              "why": "It now 'waits' for its next greater/smaller."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph LR\n    subgraph \"Decreasing Stack for Next Greater\"\n        A[\"Push 3\"] --> B[\"Stack: [3]\"]\n        B --> C[\"Push 1\"] \n        C --> D[\"Stack: [3,1]\"]\n        D --> E[\"Push 4: Pop 1,3\"]\n        E --> F[\"Stack: [4]\"]\n    end\n    \n    style E fill:#ee6c4d\n    style F fill:#98c1d9",
            "caption": "4 is next greater for both 1 and 3. They're popped when 4 arrives."
          }
        },
        "whenToUse": {
          "summary": "Use when you need to find 'next greater/smaller' or 'previous greater/smaller' for each element in O(n).",
          "patterns": [
            {
              "pattern": "Next Greater Element",
              "signal": "For each element, find first larger to the right",
              "example": "Daily temperatures - days until warmer",
              "withoutIt": "O(n¬≤) checking each element against all right",
              "withIt": "O(n) - each element pushed/popped once"
            },
            {
              "pattern": "Largest Rectangle in Histogram",
              "signal": "Max area with height constraints",
              "example": "Largest rectangle under histogram bars",
              "withoutIt": "O(n¬≤) checking each bar as minimum",
              "withIt": "O(n) using previous/next smaller"
            },
            {
              "pattern": "Stock Span",
              "signal": "Consecutive days with price ‚â§ today",
              "example": "Stock span problem",
              "withoutIt": "O(n¬≤) looking back each day",
              "withIt": "O(n) with decreasing stack"
            },
            {
              "pattern": "Trapping Rain Water",
              "signal": "Water trapped between bars",
              "example": "Calculate trapped rainwater",
              "withoutIt": "O(n) with prefix max arrays",
              "withIt": "O(n) single pass with stack"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "When order doesn't matter or when you need more than just next/previous greater/smaller.",
          "antiPatterns": [
            {
              "situation": "Finding K-th Greatest",
              "why": "Stack only tracks immediate next",
              "useInstead": "Heap or sorting",
              "example": "3rd largest element"
            },
            {
              "situation": "Unsorted Output Needed",
              "why": "Stack gives sequential relationships",
              "useInstead": "Different data structure",
              "example": "Random access queries"
            },
            {
              "situation": "Two-Dimensional Problems",
              "why": "Stack is inherently 1D",
              "useInstead": "2D DP or segment tree",
              "example": "Maximal rectangle in matrix (though 1D histogram per row works)"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Bouncer at a Club",
            "story": "Imagine a line of people waiting to enter a club. A bouncer (the stack) only allows people in if they're taller than everyone already inside. When someone tall arrives, shorter people already inside are kicked out (popped) - they've 'found' the person taller than them.",
            "connection": "Stack maintains the 'worthy' elements. When a new element kicks out old ones, those old ones have found their 'answer' (next greater)."
          },
          "keyInsight": "Each element is pushed exactly once and popped at most once. This guarantees O(n) total, even though inner loop may pop multiple elements. The 'answer' for a popped element is always the element currently being processed.",
          "commonConfusion": [
            {
              "confusion": "Increasing vs Decreasing stack?",
              "clarification": "Decreasing: elements decrease top-to-bottom (next GREATER). Increasing: elements increase top-to-bottom (next SMALLER)."
            },
            {
              "confusion": "Why O(n) if there's a while loop?",
              "clarification": "Each element pushed once, popped once. Total operations = 2n = O(n). Amortized analysis."
            },
            {
              "confusion": "Store values or indices?",
              "clarification": "Usually indices - lets you calculate distances and access original values. Values alone can't give positions."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Next Greater Element",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Each element pushed/popped once"
              },
              {
                "operation": "Largest Rectangle",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Two passes or one pass with sentinel"
              },
              {
                "operation": "Stock Span",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Amortized O(1) per element"
              }
            ],
            "explanation": "Always O(n) because total pushes + pops ‚â§ 2n."
          },
          "space": {
            "complexity": "O(n)",
            "explanation": "Stack can hold all elements in worst case (already sorted input)."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Stack stores indices (not values) for most problems. This allows position calculations.",
            "keyPoints": [
              "Store indices to calculate distances (e.g., days until warmer)",
              "Access arr[stack.top()] to get actual values",
              "Sentinel values (-1 or n) can simplify edge cases",
              "Result array initialized to -1 or 0 for 'no answer' cases"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Use array as stack with push/pop. Store indices.",
              "gotchas": [
                "arr.at(-1) for peek (stack top) in modern JS",
                "Initialize result with -1 or suitable default",
                "Be careful with empty stack checks"
              ]
            },
            "python": {
              "implementation": "List as stack with append/pop. stack[-1] for peek.",
              "gotchas": [
                "list[-1] for peek, but check `if stack` first",
                "enumerate() useful for tracking indices",
                "Consider adding sentinel to avoid edge case handling"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Monotonic stack processes n elements in O(n)",
            "proof": {
              "step1": {
                "action": "Each element is pushed exactly once",
                "cost": "n push operations"
              },
              "step2": {
                "action": "Each element is popped at most once",
                "cost": "‚â§ n pop operations"
              },
              "step3": {
                "action": "Total operations",
                "cost": "‚â§ 2n = O(n)"
              },
              "step4": {
                "action": "While loop iterations across ALL elements",
                "cost": "Bounded by total pops = n"
              }
            },
            "totalCost": "O(n) amortized"
          }
        },
        "codeTemplates": [
          {
            "name": "Next Greater Element",
            "description": "For each element, find first greater to the right",
            "javascript": {
              "code": "function nextGreaterElement(nums) {\n  const n = nums.length;\n  const result = new Array(n).fill(-1);  // -1 if no greater\n  const stack = [];  // Store INDICES\n  \n  for (let i = 0; i < n; i++) {\n    // Pop smaller elements - they found their next greater\n    while (stack.length && nums[stack.at(-1)] < nums[i]) {\n      const idx = stack.pop();\n      result[idx] = nums[i];\n    }\n    \n    stack.push(i);\n  }\n  \n  return result;\n}\n\n// Example: [2, 1, 2, 4, 3]\n// i=0: push 0, stack=[0]\n// i=1: 1 < 2, push 1, stack=[0,1]\n// i=2: 2 > 1, pop 1‚Üíresult[1]=2, 2 == 2 no pop, push 2, stack=[0,2]\n// i=3: 4 > 2, pop 2‚Üíresult[2]=4, 4 > 2, pop 0‚Üíresult[0]=4, push 3\n// i=4: 3 < 4, push 4\n// Result: [4, 2, 4, -1, -1]",
              "notes": "Decreasing stack (top to bottom). Pop when current > top."
            },
            "python": {
              "code": "def next_greater_element(nums):\n    n = len(nums)\n    result = [-1] * n\n    stack = []  # Indices\n    \n    for i, num in enumerate(nums):\n        while stack and nums[stack[-1]] < num:\n            idx = stack.pop()\n            result[idx] = num\n        \n        stack.append(i)\n    \n    return result\n\n# Next Smaller Element (just change comparison)\ndef next_smaller_element(nums):\n    n = len(nums)\n    result = [-1] * n\n    stack = []\n    \n    for i, num in enumerate(nums):\n        while stack and nums[stack[-1]] > num:  # > instead of <\n            idx = stack.pop()\n            result[idx] = num\n        \n        stack.append(i)\n    \n    return result",
              "notes": "For 'smaller', use increasing stack (change < to >)."
            }
          },
          {
            "name": "Daily Temperatures",
            "description": "Days until warmer temperature",
            "javascript": {
              "code": "function dailyTemperatures(temperatures) {\n  const n = temperatures.length;\n  const result = new Array(n).fill(0);  // 0 if no warmer day\n  const stack = [];  // Indices of days waiting for warmer\n  \n  for (let i = 0; i < n; i++) {\n    while (stack.length && temperatures[stack.at(-1)] < temperatures[i]) {\n      const prevDay = stack.pop();\n      result[prevDay] = i - prevDay;  // Days between\n    }\n    \n    stack.push(i);\n  }\n  \n  return result;\n}\n\n// Example: [73, 74, 75, 71, 69, 72, 76, 73]\n// Output: [1, 1, 4, 2, 1, 1, 0, 0]\n// Day 0 (73): Next warmer is day 1 (74), wait = 1 day\n// Day 2 (75): Next warmer is day 6 (76), wait = 4 days",
              "notes": "Store indices to calculate distance (i - prevDay)."
            },
            "python": {
              "code": "def daily_temperatures(temperatures):\n    n = len(temperatures)\n    result = [0] * n\n    stack = []\n    \n    for i, temp in enumerate(temperatures):\n        while stack and temperatures[stack[-1]] < temp:\n            prev_day = stack.pop()\n            result[prev_day] = i - prev_day\n        \n        stack.append(i)\n    \n    return result",
              "notes": "Same pattern - indices give distance calculation."
            }
          },
          {
            "name": "Largest Rectangle in Histogram",
            "description": "Max rectangle area under histogram bars",
            "javascript": {
              "code": "function largestRectangleArea(heights) {\n  const stack = [];  // Indices of bars\n  let maxArea = 0;\n  \n  // Add sentinel 0 at end to flush remaining bars\n  heights.push(0);\n  \n  for (let i = 0; i < heights.length; i++) {\n    // Pop taller bars - they can't extend further right\n    while (stack.length && heights[stack.at(-1)] > heights[i]) {\n      const h = heights[stack.pop()];\n      \n      // Width: from previous bar in stack to current\n      const w = stack.length ? i - stack.at(-1) - 1 : i;\n      \n      maxArea = Math.max(maxArea, h * w);\n    }\n    \n    stack.push(i);\n  }\n  \n  heights.pop();  // Remove sentinel\n  return maxArea;\n}\n\n// Key insight:\n// When a bar is popped, it's the HEIGHT of rectangle\n// Width extends from previous shorter bar to current shorter bar\n// Stack stores indices of bars in increasing height order\n\n// Example: [2, 1, 5, 6, 2, 3]\n// When we reach final 2 (or sentinel 0):\n// Pop 6: width=1, area=6\n// Pop 5: width=2, area=10\n// etc.",
              "notes": "Sentinel 0 at end forces all bars to be processed."
            },
            "python": {
              "code": "def largest_rectangle_area(heights):\n    stack = []\n    max_area = 0\n    \n    heights.append(0)  # Sentinel\n    \n    for i, h in enumerate(heights):\n        while stack and heights[stack[-1]] > h:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        \n        stack.append(i)\n    \n    heights.pop()  # Remove sentinel\n    return max_area\n\n# Alternative: compute left/right boundaries separately\ndef largest_rectangle_area_v2(heights):\n    n = len(heights)\n    left = [0] * n   # First smaller to left\n    right = [n] * n  # First smaller to right\n    \n    stack = []\n    for i in range(n):\n        while stack and heights[stack[-1]] >= heights[i]:\n            stack.pop()\n        left[i] = stack[-1] if stack else -1\n        stack.append(i)\n    \n    stack = []\n    for i in range(n - 1, -1, -1):\n        while stack and heights[stack[-1]] >= heights[i]:\n            stack.pop()\n        right[i] = stack[-1] if stack else n\n        stack.append(i)\n    \n    return max(heights[i] * (right[i] - left[i] - 1) for i in range(n))",
              "notes": "Two-pass version is clearer. One-pass with sentinel is trickier."
            }
          }
        ],
        "visualTrace": {
          "title": "Next Greater Element for [2, 1, 2, 4, 3]",
          "input": {
            "array": "[2, 1, 2, 4, 3]"
          },
          "steps": [
            {
              "i": 0,
              "val": 2,
              "action": "Stack empty, push 0",
              "stack": "[0]",
              "result": "[-1,-1,-1,-1,-1]"
            },
            {
              "i": 1,
              "val": 1,
              "action": "1 < arr[0]=2, push 1",
              "stack": "[0,1]",
              "result": "[-1,-1,-1,-1,-1]"
            },
            {
              "i": 2,
              "val": 2,
              "action": "2 > arr[1]=1, pop 1, result[1]=2, 2=arr[0], push 2",
              "stack": "[0,2]",
              "result": "[-1,2,-1,-1,-1]"
            },
            {
              "i": 3,
              "val": 4,
              "action": "4 > arr[2]=2, pop 2‚Üíresult[2]=4; 4 > arr[0]=2, pop 0‚Üíresult[0]=4; push 3",
              "stack": "[3]",
              "result": "[4,2,4,-1,-1]"
            },
            {
              "i": 4,
              "val": 3,
              "action": "3 < arr[3]=4, push 4",
              "stack": "[3,4]",
              "result": "[4,2,4,-1,-1]"
            }
          ],
          "output": "[4, 2, 4, -1, -1] ‚Äî 4 is next greater for indices 0,2; 2 is next greater for index 1"
        },
        "commonMistakes": [
          {
            "mistake": "Storing values instead of indices",
            "wrong": "stack.push(nums[i])",
            "right": "stack.push(i)",
            "explanation": "Indices let you calculate distances and access result array."
          },
          {
            "mistake": "Wrong comparison direction",
            "wrong": "< for next smaller",
            "right": "> for next smaller, < for next greater",
            "explanation": "Pop when current breaks monotonic property."
          },
          {
            "mistake": "Not handling remaining stack elements",
            "wrong": "Forget elements still in stack at end",
            "right": "They have no next greater/smaller (keep default -1)",
            "explanation": "Use sentinel or post-process remaining stack."
          }
        ],
        "keyTakeaways": [
          "Monotonic stack: maintains sorted order by popping violators",
          "Decreasing stack ‚Üí next greater; Increasing stack ‚Üí next smaller",
          "O(n) total: each element pushed once, popped once",
          "Store INDICES not values (enables distance calculation)",
          "Sentinel values (0 at end) can simplify edge cases",
          "Classic problems: Next Greater, Daily Temperatures, Histogram Rectangle"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "stack",
              "label": "Stack",
              "why": "Monotonic stack is a stack variant"
            },
            {
              "id": "array",
              "label": "Arrays",
              "why": "Operates on array elements"
            }
          ],
          "nextTopics": [
            {
              "id": "monotonic_queue",
              "label": "Monotonic Queue",
              "why": "Similar idea for sliding window"
            },
            {
              "id": "histogram",
              "label": "Histogram Problems",
              "why": "Classic monotonic stack application"
            },
            {
              "id": "stock_problems",
              "label": "Stock Problems",
              "why": "Span and price tracking"
            }
          ]
        },
        "patternChain": {
          "description": "Monotonic stack solves 'next greater/smaller' class of problems",
          "buildsOn": [
            {
              "id": "stack",
              "relationship": "Specialized stack with ordering constraint",
              "whatToKnow": "Stack operations"
            },
            {
              "id": "array",
              "relationship": "Processes arrays sequentially",
              "whatToKnow": "Array traversal"
            }
          ],
          "enables": [
            {
              "id": "daily_temperatures",
              "relationship": "Days until warmer",
              "patternName": "Next Greater",
              "interviewFrequency": "Very High"
            },
            {
              "id": "histogram",
              "relationship": "Left/right boundaries",
              "patternName": "Largest Rectangle",
              "interviewFrequency": "Very High"
            },
            {
              "id": "stock_span",
              "relationship": "Consecutive smaller days",
              "patternName": "Stock Span",
              "interviewFrequency": "High"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    STACK[Stack] --> MS[Monotonic Stack]\n    ARR[Arrays] --> MS\n    MS --> NGE[Next Greater Element]\n    MS --> TEMP[Daily Temperatures]\n    MS --> HIST[Histogram Rectangle]\n    \n    style MS fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "monotonic_queue",
      "label": "Monotonic Queue",
      "type": "algo-pattern",
      "description": "Deque maintaining monotonic order; common in sliding window max/min.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Monotone_priority_queue"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/monotonic-queue/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "content": {
        "definition": {
          "simple": "A deque that maintains elements in sorted order. Useful for sliding window min/max.",
          "technical": "Elements stored in monotonic (increasing or decreasing) order. Pop from back when new element violates order."
        },
        "keyTakeaways": [
          "Maintains min or max efficiently",
          "Amortized O(1) per operation",
          "Used for sliding window max/min",
          "Each element pushed/popped once"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "deque",
              "label": "Deque",
              "why": "Built on deque"
            }
          ],
          "nextTopics": [
            {
              "id": "sliding_window_max",
              "label": "Sliding Window Max",
              "why": "Classic application"
            }
          ]
        }
      }
    },
    {
      "id": "divide_conquer",
      "label": "Divide & Conquer",
      "type": "algo-pattern",
      "description": "Split problem, solve subproblems, combine results.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/divide-and-conquer/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/divide-and-conquer/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "3-4 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon"
      ],
      "interviewFrequency": "medium",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "interviewQuestions": [
        {
          "name": "Merge Sort (conceptual)",
          "leetcode": "https://leetcode.com/problems/sort-an-array/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Microsoft",
            "Google"
          ],
          "frequency": "High",
          "whyAsked": "Classic D&C - divide, sort halves, merge",
          "approach": "Split array in half. Recursively sort each. Merge sorted halves. O(n log n)",
          "followUps": [
            {
              "question": "Count inversions while sorting?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "External merge sort?",
              "answer": "Sort chunks that fit in memory, write to disk. Merge k sorted files using min-heap. Minimize disk I/O."
            }
          ],
          "sources": [
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Merge K Sorted Lists",
          "leetcode": "https://leetcode.com/problems/merge-k-sorted-lists/",
          "difficulty": "Hard",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "D&C approach - pair up and merge, or use heap",
          "approach": "Merge pairs of lists, reducing k by half each round. O(n log k)",
          "followUps": [
            {
              "question": "Heap approach comparison?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Parallelize?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Kth Largest Element",
          "leetcode": "https://leetcode.com/problems/kth-largest-element-in-an-array/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon",
            "Google",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Quickselect - D&C for selection without full sort",
          "approach": "Partition around pivot. Recurse only on side containing kth element. O(n) average",
          "followUps": [
            {
              "question": "Median of medians for O(n) worst case?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Count of Smaller Numbers After Self",
          "leetcode": "https://leetcode.com/problems/count-of-smaller-numbers-after-self/",
          "difficulty": "Hard",
          "companies": [
            "Google",
            "Amazon",
            "Meta"
          ],
          "frequency": "Medium",
          "whyAsked": "Merge sort with inversion counting",
          "approach": "Modified merge sort: count elements from right half placed before left elements",
          "followUps": [
            {
              "question": "Range sum queries?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "BIT/Segment tree approach?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "teamblind"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Blind (Teamblind)",
              "url": "https://www.teamblind.com/",
              "note": "Crowdsourced FAANG interview experiences"
            }
          ]
        },
        {
          "name": "Maximum Subarray",
          "leetcode": "https://leetcode.com/problems/maximum-subarray/",
          "difficulty": "Medium",
          "companies": [
            "Google",
            "Amazon",
            "Microsoft"
          ],
          "frequency": "Very High",
          "whyAsked": "Can solve with D&C (though Kadane's is simpler)",
          "approach": "D&C: max of (left max, right max, crossing max). Crossing = max suffix left + max prefix right",
          "followUps": [
            {
              "question": "Kadane's approach?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Circular array?",
              "answer": "Max of: normal Kadane, or total_sum - min_subarray_sum. Handle all-negative case."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with videos"
        },
        {
          "name": "CP-Algorithms",
          "url": "https://cp-algorithms.com/",
          "note": "Competitive programming reference"
        }
      ],
      "content": {
        "definition": {
          "simple": "Divide problem into subproblems, solve recursively, combine results.",
          "technical": "T(n) = aT(n/b) + f(n). Master theorem gives complexity. Merge sort, quick sort, binary search."
        },
        "keyTakeaways": [
          "Divide ‚Üí Conquer ‚Üí Combine",
          "Master theorem for complexity",
          "Parallelizable",
          "Examples: merge sort, FFT"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "recursion",
              "label": "Recursion",
              "why": "Recursive approach"
            }
          ],
          "nextTopics": [
            {
              "id": "merge_sort",
              "label": "Merge Sort",
              "why": "Classic example"
            }
          ]
        }
      }
    },
    {
      "id": "bitmasking",
      "label": "Bitmasking",
      "type": "concept",
      "description": "Using bits to represent sets/states compactly.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Mask_(computing)"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/bit-manipulation/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/bitmasking-dp-simple-problem/"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2-3 hours",
      "companies": [
        "Google",
        "Meta"
      ],
      "interviewFrequency": "low",
      "category": "Concept",
      "categoryIcon": "üí°",
      "interviewQuestions": [
        {
          "name": "Single Number",
          "leetcode": "https://leetcode.com/problems/single-number/",
          "difficulty": "Easy",
          "companies": [
            "Amazon",
            "Google",
            "Apple"
          ],
          "frequency": "Very High",
          "whyAsked": "XOR property: a^a=0, a^0=a. Find unique element",
          "approach": "XOR all numbers. Pairs cancel out, leaving the single number",
          "followUps": [
            {
              "question": "Two single numbers?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Three times except one?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Number of 1 Bits",
          "leetcode": "https://leetcode.com/problems/number-of-1-bits/",
          "difficulty": "Easy",
          "companies": [
            "Amazon",
            "Microsoft",
            "Apple"
          ],
          "frequency": "High",
          "whyAsked": "Brian Kernighan's algorithm or bit shifting",
          "approach": "n & (n-1) removes rightmost 1 bit. Count iterations until n=0",
          "followUps": [
            {
              "question": "Counting bits for 0 to n?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Hamming distance?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Counting Bits",
          "leetcode": "https://leetcode.com/problems/counting-bits/",
          "difficulty": "Easy",
          "companies": [
            "Google",
            "Amazon"
          ],
          "frequency": "High",
          "whyAsked": "DP with bit manipulation - relation between n and n/2",
          "approach": "dp[i] = dp[i >> 1] + (i & 1). Or dp[i] = dp[i & (i-1)] + 1",
          "followUps": [
            {
              "question": "Prime number of set bits?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Reverse Bits",
          "leetcode": "https://leetcode.com/problems/reverse-bits/",
          "difficulty": "Easy",
          "companies": [
            "Apple",
            "Amazon"
          ],
          "frequency": "Medium",
          "whyAsked": "Bit manipulation fundamentals",
          "approach": "Extract LSB of n, add to result. Shift n right, result left. Repeat 32 times",
          "followUps": [
            {
              "question": "Optimize for multiple calls?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Divide and conquer approach?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Missing Number",
          "leetcode": "https://leetcode.com/problems/missing-number/",
          "difficulty": "Easy",
          "companies": [
            "Amazon",
            "Microsoft",
            "Meta",
            "Flipkart"
          ],
          "frequency": "High",
          "whyAsked": "XOR or math (Gauss sum) approach",
          "approach": "XOR indices [0,n] with array values. Missing number remains. Or sum(0..n) - sum(arr)",
          "followUps": [
            {
              "question": "Two missing numbers?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Duplicates and missing?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Sum of Two Integers",
          "leetcode": "https://leetcode.com/problems/sum-of-two-integers/",
          "difficulty": "Medium",
          "companies": [
            "Meta",
            "Amazon"
          ],
          "frequency": "Medium",
          "whyAsked": "Add without + operator - bit manipulation",
          "approach": "XOR gives sum without carry. AND + left shift gives carry. Repeat until no carry",
          "followUps": [
            {
              "question": "Subtract?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Multiply?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with videos"
        },
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based categorization"
        }
      ],
      "content": {
        "definition": {
          "simple": "Using bits to represent sets. Each bit = element present (1) or absent (0).",
          "technical": "Set operations via bit ops: union (|), intersection (&), diff (^), membership (& mask)."
        },
        "keyTakeaways": [
          "Set as integer",
          "Union = |, Intersection = &",
          "Iterate subsets efficiently",
          "Used in DP, combinatorics"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bits",
              "label": "Bit Manipulation",
              "why": "Bit operations"
            }
          ],
          "nextTopics": [
            {
              "id": "bitmask_dp",
              "label": "Bitmask DP",
              "why": "Application"
            }
          ]
        }
      }
    },
    {
      "id": "bitmask_dp",
      "label": "Bitmask DP",
      "type": "algo-pattern",
      "description": "DP over subsets/states encoded as bitmasks.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Dynamic_programming"
          }
        ],
        "community": [
          {
            "title": "Codeforces Blog",
            "url": "https://codeforces.com/blog/entry/18051"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/bitmasking-and-dynamic-programming-set-1-count-ways-to-assign-unique-cap-to-every-person/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-6 hours",
      "companies": [
        "Google"
      ],
      "interviewFrequency": "low",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "content": {
        "definition": {
          "simple": "DP where state includes a bitmask representing subset of elements visited/used.",
          "technical": "dp[mask] or dp[mask][i]. Transition: add bit, remove bit. O(2^n √ó n) typical."
        },
        "keyTakeaways": [
          "State = subset as bitmask",
          "O(2^n √ó n) typical",
          "TSP, assignment problems",
          "n usually ‚â§ 20"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bits",
              "label": "Bit Manipulation",
              "why": "Bitmask operations"
            },
            {
              "id": "dp",
              "label": "DP",
              "why": "Core technique"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "fenwick",
      "label": "Fenwick Tree (BIT)",
      "type": "ds-specialized",
      "description": "Supports prefix/range sums with logarithmic updates.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Fenwick_tree"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/fenwicktree"
          },
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/data_structures/fenwick.html"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/binary-indexed-tree/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "4-5 hours",
      "companies": [
        "Google"
      ],
      "interviewFrequency": "low",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "interviewQuestions": [
        {
          "name": "Range Sum Query - Mutable",
          "leetcode": "https://leetcode.com/problems/range-sum-query-mutable/",
          "difficulty": "Medium",
          "companies": [
            "Google",
            "Amazon"
          ],
          "frequency": "Medium",
          "whyAsked": "BIT (Fenwick Tree) - simpler than segment tree for prefix sums",
          "approach": "BIT with update and prefix query. Range = prefix(r) - prefix(l-1)",
          "followUps": [
            {
              "question": "2D BIT?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Range update + point query?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "cpalgorithms"
          ],
          "sourceDetails": [
            {
              "name": "CP-Algorithms",
              "url": "https://cp-algorithms.com/",
              "note": "Competitive programming reference"
            }
          ]
        },
        {
          "name": "Count of Smaller Numbers After Self",
          "leetcode": "https://leetcode.com/problems/count-of-smaller-numbers-after-self/",
          "difficulty": "Hard",
          "companies": [
            "Google",
            "Amazon"
          ],
          "frequency": "Medium",
          "whyAsked": "BIT to count elements in range while processing",
          "approach": "Coordinate compress values. Process right to left, BIT query for smaller count",
          "followUps": [
            {
              "question": "Merge sort approach?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "cpalgorithms"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "CP-Algorithms",
              "url": "https://cp-algorithms.com/",
              "note": "Competitive programming reference"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "CP-Algorithms",
          "url": "https://cp-algorithms.com/",
          "note": "Competitive programming reference"
        }
      ],
      "content": {
        "definition": {
          "simple": "Efficient structure for prefix sums and point updates. Also called Binary Indexed Tree (BIT).",
          "technical": "Tree stored in array. Uses binary representation of indices. O(log n) update and prefix query."
        },
        "keyTakeaways": [
          "O(log n) point update",
          "O(log n) prefix sum query",
          "Less memory than segment tree",
          "Index math uses lowest set bit"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "prefix_sum",
              "label": "Prefix Sum",
              "why": "Solves same problem dynamically"
            }
          ],
          "nextTopics": [
            {
              "id": "segment_tree",
              "label": "Segment Tree",
              "why": "More flexible"
            }
          ]
        }
      }
    },
    {
      "id": "segment_tree",
      "label": "Segment Tree",
      "type": "ds-specialized",
      "description": "Range queries/updates with logarithmic complexity.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Segment_tree"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/segmenttree"
          },
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/data_structures/segment_tree.html"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/segment-tree/"
          },
          {
            "title": "Codeforces Blog",
            "url": "https://codeforces.com/blog/entry/18051"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-7 hours",
      "companies": [
        "Google"
      ],
      "interviewFrequency": "low",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "interviewQuestions": [
        {
          "name": "Range Sum Query - Mutable",
          "leetcode": "https://leetcode.com/problems/range-sum-query-mutable/",
          "difficulty": "Medium",
          "companies": [
            "Google",
            "Amazon"
          ],
          "frequency": "Medium",
          "whyAsked": "Basic segment tree for range sum with updates",
          "approach": "Build tree with sum at each node. Update: O(log n). Query: O(log n)",
          "followUps": [
            {
              "question": "Lazy propagation?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "2D segment tree?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150",
            "cpalgorithms"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "CP-Algorithms",
              "url": "https://cp-algorithms.com/",
              "note": "Competitive programming reference"
            }
          ]
        },
        {
          "name": "Count of Range Sum",
          "leetcode": "https://leetcode.com/problems/count-of-range-sum/",
          "difficulty": "Hard",
          "companies": [
            "Google"
          ],
          "frequency": "Low",
          "whyAsked": "Segment tree or merge sort for counting ranges",
          "approach": "Prefix sums + segment tree/merge sort to count valid (lower, upper) ranges",
          "followUps": [
            {
              "question": "BIT approach?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "cpalgorithms"
          ],
          "sourceDetails": [
            {
              "name": "CP-Algorithms",
              "url": "https://cp-algorithms.com/",
              "note": "Competitive programming reference"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "CP-Algorithms",
          "url": "https://cp-algorithms.com/",
          "note": "Competitive programming reference"
        }
      ],
      "content": {
        "definition": {
          "simple": "Tree that stores aggregate info (sum, min, max) for array segments. O(log n) range queries and updates.",
          "technical": "Complete binary tree. Leaves = array elements. Internal nodes = aggregate of children. 2n-1 nodes total."
        },
        "keyTakeaways": [
          "O(log n) range query",
          "O(log n) point update",
          "Supports sum, min, max, GCD, etc.",
          "Array representation: left=2i, right=2i+1"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "tree",
              "label": "Trees",
              "why": "It's a tree structure"
            }
          ],
          "nextTopics": [
            {
              "id": "segment_tree_lazy",
              "label": "Lazy Propagation",
              "why": "Range updates"
            }
          ]
        }
      }
    },
    {
      "id": "skip_list",
      "label": "Skip List",
      "type": "ds-specialized",
      "description": "Probabilistic layered linked list for O(log n) search/insert.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Skip_list"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/skip-list/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "4-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Layered linked list with express lanes. Probabilistically balanced for O(log n) operations.",
          "technical": "Multiple levels of linked lists. Each level skips ~half the nodes. Expected O(log n) search/insert/delete."
        },
        "keyTakeaways": [
          "Probabilistic balancing",
          "O(log n) expected operations",
          "Simpler than balanced trees",
          "Used in Redis, LevelDB"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "linked_list",
              "label": "Linked List",
              "why": "Built on linked lists"
            }
          ],
          "nextTopics": [
            {
              "id": "lsm_tree",
              "label": "LSM Tree",
              "why": "Uses skip lists"
            }
          ]
        }
      }
    },
    {
      "id": "btree",
      "label": "B-Tree / B+Tree",
      "type": "ds-specialized",
      "description": "Multiway balanced tree used in databases/filesystems.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/B-tree"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/bst"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/introduction-of-b-tree-2/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Self-balancing tree optimized for disk. Each node has many keys. Used in databases and filesystems.",
          "technical": "Each node has m/2 to m children. All leaves at same depth. Minimizes disk I/O by keeping tree shallow."
        },
        "keyTakeaways": [
          "Optimized for disk access",
          "Many keys per node",
          "All leaves same depth",
          "Used in databases, filesystems"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bst",
              "label": "BST",
              "why": "B-tree generalizes BST"
            }
          ],
          "nextTopics": [
            {
              "id": "lsm_tree",
              "label": "LSM Tree",
              "why": "Alternative for writes"
            }
          ]
        }
      }
    },
    {
      "id": "lru_cache",
      "label": "LRU Cache",
      "type": "ds-hybrid",
      "description": "Cache eviction policy: least recently used (HashMap + DLL).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/design/"
          },
          {
            "title": "LeetCode #146",
            "url": "https://leetcode.com/problems/lru-cache/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "2-3 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft",
        "LinkedIn"
      ],
      "interviewFrequency": "high",
      "category": "Hybrid DS",
      "categoryIcon": "üîÄ",
      "content": {
        "definition": {
          "simple": "Cache that evicts least recently used items when full. O(1) get and put.",
          "technical": "Hash map for O(1) lookup + doubly linked list for O(1) move-to-front and eviction."
        },
        "keyTakeaways": [
          "O(1) get and put",
          "HashMap + Doubly Linked List",
          "Move to front on access",
          "Evict from tail when full"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "hash_map",
              "label": "Hash Map",
              "why": "For O(1) lookup"
            },
            {
              "id": "dll",
              "label": "Doubly Linked List",
              "why": "For O(1) reordering"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "mst",
      "label": "Minimum Spanning Tree (MST)",
      "type": "algo-graph",
      "description": "Connect all vertices with minimum total edge weight.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Minimum_spanning_tree"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/mst"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/minimum-spanning-tree/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "4-5 hours",
      "companies": [
        "Google",
        "Amazon"
      ],
      "interviewFrequency": "low",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Subset of edges connecting all vertices with minimum total weight. No cycles.",
          "technical": "Spanning tree with minimum sum of edge weights. Unique if all weights distinct."
        },
        "keyTakeaways": [
          "Connects all vertices",
          "Minimum total edge weight",
          "N-1 edges for N vertices",
          "Kruskal's or Prim's algorithm"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "graph",
              "label": "Graphs",
              "why": "MST is graph algorithm"
            }
          ],
          "nextTopics": [
            {
              "id": "kruskal",
              "label": "Kruskal's",
              "why": "MST algorithm"
            }
          ]
        }
      }
    },
    {
      "id": "kruskal",
      "label": "Kruskal's Algorithm",
      "type": "algo-graph",
      "description": "MST via sorting edges + Union-Find.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Kruskal%27s_algorithm"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/mst"
          },
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/mst_kruskal.html"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "4-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Build MST by adding cheapest edges that don't create cycles. Uses Union-Find.",
          "technical": "Sort edges by weight. For each edge, if endpoints in different components, add edge and union. O(E log E)."
        },
        "keyTakeaways": [
          "Sort edges by weight",
          "Union-Find for cycle detection",
          "O(E log E) time",
          "Good for sparse graphs"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "union_find",
              "label": "Union-Find",
              "why": "Core data structure"
            }
          ],
          "nextTopics": [
            {
              "id": "prim",
              "label": "Prim's",
              "why": "Alternative MST"
            }
          ]
        }
      }
    },
    {
      "id": "prim",
      "label": "Prim's Algorithm",
      "type": "algo-graph",
      "description": "MST via growing frontier using a priority queue.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Prim%27s_algorithm"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/mst"
          },
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/mst_prim.html"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "4-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Build MST by growing from a vertex, always adding cheapest edge to unvisited vertex.",
          "technical": "Start from any vertex. Use min-heap to track cheapest edges to frontier. O(E log V) with heap."
        },
        "keyTakeaways": [
          "Grow tree from starting vertex",
          "Min-heap for cheapest edge",
          "O(E log V) with heap",
          "Good for dense graphs"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "heap",
              "label": "Heaps",
              "why": "Uses priority queue"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "scc",
      "label": "Strongly Connected Components (SCC)",
      "type": "algo-graph",
      "description": "Decompose directed graph into SCCs.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Strongly_connected_component"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/dfsbfs"
          },
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/strongly-connected-components.html"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "5-6 hours",
      "companies": [
        "Google"
      ],
      "interviewFrequency": "low",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Maximal set of vertices where every vertex is reachable from every other vertex.",
          "technical": "Partition of directed graph into strongly connected components. Forms a DAG when contracted."
        },
        "keyTakeaways": [
          "Every vertex reachable from every other",
          "Directed graphs only",
          "SCC graph is a DAG",
          "Kosaraju's or Tarjan's"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dfs",
              "label": "DFS",
              "why": "Both algorithms use DFS"
            }
          ],
          "nextTopics": [
            {
              "id": "kosaraju",
              "label": "Kosaraju's",
              "why": "SCC algorithm"
            }
          ]
        }
      }
    },
    {
      "id": "kosaraju",
      "label": "Kosaraju's Algorithm",
      "type": "algo-graph",
      "description": "SCC via two DFS passes and reversed graph.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/strongly-connected-components.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/strongly-connected-components/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "5-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Find SCCs using two DFS passes: one on original, one on reversed graph.",
          "technical": "DFS to get finish times. Reverse graph. DFS in decreasing finish time order. Each DFS tree is an SCC."
        },
        "keyTakeaways": [
          "Two DFS passes",
          "First pass: finish times",
          "Second pass: reversed graph",
          "O(V + E) time"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dfs",
              "label": "DFS",
              "why": "Core algorithm"
            }
          ],
          "nextTopics": [
            {
              "id": "tarjan",
              "label": "Tarjan's",
              "why": "Single-pass alternative"
            }
          ]
        }
      }
    },
    {
      "id": "tarjan",
      "label": "Tarjan's Algorithm",
      "type": "algo-graph",
      "description": "SCC via single DFS with low-link values.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/strongly-connected-components.html"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Find SCCs in single DFS pass using discovery times and low-link values.",
          "technical": "Track discovery time and lowest reachable time. Root of SCC when low[v] = disc[v]. Uses stack."
        },
        "keyTakeaways": [
          "Single DFS pass",
          "Low-link values",
          "Root when low == discovery",
          "O(V + E) time"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dfs",
              "label": "DFS",
              "why": "Extended DFS"
            }
          ],
          "nextTopics": [
            {
              "id": "articulation_points",
              "label": "Articulation Points",
              "why": "Similar technique"
            }
          ]
        }
      }
    },
    {
      "id": "bellman_ford",
      "label": "Bellman-Ford",
      "type": "algo-graph",
      "description": "Shortest paths with negative edges; detects negative cycles.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Bellman‚ÄìFord_algorithm"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/sssp"
          },
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/bellman_ford.html"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "4-5 hours",
      "companies": [
        "Google"
      ],
      "interviewFrequency": "low",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Single-source shortest paths that handles negative edges. Detects negative cycles.",
          "technical": "Relax all edges V-1 times. If any edge can still be relaxed, negative cycle exists. O(VE)."
        },
        "keyTakeaways": [
          "Handles negative weights",
          "Detects negative cycles",
          "O(VE) time",
          "Slower than Dijkstra but more general"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "graph",
              "label": "Graphs",
              "why": "Graph algorithm"
            }
          ],
          "nextTopics": [
            {
              "id": "floyd_warshall",
              "label": "Floyd-Warshall",
              "why": "All-pairs shortest"
            }
          ]
        }
      }
    },
    {
      "id": "floyd_warshall",
      "label": "Floyd-Warshall",
      "type": "algo-graph",
      "description": "All-pairs shortest paths (dynamic programming).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Floyd‚ÄìWarshall_algorithm"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/sssp"
          },
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/all-pair-shortest-path-floyd-warshall.html"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "4-5 hours",
      "companies": [
        "Google"
      ],
      "interviewFrequency": "low",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Find shortest paths between ALL pairs of vertices. Simple DP approach.",
          "technical": "dp[i][j][k] = shortest i‚Üíj using vertices 1..k. Recurrence: min(dp[i][j][k-1], dp[i][k] + dp[k][j]). O(V¬≥)."
        },
        "keyTakeaways": [
          "All-pairs shortest paths",
          "O(V¬≥) time and O(V¬≤) space",
          "Simple triple nested loop",
          "Handles negative edges (no neg cycles)"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp",
              "label": "DP",
              "why": "Uses dynamic programming"
            }
          ],
          "nextTopics": [
            {
              "id": "johnson",
              "label": "Johnson's",
              "why": "Faster for sparse graphs"
            }
          ]
        }
      }
    },
    {
      "id": "max_flow",
      "label": "Max Flow / Min Cut",
      "type": "algo-graph",
      "description": "Flow networks: maximize flow under capacities.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Maximum_flow_problem"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/edmonds_karp.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/max-flow-problem-introduction/"
          }
        ]
      },
      "difficulty": 8,
      "timeEstimate": "6-8 hours",
      "companies": [
        "Google"
      ],
      "interviewFrequency": "low",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Maximum amount of flow from source to sink in a network with edge capacities.",
          "technical": "Ford-Fulkerson method: find augmenting paths until none exist. Max-flow = min-cut (duality)."
        },
        "keyTakeaways": [
          "Source to sink with capacities",
          "Max-flow = min-cut",
          "Ford-Fulkerson framework",
          "Applications: bipartite matching, scheduling"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "graph",
              "label": "Graphs",
              "why": "Network flow on graphs"
            }
          ],
          "nextTopics": [
            {
              "id": "edmonds_karp",
              "label": "Edmonds-Karp",
              "why": "BFS implementation"
            }
          ]
        }
      }
    },
    {
      "id": "edmonds_karp",
      "label": "Edmonds-Karp",
      "type": "algo-graph",
      "description": "Max flow using BFS augmenting paths.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Edmonds‚ÄìKarp_algorithm"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/edmonds_karp.html"
          }
        ]
      },
      "difficulty": 8,
      "timeEstimate": "6-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Max flow using BFS to find shortest augmenting paths.",
          "technical": "Ford-Fulkerson with BFS. O(VE¬≤) time. Each BFS finds shortest augmenting path in residual graph."
        },
        "keyTakeaways": [
          "BFS for augmenting paths",
          "O(VE¬≤) time",
          "Shortest path = fewest edges",
          "Polynomial time guarantee"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bfs",
              "label": "BFS",
              "why": "Core algorithm"
            },
            {
              "id": "max_flow",
              "label": "Max Flow",
              "why": "Solves max flow"
            }
          ],
          "nextTopics": [
            {
              "id": "dinic",
              "label": "Dinic's",
              "why": "Faster algorithm"
            }
          ]
        }
      }
    },
    {
      "id": "dinic",
      "label": "Dinic's Algorithm",
      "type": "algo-graph",
      "description": "Max flow using level graph (BFS) + blocking flow (DFS).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Dinic%27s_algorithm"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/dinic.html"
          }
        ]
      },
      "difficulty": 8,
      "timeEstimate": "6-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Faster max flow using blocking flows in layered graph.",
          "technical": "Build level graph with BFS. Find blocking flow with DFS. Repeat. O(V¬≤E), O(E‚àöV) for unit capacity."
        },
        "keyTakeaways": [
          "Level graph + blocking flow",
          "O(V¬≤E) general, O(E‚àöV) unit",
          "Faster than Edmonds-Karp",
          "Used for bipartite matching"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "edmonds_karp",
              "label": "Edmonds-Karp",
              "why": "Simpler max flow"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "bipartite_matching",
      "label": "Bipartite Matching",
      "type": "algo-graph",
      "description": "Match nodes across two partitions without conflicts.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Matching_(graph_theory)"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/kuhn_maximum_bipartite_matching.html"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "4-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Maximum number of pairs from two disjoint sets where each item matched at most once.",
          "technical": "Model as max flow: source‚Üíleft, left‚Üíright (capacity 1), right‚Üísink. Or use Hungarian/Hopcroft-Karp."
        },
        "keyTakeaways": [
          "Two disjoint sets",
          "Each vertex matched once",
          "Reduce to max flow",
          "Applications: job assignment"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "max_flow",
              "label": "Max Flow",
              "why": "Can reduce to flow"
            }
          ],
          "nextTopics": [
            {
              "id": "hopcroft_karp",
              "label": "Hopcroft-Karp",
              "why": "Specialized algorithm"
            }
          ]
        }
      }
    },
    {
      "id": "hopcroft_karp",
      "label": "Hopcroft-Karp",
      "type": "algo-graph",
      "description": "Maximum bipartite matching using BFS layers + DFS augmentations.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Hopcroft‚ÄìKarp_algorithm"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/kuhn_maximum_bipartite_matching.html"
          }
        ]
      },
      "difficulty": 8,
      "timeEstimate": "6-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Fast bipartite matching using BFS layers and DFS augmentation.",
          "technical": "Build layers with BFS from unmatched vertices. Augment with DFS. O(E‚àöV) time."
        },
        "keyTakeaways": [
          "O(E‚àöV) time",
          "BFS for layers, DFS for augment",
          "Faster than naive approach",
          "Multiple augmenting paths per phase"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bipartite_matching",
              "label": "Bipartite Matching",
              "why": "Solves this problem"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "kmp",
      "label": "KMP String Search",
      "type": "algo",
      "description": "Pattern matching using prefix function (LPS).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Knuth‚ÄìMorris‚ÄìPratt_algorithm"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/suffixarray"
          },
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/string/prefix-function.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "5-6 hours",
      "companies": [
        "Google"
      ],
      "interviewFrequency": "low",
      "category": "Algorithm",
      "categoryIcon": "‚ö°",
      "content": {
        "definition": {
          "simple": "Find pattern in text without backtracking. Precompute failure function.",
          "technical": "Build prefix table (failure function) in O(m). Search in O(n). Total O(n+m)."
        },
        "keyTakeaways": [
          "O(n+m) pattern matching",
          "No backtracking in text",
          "Prefix/failure table",
          "Handles all overlapping matches"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "string",
              "label": "Strings",
              "why": "String algorithm"
            }
          ],
          "nextTopics": [
            {
              "id": "z_algorithm",
              "label": "Z-Algorithm",
              "why": "Alternative O(n+m)"
            }
          ]
        }
      }
    },
    {
      "id": "rabin_karp",
      "label": "Rabin-Karp",
      "type": "algo",
      "description": "String search using rolling hash.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Rabin‚ÄìKarp_algorithm"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/string/rabin-karp.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "4-5 hours",
      "companies": [
        "Google",
        "Meta"
      ],
      "interviewFrequency": "low",
      "category": "Algorithm",
      "categoryIcon": "‚ö°",
      "content": {
        "definition": {
          "simple": "Rolling hash for pattern matching. Hash each window, compare only on hash match.",
          "technical": "Polynomial rolling hash. O(n+m) average, O(nm) worst (many hash collisions). Good for multiple patterns."
        },
        "keyTakeaways": [
          "Rolling hash technique",
          "O(n+m) average",
          "Good for multiple patterns",
          "Hash collisions cause false positives"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "hashing",
              "label": "Hashing",
              "why": "Uses hash functions"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "z_algorithm",
      "label": "Z-Algorithm",
      "type": "algo",
      "description": "String matching using Z-values (prefix matches).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Z_algorithm"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/string/z-function.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "5-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Algorithm",
      "categoryIcon": "‚ö°",
      "content": {
        "definition": {
          "simple": "Compute Z-array where Z[i] = length of longest prefix starting at i that matches prefix.",
          "technical": "O(n) using Z-box technique. Pattern matching: search in P$T, find Z[i] = len(P)."
        },
        "keyTakeaways": [
          "Z[i] = longest match with prefix",
          "O(n) time",
          "Pattern matching via concatenation",
          "Alternative to KMP"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "string",
              "label": "Strings",
              "why": "String algorithm"
            }
          ],
          "nextTopics": [
            {
              "id": "suffix_array",
              "label": "Suffix Array",
              "why": "More advanced"
            }
          ]
        }
      }
    },
    {
      "id": "suffix_array",
      "label": "Suffix Array",
      "type": "ds-specialized",
      "description": "Sorted suffixes for fast substring queries.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Suffix_array"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/suffixarray"
          },
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/string/suffix-array.html"
          }
        ]
      },
      "difficulty": 8,
      "timeEstimate": "6-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Sorted array of all suffixes of a string. Enables fast substring queries.",
          "technical": "Array of starting indices of sorted suffixes. Build in O(n log n) or O(n). LCP array enhances queries."
        },
        "keyTakeaways": [
          "Sorted suffix indices",
          "O(n log n) or O(n) build",
          "LCP array for faster queries",
          "Alternative to suffix tree"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "sorting",
              "label": "Sorting",
              "why": "Sorting suffixes"
            }
          ],
          "nextTopics": [
            {
              "id": "suffix_tree",
              "label": "Suffix Tree",
              "why": "More powerful"
            }
          ]
        }
      }
    },
    {
      "id": "suffix_tree",
      "label": "Suffix Tree",
      "type": "ds-specialized",
      "description": "Compressed trie of all suffixes for substring queries.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Suffix_tree"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/suffixarray"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/"
          }
        ]
      },
      "difficulty": 9,
      "timeEstimate": "8-10 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Compressed trie of all suffixes. O(n) space and build time. Very powerful for string queries.",
          "technical": "Ukkonen's algorithm builds in O(n). Supports pattern matching, LCS, LRS in O(m) or O(1)."
        },
        "keyTakeaways": [
          "O(n) build with Ukkonen's",
          "O(m) pattern matching",
          "Very powerful but complex",
          "Suffix array often preferred"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "trie",
              "label": "Trie",
              "why": "Suffix tree is a trie"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "suffix_automaton",
      "label": "Suffix Automaton",
      "type": "ds-specialized",
      "description": "Automaton representing all substrings; fast queries.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Suffix_automaton"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/string/suffix-automaton.html"
          }
        ]
      },
      "difficulty": 9,
      "timeEstimate": "8-10 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Minimal DFA accepting all suffixes. O(n) size and build. Counts distinct substrings.",
          "technical": "DAG with suffix links. Each path = unique substring. Count distinct substrings in O(n)."
        },
        "keyTakeaways": [
          "Minimal DFA for suffixes",
          "O(n) construction",
          "Count distinct substrings",
          "More compact than suffix tree"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "suffix_tree",
              "label": "Suffix Tree",
              "why": "Related structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "count_min_sketch",
      "label": "Count-Min Sketch",
      "type": "ds-probabilistic",
      "description": "Probabilistic frequency table for streaming counts.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Count‚Äìmin_sketch"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/count-min-sketch-in-java-with-examples/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "4-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Probabilistic DS",
      "categoryIcon": "üé≤",
      "content": {
        "definition": {
          "simple": "Estimate frequency of items in stream. May overcount, never undercount.",
          "technical": "d hash functions, w counters each. Insert: increment all d counters. Query: min of d counters."
        },
        "keyTakeaways": [
          "Frequency estimation",
          "May overcount",
          "Uses multiple hash functions",
          "Sublinear space"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "hashing",
              "label": "Hashing",
              "why": "Multiple hash functions"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "hyperloglog",
      "label": "HyperLogLog",
      "type": "ds-probabilistic",
      "description": "Probabilistic cardinality estimation.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/HyperLogLog"
          }
        ],
        "community": [
          {
            "title": "Redis: HyperLogLog",
            "url": "https://redis.io/docs/data-types/hyperloglogs/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Probabilistic DS",
      "categoryIcon": "üé≤",
      "content": {
        "definition": {
          "simple": "Estimate count of distinct elements using very little space.",
          "technical": "Count leading zeros in hashes. Harmonic mean of estimates. ~2% error with 12KB."
        },
        "keyTakeaways": [
          "Cardinality estimation",
          "O(log log n) space",
          "~2% error typical",
          "Used in Redis, databases"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "hashing",
              "label": "Hashing",
              "why": "Hash-based"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "ann",
      "label": "Approximate Nearest Neighbor (ANN)",
      "type": "algo",
      "description": "Fast similarity search in high-dimensional spaces.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Nearest_neighbor_search#Approximate_nearest_neighbor"
          }
        ],
        "community": [
          {
            "title": "Pinecone: ANN Guide",
            "url": "https://www.pinecone.io/learn/what-is-similarity-search/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "4-5 hours",
      "companies": [
        "OpenAI",
        "Google",
        "Meta",
        "TikTok"
      ],
      "interviewFrequency": "medium",
      "category": "Algorithm",
      "categoryIcon": "‚ö°",
      "content": {
        "definition": {
          "simple": "Approximate Nearest Neighbor: find similar vectors quickly, may miss exact best.",
          "technical": "Trade accuracy for speed. HNSW, IVF, LSH methods. Used in vector databases."
        },
        "keyTakeaways": [
          "Approximate, not exact",
          "Much faster than exact",
          "HNSW, IVF, LSH methods",
          "Powers similarity search"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "vector_db",
              "label": "Vector DB",
              "why": "Use case"
            }
          ],
          "nextTopics": [
            {
              "id": "hnsw",
              "label": "HNSW",
              "why": "Popular method"
            }
          ]
        }
      }
    },
    {
      "id": "hnsw",
      "label": "HNSW",
      "type": "ds-modern",
      "description": "Graph-based ANN index (Hierarchical Navigable Small World).",
      "references": {
        "official": [
          {
            "title": "HNSW Paper",
            "url": "https://arxiv.org/abs/1603.09320"
          }
        ],
        "community": [
          {
            "title": "Pinecone: HNSW",
            "url": "https://www.pinecone.io/learn/series/faiss/hnsw/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-6 hours",
      "companies": [
        "OpenAI",
        "Google"
      ],
      "interviewFrequency": "low",
      "category": "Modern DS",
      "categoryIcon": "üöÄ",
      "content": {
        "definition": {
          "simple": "Hierarchical Navigable Small World: graph-based ANN with multiple layers.",
          "technical": "Skip list-like layers of proximity graph. O(log n) search. Best recall/speed trade-off."
        },
        "keyTakeaways": [
          "Hierarchical graph",
          "O(log n) search",
          "Best accuracy/speed",
          "Used in Faiss, Pinecone"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "ann",
              "label": "ANN",
              "why": "ANN method"
            },
            {
              "id": "skip_list",
              "label": "Skip List",
              "why": "Similar hierarchy"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "ivf",
      "label": "IVF Index",
      "type": "ds-modern",
      "description": "Inverted file index for ANN via clustering/partitions.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Inverted_index"
          }
        ],
        "community": [
          {
            "title": "Faiss Wiki: IVF",
            "url": "https://github.com/facebookresearch/faiss/wiki/Faiss-indexes"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "4-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Modern DS",
      "categoryIcon": "üöÄ",
      "content": {
        "definition": {
          "simple": "Inverted File Index for vectors: cluster vectors, search relevant clusters only.",
          "technical": "K-means clustering. Search nprobe nearest clusters. Trade-off: fewer clusters = faster, less accurate."
        },
        "keyTakeaways": [
          "Cluster-based search",
          "Only search nearby clusters",
          "nprobe parameter",
          "Combine with PQ"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "ann",
              "label": "ANN",
              "why": "ANN method"
            }
          ],
          "nextTopics": [
            {
              "id": "pq",
              "label": "Product Quantization",
              "why": "Compression"
            }
          ]
        }
      }
    },
    {
      "id": "pq",
      "label": "Product Quantization (PQ)",
      "type": "ds-modern",
      "description": "Compression technique for vectors to speed ANN search.",
      "references": {
        "official": [
          {
            "title": "Product Quantization Paper",
            "url": "https://inria.hal.science/inria-00514462"
          }
        ],
        "community": [
          {
            "title": "Pinecone: PQ",
            "url": "https://www.pinecone.io/learn/series/faiss/product-quantization/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "4-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Modern DS",
      "categoryIcon": "üöÄ",
      "content": {
        "definition": {
          "simple": "Product Quantization: compress vectors by splitting into subvectors, quantizing each.",
          "technical": "Split vector into m subvectors. Quantize each to k centroids. 32x+ compression with ~5% recall loss."
        },
        "keyTakeaways": [
          "Vector compression",
          "Split and quantize",
          "32x+ compression",
          "Combine with IVF"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "ivf",
              "label": "IVF",
              "why": "Often combined"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "merge_sort",
      "label": "Merge Sort",
      "type": "algo-sorting",
      "description": "Divide-and-conquer O(n log n) stable sort.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Merge_sort"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/sorting"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/merge-sort/"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2-3 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft"
      ],
      "interviewFrequency": "medium",
      "category": "Sorting",
      "categoryIcon": "üî¢",
      "content": {
        "definition": {
          "simple": "Divide array in half, sort each half, merge sorted halves. Guaranteed O(n log n).",
          "technical": "Stable, divide-and-conquer. T(n) = 2T(n/2) + O(n). O(n) extra space for merging."
        },
        "keyTakeaways": [
          "O(n log n) always",
          "Stable sort",
          "O(n) extra space",
          "Great for linked lists, external sort"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "recursion",
              "label": "Recursion",
              "why": "Divide and conquer"
            }
          ],
          "nextTopics": [
            {
              "id": "quick_sort",
              "label": "Quick Sort",
              "why": "Alternative O(n log n)"
            }
          ]
        }
      }
    },
    {
      "id": "quick_sort",
      "label": "Quick Sort",
      "type": "algo-sorting",
      "description": "In-place O(n log n) average; pivot-based partitioning.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Quicksort"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/sorting"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/quick-sort/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "3-4 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon"
      ],
      "interviewFrequency": "medium",
      "category": "Sorting",
      "categoryIcon": "üî¢",
      "content": {
        "definition": {
          "simple": "Pick pivot, partition around it, recursively sort partitions. Fast in practice.",
          "technical": "Unstable. O(n log n) average, O(n¬≤) worst. In-place with O(log n) stack. Pivot selection matters."
        },
        "keyTakeaways": [
          "O(n log n) average",
          "O(n¬≤) worst (bad pivot)",
          "In-place, cache-friendly",
          "Randomize pivot to avoid worst case"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "recursion",
              "label": "Recursion",
              "why": "Recursive algorithm"
            }
          ],
          "nextTopics": [
            {
              "id": "heap_sort",
              "label": "Heap Sort",
              "why": "O(n log n) guaranteed"
            }
          ]
        }
      }
    },
    {
      "id": "heap_sort",
      "label": "Heap Sort",
      "type": "algo-sorting",
      "description": "O(n log n) in-place sort using heap property.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Heapsort"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/sorting"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/heap-sort/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "3-4 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Sorting",
      "categoryIcon": "üî¢",
      "content": {
        "definition": {
          "simple": "Build max-heap, repeatedly extract max. O(n log n) guaranteed, in-place.",
          "technical": "Heapify in O(n). Extract max n times, each O(log n). Unstable. Not cache-friendly (random access)."
        },
        "keyTakeaways": [
          "O(n log n) guaranteed",
          "In-place (O(1) extra)",
          "Unstable",
          "Slower in practice than quicksort"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "heap",
              "label": "Heaps",
              "why": "Uses heap data structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "insertion_sort",
      "label": "Insertion Sort",
      "type": "algo-sorting",
      "description": "O(n^2) simple sort; efficient for small/nearly-sorted data.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Insertion_sort"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/sorting"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/insertion-sort/"
          }
        ]
      },
      "difficulty": 2,
      "timeEstimate": "1-2 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Sorting",
      "categoryIcon": "üî¢",
      "content": {
        "definition": {
          "simple": "Build sorted array one element at a time. Insert each element in correct position.",
          "technical": "O(n¬≤) average/worst, O(n) best (already sorted). Stable, in-place. Good for small/nearly-sorted arrays."
        },
        "keyTakeaways": [
          "O(n¬≤) but O(n) for nearly sorted",
          "Stable, in-place",
          "Good for small arrays",
          "Used as base case in hybrid sorts"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Arrays",
              "why": "Sorts arrays"
            }
          ],
          "nextTopics": [
            {
              "id": "tim_sort",
              "label": "Tim Sort",
              "why": "Uses insertion sort"
            }
          ]
        }
      }
    },
    {
      "id": "selection_sort",
      "label": "Selection Sort",
      "type": "algo-sorting",
      "description": "O(n^2) simple sort; selects min each pass.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Selection_sort"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/sorting"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/selection-sort/"
          }
        ]
      },
      "difficulty": 2,
      "timeEstimate": "1-2 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Sorting",
      "categoryIcon": "üî¢",
      "content": {
        "definition": {
          "simple": "Find minimum, put at front. Repeat for remaining array.",
          "technical": "O(n¬≤) always. Unstable, in-place. Minimal swaps (O(n)). Never use in practice."
        },
        "keyTakeaways": [
          "O(n¬≤) always",
          "Minimal swaps",
          "Unstable",
          "Educational only"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Arrays",
              "why": "Basic sorting"
            }
          ],
          "nextTopics": [
            {
              "id": "insertion_sort",
              "label": "Insertion Sort",
              "why": "Better O(n¬≤) sort"
            }
          ]
        }
      }
    },
    {
      "id": "bubble_sort",
      "label": "Bubble Sort",
      "type": "algo-sorting",
      "description": "O(n^2) simple sort; swaps adjacent elements.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Bubble_sort"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/sorting"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/bubble-sort/"
          }
        ]
      },
      "difficulty": 1,
      "timeEstimate": "1 hour",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Sorting",
      "categoryIcon": "üî¢",
      "content": {
        "definition": {
          "simple": "Repeatedly swap adjacent elements if out of order. Largest bubbles to end.",
          "technical": "O(n¬≤) average/worst, O(n) best with early termination. Stable, in-place. Very slow."
        },
        "keyTakeaways": [
          "O(n¬≤)",
          "Stable, in-place",
          "Only educational value",
          "Early termination if no swaps"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Arrays",
              "why": "Basic sorting"
            }
          ],
          "nextTopics": [
            {
              "id": "insertion_sort",
              "label": "Insertion Sort",
              "why": "Better alternative"
            }
          ]
        }
      }
    },
    {
      "id": "counting_sort",
      "label": "Counting Sort",
      "type": "algo-sorting",
      "description": "O(n+k) non-comparison sort for integers.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Counting_sort"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/sorting"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/counting-sort/"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2-3 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Sorting",
      "categoryIcon": "üî¢",
      "content": {
        "definition": {
          "simple": "Count occurrences of each value, reconstruct sorted array. O(n+k) for range k.",
          "technical": "Not comparison-based. Works for integers in range [0, k). O(n+k) time and space. Stable."
        },
        "keyTakeaways": [
          "O(n+k) time",
          "Not comparison-based",
          "Only for bounded integers",
          "Stable"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Arrays",
              "why": "Uses counting array"
            }
          ],
          "nextTopics": [
            {
              "id": "radix_sort",
              "label": "Radix Sort",
              "why": "Uses counting sort"
            }
          ]
        }
      }
    },
    {
      "id": "radix_sort",
      "label": "Radix Sort",
      "type": "algo-sorting",
      "description": "O(nk) sort by digit/character position.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Radix_sort"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/sorting"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/radix-sort/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "3-4 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Sorting",
      "categoryIcon": "üî¢",
      "content": {
        "definition": {
          "simple": "Sort digit by digit from least to most significant. Uses stable sort (counting) per digit.",
          "technical": "O(d(n+k)) where d=digits, k=base. Not comparison-based. Works for integers or fixed-length strings."
        },
        "keyTakeaways": [
          "O(d(n+k)) time",
          "Process digit by digit",
          "Uses stable sort per digit",
          "Good for fixed-length keys"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "counting_sort",
              "label": "Counting Sort",
              "why": "Used per digit"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "bucket_sort",
      "label": "Bucket Sort",
      "type": "algo-sorting",
      "description": "O(n+k) distributes elements into buckets.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Bucket_sort"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/bucket-sort-2/"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2-3 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Sorting",
      "categoryIcon": "üî¢",
      "content": {
        "definition": {
          "simple": "Distribute elements into buckets, sort each bucket, concatenate.",
          "technical": "O(n+k) average for uniform distribution. O(n¬≤) worst. Good for floating point in [0,1)."
        },
        "keyTakeaways": [
          "O(n) average for uniform data",
          "Divide into buckets",
          "Sort buckets individually",
          "Good for uniform distribution"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "sorting",
              "label": "Sorting",
              "why": "Distribution-based sort"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "tim_sort",
      "label": "Tim Sort",
      "type": "algo-sorting",
      "description": "Hybrid merge+insertion sort; Python/Java default.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Timsort"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/timsort/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "4-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Sorting",
      "categoryIcon": "üî¢",
      "content": {
        "definition": {
          "simple": "Hybrid of merge sort and insertion sort. Exploits existing runs. Used by Python/Java.",
          "technical": "Find natural runs, extend with insertion sort, merge with galloping. O(n log n) worst, O(n) for sorted."
        },
        "keyTakeaways": [
          "Python/Java default sort",
          "Exploits existing order",
          "O(n) for nearly sorted",
          "Hybrid merge + insertion"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "merge_sort",
              "label": "Merge Sort",
              "why": "Based on merge"
            },
            {
              "id": "insertion_sort",
              "label": "Insertion Sort",
              "why": "Used for small runs"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "linear_search",
      "label": "Linear Search",
      "type": "algo",
      "description": "O(n) sequential search.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Linear_search"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/linear-search/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "2-4 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Algorithm",
      "categoryIcon": "‚ö°",
      "content": {
        "definition": {
          "simple": "Check each element one by one until found. O(n) time.",
          "technical": "Sequential scan. Works on unsorted data. O(n) average and worst. O(1) best."
        },
        "keyTakeaways": [
          "O(n) time",
          "Works on unsorted data",
          "Simple but slow",
          "Use when data is small or unsorted"
        ],
        "learningPath": {
          "prerequisites": [],
          "nextTopics": [
            {
              "id": "binary_search",
              "label": "Binary Search",
              "why": "O(log n) for sorted"
            }
          ]
        }
      }
    },
    {
      "id": "ternary_search",
      "label": "Ternary Search",
      "type": "algo",
      "description": "O(log n) search on unimodal functions.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Ternary_search"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/num_methods/ternary_search.html"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "2-4 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Algorithm",
      "categoryIcon": "‚ö°",
      "content": {
        "definition": {
          "simple": "Find maximum/minimum of unimodal function by dividing into thirds.",
          "technical": "Divide range into thirds, eliminate one third based on function values. O(log n) iterations."
        },
        "keyTakeaways": [
          "For unimodal functions",
          "Find peak or valley",
          "O(log n) iterations",
          "Alternative: binary search on derivative"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "binary_search",
              "label": "Binary Search",
              "why": "Similar technique"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "interpolation_search",
      "label": "Interpolation Search",
      "type": "algo",
      "description": "O(log log n) average for uniformly distributed data.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Interpolation_search"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/interpolation-search/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "2-4 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Algorithm",
      "categoryIcon": "‚ö°",
      "content": {
        "definition": {
          "simple": "Binary search that guesses position based on value distribution. O(log log n) for uniform data.",
          "technical": "Probe position: lo + (x-arr[lo])*(hi-lo)/(arr[hi]-arr[lo]). O(n) worst for non-uniform."
        },
        "keyTakeaways": [
          "O(log log n) for uniform",
          "O(n) worst case",
          "Estimates position from value",
          "Good for uniformly distributed data"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "binary_search",
              "label": "Binary Search",
              "why": "Improved binary search"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "exponential_search",
      "label": "Exponential Search",
      "type": "algo",
      "description": "O(log n) for unbounded/infinite arrays.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Exponential_search"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/exponential-search/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "2-4 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Algorithm",
      "categoryIcon": "‚ö°",
      "content": {
        "definition": {
          "simple": "Find range where element exists by doubling, then binary search in that range.",
          "technical": "Find i where arr[i] > x (doubling i). Binary search in [i/2, i]. O(log n). Good for unbounded arrays."
        },
        "keyTakeaways": [
          "For unbounded/infinite arrays",
          "Find range by doubling",
          "O(log n) time",
          "Good when element is near start"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "binary_search",
              "label": "Binary Search",
              "why": "Used after range found"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "nary_tree",
      "label": "N-ary Tree",
      "type": "ds-hierarchical",
      "description": "Tree where each node can have N children.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/M-ary_tree"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/tree/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "3-4 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Tree DS",
      "categoryIcon": "üå≥",
      "content": {
        "definition": {
          "simple": "Tree where each node can have any number of children.",
          "technical": "Store children as array/list. Level order uses queue. Many trees generalize binary tree concepts."
        },
        "keyTakeaways": [
          "Nodes have 0+ children",
          "Store children as list",
          "Generalized tree traversals",
          "Used in file systems, DOM"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "tree",
              "label": "Trees",
              "why": "Tree basics"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "red_black_tree",
      "label": "Red-Black Tree",
      "type": "ds-hierarchical",
      "description": "Self-balancing BST with color properties.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Red‚Äìblack_tree"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Tree DS",
      "categoryIcon": "üå≥",
      "content": {
        "definition": {
          "simple": "Self-balancing BST using node colors to maintain balance. Less strict than AVL.",
          "technical": "Each node red or black. Root black. Red nodes have black children. Equal black-height on all paths."
        },
        "keyTakeaways": [
          "Looser balance than AVL",
          "Fewer rotations on insert/delete",
          "O(log n) operations",
          "Used in std::map, TreeMap"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "avl",
              "label": "AVL Tree",
              "why": "Simpler balancing"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "splay_tree",
      "label": "Splay Tree",
      "type": "ds-hierarchical",
      "description": "Self-adjusting BST; recently accessed nodes move to root.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Splay_tree"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/splay-tree-set-1-insert/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "3-4 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Tree DS",
      "categoryIcon": "üå≥",
      "content": {
        "definition": {
          "simple": "Self-adjusting BST that moves accessed nodes to root via splaying.",
          "technical": "Splay operation rotates accessed node to root. Amortized O(log n). Good for locality."
        },
        "keyTakeaways": [
          "Move accessed to root",
          "Amortized O(log n)",
          "Good for repeated access",
          "No explicit balance tracking"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bst",
              "label": "BST",
              "why": "Tree operations"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "treap",
      "label": "Treap",
      "type": "ds-hierarchical",
      "description": "Randomized BST combining tree + heap properties.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Treap"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/data_structures/treap.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/treap-a-randomized-binary-search-tree/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "3-4 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Tree DS",
      "categoryIcon": "üå≥",
      "content": {
        "definition": {
          "simple": "BST + heap: BST by key, heap by random priority. Expected O(log n).",
          "technical": "Random priorities ensure expected balance. Rotations maintain heap property. Split/merge operations."
        },
        "keyTakeaways": [
          "BST keys + heap priorities",
          "Random priorities for balance",
          "Expected O(log n)",
          "Supports split/merge"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bst",
              "label": "BST",
              "why": "Tree structure"
            },
            {
              "id": "heap",
              "label": "Heap",
              "why": "Heap property"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "interval_tree",
      "label": "Interval Tree",
      "type": "ds-specialized",
      "description": "Tree for storing intervals; fast overlap queries.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Interval_tree"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/interval-tree/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "4-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Interval problems involve ranges like [start, end]. The key insight: sorting by start time lets you process intervals sequentially and detect overlaps by comparing current start with previous end.",
          "technical": "Interval manipulation involves operations on ranges [start, end]. Most problems reduce to sorting intervals (typically by start) and making a single pass with O(n log n) complexity. Core operations include merge, intersection, insert, and gap detection."
        },
        "howItWorks": {
          "explanation": "Think of calendar events. To find conflicts (overlaps), sort by start time. If next meeting starts before current one ends, they overlap! To merge, extend the current meeting's end time. To insert a new meeting, find where it fits and handle overlaps on both sides.",
          "steps": [
            {
              "step": 1,
              "title": "Sort by Start",
              "description": "Sort intervals by start time (usually ascending)",
              "why": "Enables sequential processing - earlier starts come first."
            },
            {
              "step": 2,
              "title": "Track Current Interval",
              "description": "Keep track of the 'active' or 'merged' interval",
              "why": "Compare next interval against this."
            },
            {
              "step": 3,
              "title": "Detect Overlap",
              "description": "If next.start <= current.end, they overlap",
              "why": "Overlap condition is key to all interval problems."
            },
            {
              "step": 4,
              "title": "Apply Operation",
              "description": "Merge: extend end. Intersection: shrink range. Insert: split and combine.",
              "why": "Different problems require different overlap handling."
            },
            {
              "step": 5,
              "title": "Advance or Add",
              "description": "Either extend current interval or start a new one",
              "why": "Build result incrementally."
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph TD\n    subgraph \"Overlap Detection\"\n        A[\"Interval A: [1,5]\"]\n        B[\"Interval B: [3,7]\"]\n        C[\"Overlap: B.start(3) <= A.end(5)\"]\n        D[\"Merged: [1, max(5,7)] = [1,7]\"]\n    end\n    \n    A --> C\n    B --> C\n    C --> D\n    \n    style C fill:#ee6c4d\n    style D fill:#98c1d9",
            "caption": "Two intervals overlap if next.start <= prev.end (after sorting by start)"
          }
        },
        "whenToUse": {
          "summary": "Use interval techniques when dealing with ranges, schedules, or segments that may overlap.",
          "patterns": [
            {
              "pattern": "Merge Overlapping Intervals",
              "signal": "Combine overlapping ranges into minimal set",
              "example": "Merge calendar events, IP range consolidation",
              "withoutIt": "O(n¬≤) pairwise comparison",
              "withIt": "O(n log n) sort + O(n) merge"
            },
            {
              "pattern": "Insert Interval",
              "signal": "Add new range to sorted non-overlapping set",
              "example": "Add meeting to schedule",
              "withoutIt": "Remerge everything O(n¬≤)",
              "withIt": "O(n) single pass with merge"
            },
            {
              "pattern": "Meeting Rooms",
              "signal": "Count overlaps / check if possible",
              "example": "Can person attend all meetings?",
              "withoutIt": "Check all pairs O(n¬≤)",
              "withIt": "Sort and scan O(n log n)"
            },
            {
              "pattern": "Minimum Rooms Needed",
              "signal": "Max concurrent overlaps",
              "example": "Minimum meeting rooms required",
              "withoutIt": "Simulate timeline O(n¬≤)",
              "withIt": "Event sweep or heap O(n log n)"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "When ranges aren't naturally comparable or when order doesn't help.",
          "antiPatterns": [
            {
              "situation": "Non-Comparable Ranges",
              "why": "Intervals need sortable start/end",
              "useInstead": "Different data structure",
              "example": "Multi-dimensional ranges (use R-tree)"
            },
            {
              "situation": "Frequent Updates",
              "why": "Re-sorting is expensive",
              "useInstead": "Interval Tree or Segment Tree",
              "example": "Dynamic interval insertion/deletion with queries"
            },
            {
              "situation": "Point Queries Only",
              "why": "Overkill for simple membership",
              "useInstead": "Hash set or sorted array + binary search",
              "example": "Check if point is in any range"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The Meeting Room Scheduler",
            "story": "You're a receptionist with a list of meeting requests. To know how many rooms you need, sort by start time. Every time a meeting starts, you need a room. Every time one ends, you free a room. The maximum 'active' meetings at any point = rooms needed.",
            "connection": "Interval problems are about tracking 'active' ranges. Sorting lets you process events in order."
          },
          "keyInsight": "After sorting by start: overlap happens when current.start <= prev.end. This simple condition is the core of almost all interval problems.",
          "commonConfusion": [
            {
              "confusion": "Sort by start or end?",
              "clarification": "Usually by start. Sort by end for activity selection (greedy). Some problems need both (meeting rooms uses separate sorted arrays)."
            },
            {
              "confusion": "< vs <= for overlap?",
              "clarification": "[1,2] and [2,3] - do they overlap? Depends on problem! Meeting [1,2) and [2,3) don't overlap. Closed intervals [1,2] and [2,3] touch at 2."
            },
            {
              "confusion": "Merge vs count overlaps?",
              "clarification": "Merge: combine into fewer intervals. Count: track max concurrent (use min-heap or two-pointer on sorted starts/ends)."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Merge Intervals",
                "average": "O(n log n)",
                "worst": "O(n log n)",
                "note": "Dominated by sorting"
              },
              {
                "operation": "Insert Interval",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "Already sorted, single pass"
              },
              {
                "operation": "Meeting Rooms I",
                "average": "O(n log n)",
                "worst": "O(n log n)",
                "note": "Sort + single scan"
              },
              {
                "operation": "Meeting Rooms II",
                "average": "O(n log n)",
                "worst": "O(n log n)",
                "note": "Sort + heap operations"
              }
            ],
            "explanation": "Sorting is usually the bottleneck. Post-sort operations are O(n)."
          },
          "space": {
            "complexity": "O(n) or O(1)",
            "explanation": "O(n) for result/heap. Some can be done in-place O(1)."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Intervals often stored as [start, end] pairs or objects with .start, .end properties.",
            "keyPoints": [
              "Sort in-place when possible to save space",
              "Result array grows as we process",
              "Min-heap for tracking 'earliest ending' active interval",
              "Two separate sorted arrays (starts, ends) for sweep line"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Sort with custom comparator. Arrays for intervals.",
              "gotchas": [
                "sort() needs numeric comparator: (a, b) => a[0] - b[0]",
                "Default sort is lexicographic (wrong for numbers!)",
                "Use array destructuring: const [start, end] = interval"
              ]
            },
            "python": {
              "implementation": "Sort with key=lambda x: x[0]. Tuples or lists.",
              "gotchas": [
                "Tuples compare lexicographically (first by [0], then [1])",
                "heapq is min-heap - perfect for tracking earliest end",
                "Use intervals.sort(key=lambda x: x[0]) for start sort"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Merge intervals in O(n log n)",
            "proof": {
              "step1": {
                "action": "Sort intervals by start",
                "cost": "O(n log n)"
              },
              "step2": {
                "action": "Iterate through sorted intervals once",
                "cost": "O(n)"
              },
              "step3": {
                "action": "Each interval either extends result or adds new",
                "cost": "O(1) per interval"
              },
              "step4": {
                "action": "Total",
                "cost": "O(n log n) + O(n) = O(n log n)"
              }
            },
            "totalCost": "Sorting dominates: O(n log n)"
          }
        },
        "codeTemplates": [
          {
            "name": "Merge Intervals",
            "description": "Combine overlapping intervals",
            "javascript": {
              "code": "function merge(intervals) {\n  if (intervals.length <= 1) return intervals;\n  \n  // Sort by start time\n  intervals.sort((a, b) => a[0] - b[0]);\n  \n  const result = [intervals[0]];\n  \n  for (let i = 1; i < intervals.length; i++) {\n    const prev = result[result.length - 1];\n    const curr = intervals[i];\n    \n    if (curr[0] <= prev[1]) {\n      // Overlapping - extend previous end\n      prev[1] = Math.max(prev[1], curr[1]);\n    } else {\n      // No overlap - add new interval\n      result.push(curr);\n    }\n  }\n  \n  return result;\n}\n\n// Example:\n// [[1,3], [2,6], [8,10], [15,18]]\n// After sort: [[1,3], [2,6], [8,10], [15,18]]\n// [1,3] + [2,6]: 2 <= 3, merge to [1,6]\n// [1,6] + [8,10]: 8 > 6, add [8,10]\n// [8,10] + [15,18]: 15 > 10, add [15,18]\n// Result: [[1,6], [8,10], [15,18]]",
              "notes": "Key: curr[0] <= prev[1] means overlap. Extend with max(ends)."
            },
            "python": {
              "code": "def merge(intervals):\n    if len(intervals) <= 1:\n        return intervals\n    \n    intervals.sort(key=lambda x: x[0])\n    \n    result = [intervals[0]]\n    \n    for start, end in intervals[1:]:\n        prev = result[-1]\n        \n        if start <= prev[1]:\n            prev[1] = max(prev[1], end)\n        else:\n            result.append([start, end])\n    \n    return result\n\n# Alternative using reduce\nfrom functools import reduce\n\ndef merge_v2(intervals):\n    def merge_pair(merged, interval):\n        if merged and interval[0] <= merged[-1][1]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n        return merged\n    \n    return reduce(merge_pair, sorted(intervals), [])",
              "notes": "Pythonic: unpack with 'for start, end'. Modify result[-1] in place."
            }
          },
          {
            "name": "Insert Interval",
            "description": "Insert new interval into sorted non-overlapping intervals",
            "javascript": {
              "code": "function insert(intervals, newInterval) {\n  const result = [];\n  let i = 0;\n  const n = intervals.length;\n  \n  // 1. Add all intervals that end before newInterval starts\n  while (i < n && intervals[i][1] < newInterval[0]) {\n    result.push(intervals[i]);\n    i++;\n  }\n  \n  // 2. Merge overlapping intervals\n  while (i < n && intervals[i][0] <= newInterval[1]) {\n    newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n    newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n    i++;\n  }\n  result.push(newInterval);\n  \n  // 3. Add remaining intervals\n  while (i < n) {\n    result.push(intervals[i]);\n    i++;\n  }\n  \n  return result;\n}\n\n// Example: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], new = [4,8]\n// Step 1: Add [1,2] (ends before 4)\n// Step 2: Merge [3,5],[6,7],[8,10] with [4,8] ‚Üí [3,10]\n// Step 3: Add [12,16]\n// Result: [[1,2],[3,10],[12,16]]",
              "notes": "Three phases: before, overlap, after. Clean separation."
            },
            "python": {
              "code": "def insert(intervals, new_interval):\n    result = []\n    i, n = 0, len(intervals)\n    \n    # Add intervals ending before new starts\n    while i < n and intervals[i][1] < new_interval[0]:\n        result.append(intervals[i])\n        i += 1\n    \n    # Merge overlapping intervals\n    while i < n and intervals[i][0] <= new_interval[1]:\n        new_interval = [\n            min(new_interval[0], intervals[i][0]),\n            max(new_interval[1], intervals[i][1])\n        ]\n        i += 1\n    result.append(new_interval)\n    \n    # Add remaining\n    result.extend(intervals[i:])\n    \n    return result",
              "notes": "new_interval gets updated during merge phase. extend() for remainder."
            }
          },
          {
            "name": "Meeting Rooms II (Min Rooms Needed)",
            "description": "Find minimum meeting rooms required",
            "javascript": {
              "code": "function minMeetingRooms(intervals) {\n  if (intervals.length === 0) return 0;\n  \n  // Extract and sort start times and end times separately\n  const starts = intervals.map(i => i[0]).sort((a, b) => a - b);\n  const ends = intervals.map(i => i[1]).sort((a, b) => a - b);\n  \n  let rooms = 0;\n  let endPtr = 0;\n  \n  for (let start of starts) {\n    if (start < ends[endPtr]) {\n      // New meeting starts before earliest one ends\n      rooms++;\n    } else {\n      // A room freed up\n      endPtr++;\n    }\n  }\n  \n  return rooms;\n}\n\n// Alternative: Min-Heap approach\nclass MinHeap {\n  constructor() { this.heap = []; }\n  \n  push(val) {\n    this.heap.push(val);\n    this._bubbleUp();\n  }\n  \n  pop() {\n    const min = this.heap[0];\n    const last = this.heap.pop();\n    if (this.heap.length) {\n      this.heap[0] = last;\n      this._sinkDown();\n    }\n    return min;\n  }\n  \n  peek() { return this.heap[0]; }\n  get size() { return this.heap.length; }\n  \n  _bubbleUp() { /* standard heap bubble up */ }\n  _sinkDown() { /* standard heap sink down */ }\n}\n\nfunction minMeetingRoomsHeap(intervals) {\n  if (!intervals.length) return 0;\n  \n  intervals.sort((a, b) => a[0] - b[0]);\n  const heap = new MinHeap();\n  heap.push(intervals[0][1]);  // End time of first meeting\n  \n  for (let i = 1; i < intervals.length; i++) {\n    if (intervals[i][0] >= heap.peek()) {\n      heap.pop();  // Reuse room\n    }\n    heap.push(intervals[i][1]);\n  }\n  \n  return heap.size;\n}",
              "notes": "Two approaches: two-pointer on sorted arrays, or min-heap of end times."
            },
            "python": {
              "code": "import heapq\n\ndef min_meeting_rooms(intervals):\n    if not intervals:\n        return 0\n    \n    # Sort by start time\n    intervals.sort(key=lambda x: x[0])\n    \n    # Min-heap of end times (rooms in use)\n    heap = []\n    \n    for start, end in intervals:\n        # If earliest ending meeting ends before this starts, reuse room\n        if heap and heap[0] <= start:\n            heapq.heappop(heap)\n        \n        heapq.heappush(heap, end)\n    \n    return len(heap)\n\n# Two-pointer approach (no heap needed)\ndef min_meeting_rooms_v2(intervals):\n    if not intervals:\n        return 0\n    \n    starts = sorted(i[0] for i in intervals)\n    ends = sorted(i[1] for i in intervals)\n    \n    rooms = 0\n    end_ptr = 0\n    \n    for start in starts:\n        if start < ends[end_ptr]:\n            rooms += 1\n        else:\n            end_ptr += 1\n    \n    return rooms\n\n# Example: [[0,30],[5,10],[15,20]]\n# starts = [0, 5, 15], ends = [10, 20, 30]\n# start=0: 0 < 10, rooms=1\n# start=5: 5 < 10, rooms=2\n# start=15: 15 >= 10, end_ptr=1\n# Result: 2 rooms",
              "notes": "Heap tracks active rooms. Two-pointer is more elegant and same O(n log n)."
            }
          }
        ],
        "visualTrace": {
          "title": "Merge Intervals [[1,3],[2,6],[8,10],[15,18]]",
          "input": {
            "intervals": "[[1,3],[2,6],[8,10],[15,18]]"
          },
          "steps": [
            {
              "step": 1,
              "action": "Sort by start",
              "result": "[[1,3],[2,6],[8,10],[15,18]] (already sorted)"
            },
            {
              "step": 2,
              "action": "Start with [1,3]",
              "result": "result = [[1,3]]"
            },
            {
              "step": 3,
              "action": "Check [2,6]: 2 <= 3?",
              "result": "YES, overlap! Merge to [1, max(3,6)] = [1,6]"
            },
            {
              "step": 4,
              "action": "Check [8,10]: 8 <= 6?",
              "result": "NO, no overlap. Add [8,10]"
            },
            {
              "step": 5,
              "action": "Check [15,18]: 15 <= 10?",
              "result": "NO, no overlap. Add [15,18]"
            },
            {
              "step": 6,
              "action": "Final result",
              "result": "[[1,6],[8,10],[15,18]]"
            }
          ],
          "output": "[[1,6],[8,10],[15,18]] ‚Äî 4 intervals merged to 3"
        },
        "commonMistakes": [
          {
            "mistake": "Forgetting to sort",
            "wrong": "Process intervals as given",
            "right": "Always sort by start (or end) first",
            "explanation": "Overlap detection requires ordered processing."
          },
          {
            "mistake": "Wrong overlap condition",
            "wrong": "curr.start < prev.end",
            "right": "curr.start <= prev.end",
            "explanation": "[1,3] and [3,5] touch at 3 - usually considered overlapping."
          },
          {
            "mistake": "Not updating merged interval correctly",
            "wrong": "prev.end = curr.end",
            "right": "prev.end = max(prev.end, curr.end)",
            "explanation": "New interval might end before current one! [1,10] merged with [2,5] is still [1,10]."
          }
        ],
        "keyTakeaways": [
          "Sort by start time is usually the first step",
          "Overlap condition: next.start <= prev.end",
          "Merge: extend end with max(prev.end, curr.end)",
          "Insert: three phases (before, overlap, after)",
          "Meeting Rooms II: min-heap of end times or two-pointer on sorted starts/ends",
          "Most interval problems are O(n log n) dominated by sorting"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "sorting",
              "label": "Sorting",
              "why": "Intervals must be sorted before processing"
            },
            {
              "id": "array",
              "label": "Arrays",
              "why": "Interval manipulation uses arrays"
            }
          ],
          "nextTopics": [
            {
              "id": "heap",
              "label": "Heaps",
              "why": "Meeting Rooms II uses min-heap"
            },
            {
              "id": "sweep_line",
              "label": "Sweep Line",
              "why": "Advanced interval technique"
            },
            {
              "id": "interval_tree",
              "label": "Interval Tree",
              "why": "Dynamic interval queries"
            }
          ]
        },
        "patternChain": {
          "description": "Intervals are a fundamental pattern for range-based problems",
          "buildsOn": [
            {
              "id": "sorting",
              "relationship": "Sort intervals before processing",
              "whatToKnow": "Custom comparators"
            },
            {
              "id": "array",
              "relationship": "Array manipulation for intervals",
              "whatToKnow": "Array operations"
            }
          ],
          "enables": [
            {
              "id": "merge_intervals",
              "relationship": "Combine overlapping ranges",
              "patternName": "Merge",
              "interviewFrequency": "Very High"
            },
            {
              "id": "meeting_rooms",
              "relationship": "Detect/count overlaps",
              "patternName": "Overlap Detection",
              "interviewFrequency": "Very High"
            },
            {
              "id": "sweep_line",
              "relationship": "Process events in order",
              "patternName": "Event Sweep",
              "interviewFrequency": "High"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    SORT[Sorting] --> INT[Intervals]\n    ARR[Arrays] --> INT\n    HEAP[Heaps] --> INT\n    INT --> MERGE[Merge Intervals]\n    INT --> INSERT[Insert Interval]\n    INT --> ROOM[Meeting Rooms]\n    INT --> SWEEP[Sweep Line]\n    \n    style INT fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "fenwick_2d",
      "label": "2D Fenwick Tree",
      "type": "ds-specialized",
      "description": "BIT extended to 2D for matrix prefix sums.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Fenwick_tree"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/data_structures/fenwick.html"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "4-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "2D Fenwick tree for rectangle sum queries and point updates.",
          "technical": "Nested 1D Fenwick trees. O(log n √ó log m) update and query. O(nm) space."
        },
        "keyTakeaways": [
          "Rectangle sum queries",
          "O(log n √ó log m) operations",
          "Nested 1D Fenwick trees",
          "Point updates only"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "fenwick",
              "label": "Fenwick Tree",
              "why": "1D version"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "segment_tree_lazy",
      "label": "Segment Tree (Lazy Propagation)",
      "type": "ds-specialized",
      "description": "Segment tree with deferred updates for range modifications.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Segment_tree"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/data_structures/segment_tree.html"
          },
          {
            "title": "Codeforces Blog",
            "url": "https://codeforces.com/blog/entry/18051"
          }
        ]
      },
      "difficulty": 8,
      "timeEstimate": "6-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Segment tree with lazy propagation for efficient range updates.",
          "technical": "Store pending updates in lazy array. Push down on access. O(log n) range update and query."
        },
        "keyTakeaways": [
          "O(log n) range updates",
          "Lazy array stores pending ops",
          "Push down before access",
          "Supports range add/set"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "segment_tree",
              "label": "Segment Tree",
              "why": "Basic version"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "persistent_ds",
      "label": "Persistent Data Structure",
      "type": "ds-specialized",
      "description": "Preserves previous versions after modifications.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Persistent_data_structure"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/data_structures/segment_tree.html#toc-tgt-13"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/persistent-data-structures/"
          }
        ]
      },
      "difficulty": 8,
      "timeEstimate": "6-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Data structure that preserves all previous versions after modification.",
          "technical": "Path copying for trees: copy modified path, share unchanged. O(log n) per version, O(n log n) total."
        },
        "keyTakeaways": [
          "All versions preserved",
          "Path copying technique",
          "O(log n) extra per update",
          "Version tree for undo/redo"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "tree",
              "label": "Trees",
              "why": "Tree structures"
            }
          ],
          "nextTopics": [
            {
              "id": "immutable_ds",
              "label": "Immutable DS",
              "why": "Related concept"
            }
          ]
        }
      }
    },
    {
      "id": "immutable_ds",
      "label": "Immutable Data Structure",
      "type": "ds-specialized",
      "description": "Data structure that cannot be modified after creation.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Immutable_object"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/difference-between-mutable-and-immutable/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "4-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Data structures that cannot be modified after creation. Updates create new versions.",
          "technical": "Structural sharing minimizes copying. O(log n) operations maintain immutability. Used in functional programming."
        },
        "keyTakeaways": [
          "Never mutated, only copied",
          "Structural sharing",
          "Thread-safe by design",
          "Functional programming staple"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "persistent_ds",
              "label": "Persistent DS",
              "why": "Similar concept"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "rope",
      "label": "Rope",
      "type": "ds-specialized",
      "description": "Binary tree for efficient string concatenation/splitting.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Rope_(data_structure)"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/ropes-data-structure-fast-string-concatenation/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "4-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Tree of strings for efficient text editing. Insert/delete in O(log n).",
          "technical": "Binary tree with strings at leaves. Rebalance on edit. Used in text editors."
        },
        "keyTakeaways": [
          "O(log n) insert/delete",
          "Tree of string chunks",
          "Used in editors (Xi, VSCode)",
          "Better than array for edits"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "tree",
              "label": "Trees",
              "why": "Tree structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "circular_buffer",
      "label": "Circular Buffer",
      "type": "ds-linear",
      "description": "Fixed-size buffer that wraps around; used in streaming.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Circular_buffer"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/circular-queue-set-1-introduction-array-implementation/"
          }
        ]
      },
      "difficulty": 2,
      "timeEstimate": "1-2 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Linear DS",
      "categoryIcon": "üìä",
      "content": {
        "definition": {
          "simple": "Fixed-size buffer that wraps around. FIFO with bounded memory.",
          "technical": "Head and tail pointers wrap at end. O(1) enqueue/dequeue. Overwrite old on full."
        },
        "keyTakeaways": [
          "Fixed size, wraps around",
          "O(1) operations",
          "FIFO behavior",
          "Used in streaming, logging"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "queue",
              "label": "Queue",
              "why": "Queue variant"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "articulation_points",
      "label": "Articulation Points",
      "type": "algo-graph",
      "description": "Vertices whose removal disconnects the graph.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Biconnected_component"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/cutpoints.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "5-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Vertices whose removal disconnects the graph. Critical nodes.",
          "technical": "DFS with discovery/low times. If low[child] >= disc[v], v is articulation point. Root if 2+ children."
        },
        "keyTakeaways": [
          "Removal disconnects graph",
          "DFS with low-link values",
          "Root: 2+ DFS children",
          "O(V+E) algorithm"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dfs",
              "label": "DFS",
              "why": "Core algorithm"
            }
          ],
          "nextTopics": [
            {
              "id": "bridges",
              "label": "Bridges",
              "why": "Similar concept"
            }
          ]
        }
      }
    },
    {
      "id": "bridges",
      "label": "Bridges",
      "type": "algo-graph",
      "description": "Edges whose removal disconnects the graph.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Bridge_(graph_theory)"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/bridge-searching.html"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "5-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Edges whose removal disconnects the graph. Critical connections.",
          "technical": "DFS with low-link. Edge (u,v) is bridge if low[v] > disc[u]. O(V+E)."
        },
        "keyTakeaways": [
          "Removal disconnects graph",
          "Similar to articulation points",
          "low[v] > disc[u]",
          "O(V+E) algorithm"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "articulation_points",
              "label": "Articulation Points",
              "why": "Related concept"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "euler_path",
      "label": "Euler Path/Circuit",
      "type": "algo-graph",
      "description": "Path/circuit visiting every edge exactly once.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Eulerian_path"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/euler_path.html"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/eulerian-circuit/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "4-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Path visiting every edge exactly once. Exists if 0 or 2 odd-degree vertices.",
          "technical": "Euler circuit: all vertices even degree. Euler path: exactly 2 odd. Hierholzer's algorithm O(E)."
        },
        "keyTakeaways": [
          "Visit every edge once",
          "Circuit: all even degree",
          "Path: exactly 2 odd degree",
          "Hierholzer's O(E)"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "graph",
              "label": "Graphs",
              "why": "Graph property"
            }
          ],
          "nextTopics": [
            {
              "id": "hamiltonian_path",
              "label": "Hamiltonian",
              "why": "Visit every vertex"
            }
          ]
        }
      }
    },
    {
      "id": "hamiltonian_path",
      "label": "Hamiltonian Path",
      "type": "algo-graph",
      "description": "Path visiting every vertex exactly once (NP-complete).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Hamiltonian_path"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/hamiltonian-cycle-backtracking-6/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "6-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Path visiting every vertex exactly once. NP-complete to decide.",
          "technical": "No polynomial algorithm known. Backtracking O(n!). DP with bitmask O(n¬≤ √ó 2^n)."
        },
        "keyTakeaways": [
          "Visit every vertex once",
          "NP-complete",
          "Backtracking or bitmask DP",
          "TSP is related"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "graph",
              "label": "Graphs",
              "why": "Graph problem"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "cycle_detection",
      "label": "Cycle Detection",
      "type": "algo-graph",
      "description": "Detecting cycles in directed/undirected graphs.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Cycle_detection"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/graph/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/detect-cycle-in-a-graph/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "4-6 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon"
      ],
      "interviewFrequency": "medium",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Find if graph contains a cycle. Different methods for directed/undirected.",
          "technical": "Undirected: DFS with parent tracking. Directed: color-based DFS (white/gray/black)."
        },
        "keyTakeaways": [
          "DFS-based detection",
          "Undirected: parent tracking",
          "Directed: three colors",
          "O(V+E)"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dfs",
              "label": "DFS",
              "why": "Core technique"
            }
          ],
          "nextTopics": [
            {
              "id": "topological_sort",
              "label": "Topo Sort",
              "why": "Requires no cycles"
            }
          ]
        }
      }
    },
    {
      "id": "bipartite_check",
      "label": "Bipartite Check",
      "type": "algo-graph",
      "description": "Determine if graph can be 2-colored.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Bipartite_graph"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/graph/"
          },
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/bipartite-check.html"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "4-6 hours",
      "companies": [
        "Google",
        "Meta"
      ],
      "interviewFrequency": "low",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Can vertices be colored with 2 colors so no edge connects same colors?",
          "technical": "BFS/DFS alternating colors. Bipartite iff no odd-length cycle. O(V+E)."
        },
        "keyTakeaways": [
          "2-colorable check",
          "No odd-length cycles",
          "BFS/DFS with coloring",
          "O(V+E)"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bfs",
              "label": "BFS",
              "why": "Color by levels"
            }
          ],
          "nextTopics": [
            {
              "id": "bipartite_matching",
              "label": "Matching",
              "why": "On bipartite graphs"
            }
          ]
        }
      }
    },
    {
      "id": "graph_coloring",
      "label": "Graph Coloring",
      "type": "algo-graph",
      "description": "Assign colors to vertices with constraints.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Graph_coloring"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/graph-coloring-applications/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "4-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Assign colors to vertices so no adjacent vertices share color. Minimize colors.",
          "technical": "Chromatic number œá(G) = minimum colors. NP-hard for k‚â•3. Greedy gives ‚â§Œî+1 colors."
        },
        "keyTakeaways": [
          "No adjacent same color",
          "NP-hard to minimize",
          "Greedy: at most Œî+1 colors",
          "Bipartite œá=2, planar œá‚â§4"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "graph",
              "label": "Graphs",
              "why": "Graph problem"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "dp_lcs",
      "label": "Longest Common Subsequence (LCS)",
      "type": "algo-dp",
      "description": "Classic DP: find longest subsequence common to two strings.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Longest_common_subsequence_problem"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/dynamic-programming/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-4 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon"
      ],
      "interviewFrequency": "medium",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "Longest subsequence common to two sequences. Characters don't have to be contiguous.",
          "technical": "dp[i][j] = LCS of first i chars of X and first j of Y. If match, dp[i-1][j-1]+1. Else max(dp[i-1][j], dp[i][j-1])."
        },
        "keyTakeaways": [
          "O(nm) time and space",
          "Can reduce to O(min(n,m)) space",
          "Reconstruct by backtracking",
          "Used in diff tools, bioinformatics"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp",
              "label": "Dynamic Programming",
              "why": "Classic DP"
            }
          ],
          "nextTopics": [
            {
              "id": "dp_edit_distance",
              "label": "Edit Distance",
              "why": "Similar structure"
            }
          ]
        }
      }
    },
    {
      "id": "dp_lis",
      "label": "Longest Increasing Subsequence (LIS)",
      "type": "algo-dp",
      "description": "Find longest strictly increasing subsequence.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Longest_increasing_subsequence"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/dynamic-programming/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-4 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft"
      ],
      "interviewFrequency": "medium",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "Longest increasing subsequence. Elements don't have to be contiguous.",
          "technical": "O(n¬≤) DP or O(n log n) with patience sort / binary search. dp[i] = LIS ending at i."
        },
        "keyTakeaways": [
          "O(n¬≤) naive, O(n log n) optimal",
          "Binary search optimization",
          "Patience sort visualization",
          "Can reconstruct sequence"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp",
              "label": "Dynamic Programming",
              "why": "Classic DP"
            }
          ],
          "nextTopics": [
            {
              "id": "binary_search",
              "label": "Binary Search",
              "why": "For O(n log n)"
            }
          ]
        }
      }
    },
    {
      "id": "dp_knapsack_01",
      "label": "0/1 Knapsack",
      "type": "algo-dp",
      "description": "Maximize value with weight constraint; items used once.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Knapsack_problem"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/dynamic-programming/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-4 hours",
      "companies": [
        "Google",
        "Amazon"
      ],
      "interviewFrequency": "medium",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "Maximize value by selecting items (each used at most once) within weight capacity.",
          "technical": "dp[i][w] = max value using items 1..i with capacity w. Take or skip: max(dp[i-1][w], dp[i-1][w-wt[i]] + val[i])."
        },
        "keyTakeaways": [
          "Take or skip each item",
          "O(nW) pseudo-polynomial",
          "Can reduce to O(W) space",
          "NP-hard (exponential in bits of W)"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp",
              "label": "Dynamic Programming",
              "why": "Classic DP"
            }
          ],
          "nextTopics": [
            {
              "id": "dp_knapsack_unbounded",
              "label": "Unbounded Knapsack",
              "why": "Unlimited items"
            }
          ]
        }
      }
    },
    {
      "id": "dp_knapsack_unbounded",
      "label": "Unbounded Knapsack",
      "type": "algo-dp",
      "description": "Knapsack with unlimited item copies.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Knapsack_problem"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/unbounded-knapsack-repetition-items-allowed/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "Knapsack where each item can be used unlimited times.",
          "technical": "dp[w] = max value for capacity w. For each item: dp[w] = max(dp[w], dp[w-wt[i]] + val[i])."
        },
        "keyTakeaways": [
          "Items can repeat",
          "O(nW) time, O(W) space",
          "1D array sufficient",
          "Coin change is similar"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp_knapsack_01",
              "label": "0/1 Knapsack",
              "why": "Simpler version"
            }
          ],
          "nextTopics": [
            {
              "id": "dp_coin_change",
              "label": "Coin Change",
              "why": "Similar pattern"
            }
          ]
        }
      }
    },
    {
      "id": "dp_edit_distance",
      "label": "Edit Distance (Levenshtein)",
      "type": "algo-dp",
      "description": "Minimum edits to transform one string to another.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Edit_distance"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/dynamic-programming/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/edit-distance-dp-5/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "4-5 hours",
      "companies": [
        "Google",
        "Meta"
      ],
      "interviewFrequency": "medium",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "Minimum insertions, deletions, substitutions to transform one string to another.",
          "technical": "dp[i][j] = edit distance of first i chars of A and j of B. Match: dp[i-1][j-1]. Else: 1 + min(ins, del, sub)."
        },
        "keyTakeaways": [
          "O(nm) time and space",
          "Also called Levenshtein distance",
          "Used in spell check, diff",
          "Can reduce to O(min(n,m)) space"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp_lcs",
              "label": "LCS",
              "why": "Similar structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "dp_matrix_chain",
      "label": "Matrix Chain Multiplication",
      "type": "algo-dp",
      "description": "Optimal parenthesization for matrix products.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Matrix_chain_multiplication"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "Find optimal parenthesization of matrix multiplication to minimize scalar operations.",
          "technical": "dp[i][j] = min cost to multiply matrices i..j. Try all split points k: dp[i][k] + dp[k+1][j] + cost(i,k,j)."
        },
        "keyTakeaways": [
          "Interval DP pattern",
          "O(n¬≥) time",
          "Catalan number of ways",
          "Optimal substructure on intervals"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp",
              "label": "Dynamic Programming",
              "why": "Interval DP"
            }
          ],
          "nextTopics": [
            {
              "id": "dp_interval",
              "label": "Interval DP",
              "why": "General pattern"
            }
          ]
        }
      }
    },
    {
      "id": "dp_coin_change",
      "label": "Coin Change",
      "type": "algo-dp",
      "description": "Minimum coins to make a target sum.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Change-making_problem"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/dynamic-programming/"
          },
          {
            "title": "LeetCode #322",
            "url": "https://leetcode.com/problems/coin-change/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-4 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Coinbase"
      ],
      "interviewFrequency": "medium",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "Minimum coins to make target amount (or count ways to make it).",
          "technical": "Min coins: dp[a] = min(dp[a-coin]+1) for all coins. Count ways: dp[a] += dp[a-coin]."
        },
        "keyTakeaways": [
          "Unbounded knapsack variant",
          "O(amount √ó coins)",
          "Two variants: min count, count ways",
          "Order matters for permutations"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp_knapsack_unbounded",
              "label": "Unbounded Knapsack",
              "why": "Same pattern"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "dp_rod_cutting",
      "label": "Rod Cutting",
      "type": "algo-dp",
      "description": "Maximize profit by cutting rod into pieces.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Cutting_stock_problem"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/cutting-a-rod-dp-13/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "Cut rod into pieces to maximize total price. Each length has a price.",
          "technical": "dp[n] = max(price[i] + dp[n-i]) for i in 1..n. Unbounded knapsack where items are cut lengths."
        },
        "keyTakeaways": [
          "Unbounded knapsack variant",
          "O(n¬≤) time",
          "Classic DP problem",
          "Prices given for each length"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp_knapsack_unbounded",
              "label": "Unbounded Knapsack",
              "why": "Same pattern"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "dp_palindrome",
      "label": "Palindrome DP",
      "type": "algo-dp",
      "description": "Longest palindromic subsequence/substring problems.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Longest_palindromic_substring"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/dynamic-programming/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/longest-palindrome-substring-set-1/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "Problems involving palindromic substrings: longest palindrome, min cuts, count.",
          "technical": "dp[i][j] = true if s[i..j] is palindrome. s[i]==s[j] && dp[i+1][j-1]. Min cuts uses additional DP."
        },
        "keyTakeaways": [
          "Check palindrome in O(1) after preprocessing",
          "Longest palindromic substring",
          "Minimum palindrome partitioning",
          "O(n¬≤) preprocessing"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp",
              "label": "Dynamic Programming",
              "why": "Core DP"
            }
          ],
          "nextTopics": [
            {
              "id": "manacher",
              "label": "Manacher's",
              "why": "O(n) for all palindromes"
            }
          ]
        }
      }
    },
    {
      "id": "dp_subset_sum",
      "label": "Subset Sum",
      "type": "algo-dp",
      "description": "Determine if subset sums to target.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Subset_sum_problem"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/dynamic-programming/"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "Can a subset sum to target? Or count subsets that sum to target.",
          "technical": "dp[i][s] = can subset of first i elements sum to s? dp[i][s] = dp[i-1][s] || dp[i-1][s-arr[i]]."
        },
        "keyTakeaways": [
          "0/1 knapsack variant",
          "O(n√ósum) time",
          "Boolean or count version",
          "Space optimizable to O(sum)"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp_knapsack_01",
              "label": "0/1 Knapsack",
              "why": "Same pattern"
            }
          ],
          "nextTopics": [
            {
              "id": "dp_partition",
              "label": "Partition",
              "why": "Application"
            }
          ]
        }
      }
    },
    {
      "id": "dp_partition",
      "label": "Partition Problem",
      "type": "algo-dp",
      "description": "Split array into two equal-sum subsets.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Partition_problem"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/partition-problem-dp-18/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "Partition array into two subsets with equal sum (or minimum difference).",
          "technical": "Equal partition: check if subset with sum=total/2 exists. Min diff: find closest achievable sum to total/2."
        },
        "keyTakeaways": [
          "Reduce to subset sum",
          "Equal partition: target = sum/2",
          "Min diff: closest to sum/2",
          "O(n√ósum) time"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp_subset_sum",
              "label": "Subset Sum",
              "why": "Core technique"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "dp_catalan",
      "label": "Catalan Numbers",
      "type": "algo-dp",
      "description": "Counting problems: valid parentheses, BST shapes, etc.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Catalan_number"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/program-nth-catalan-number/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "Catalan number C(n) counts many combinatorial structures: valid parentheses, BST shapes, polygon triangulations.",
          "technical": "C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0). Also C(n) = (2n)! / ((n+1)! √ó n!)."
        },
        "keyTakeaways": [
          "Counts valid parentheses",
          "Counts BST structures",
          "C(n) = binom(2n,n)/(n+1)",
          "Appears in many combinatorics problems"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp",
              "label": "Dynamic Programming",
              "why": "Recursive structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "dp_digit",
      "label": "Digit DP",
      "type": "algo-dp",
      "description": "Count numbers with digit-based constraints.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Dynamic_programming"
          }
        ],
        "community": [
          {
            "title": "Codeforces Blog",
            "url": "https://codeforces.com/blog/entry/53960"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/digit-dp-introduction/"
          }
        ]
      },
      "difficulty": 8,
      "timeEstimate": "6-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "Count numbers in range [L,R] satisfying some property by building digit by digit.",
          "technical": "State: (position, tight, ...property flags). Tight = still bounded by input. Memo on state."
        },
        "keyTakeaways": [
          "Count numbers with property",
          "Build digit by digit",
          "Tight flag tracks bound",
          "Common: sum of digits, no repeated digits"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp",
              "label": "Dynamic Programming",
              "why": "Advanced DP"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "dp_on_trees",
      "label": "DP on Trees",
      "type": "algo-dp",
      "description": "Dynamic programming applied to tree structures.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Dynamic_programming"
          }
        ],
        "community": [
          {
            "title": "Codeforces Blog",
            "url": "https://codeforces.com/blog/entry/20935"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/dynamic-programming-trees-set-1/"
          }
        ]
      },
      "difficulty": 8,
      "timeEstimate": "6-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "DP where states are tree nodes. Combine children's answers to compute parent's.",
          "technical": "Usually DFS-based. dp[v] computed from dp[children]. Rerooting for 'answer for each node as root'."
        },
        "keyTakeaways": [
          "DFS post-order to fill",
          "Subtree aggregation",
          "Rerooting technique for all-roots",
          "Applications: diameter, matching, paths"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "tree",
              "label": "Trees",
              "why": "Tree structure"
            },
            {
              "id": "dp",
              "label": "DP",
              "why": "Core technique"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "dp_interval",
      "label": "Interval DP",
      "type": "algo-dp",
      "description": "DP over contiguous intervals (e.g., matrix chain).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Dynamic_programming"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/introduction-to-interval-dp/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "DP over intervals [i,j]. Build from smaller intervals to larger.",
          "technical": "dp[i][j] computed from dp[i][k] and dp[k+1][j] for all k. Fill diagonally by interval length."
        },
        "keyTakeaways": [
          "Matrix chain, optimal BST",
          "Fill by interval length",
          "O(n¬≥) typical",
          "Split point optimization possible"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp",
              "label": "Dynamic Programming",
              "why": "Core DP"
            }
          ],
          "nextTopics": [
            {
              "id": "dp_matrix_chain",
              "label": "Matrix Chain",
              "why": "Classic example"
            }
          ]
        }
      }
    },
    {
      "id": "gcd_lcm",
      "label": "GCD / LCM",
      "type": "algo-math",
      "description": "Greatest common divisor / least common multiple.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Greatest_common_divisor"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/algebra/euclid-algorithm.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/program-to-find-gcd-or-hcf-of-two-numbers/"
          }
        ]
      },
      "difficulty": 2,
      "timeEstimate": "1-2 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon"
      ],
      "interviewFrequency": "medium",
      "category": "Math",
      "categoryIcon": "üî£",
      "content": {
        "definition": {
          "simple": "GCD: largest number dividing both. LCM: smallest number divisible by both.",
          "technical": "GCD(a,b) via Euclidean algorithm. LCM(a,b) = a√ób / GCD(a,b)."
        },
        "keyTakeaways": [
          "GCD via Euclidean algorithm",
          "LCM = a√ób / GCD",
          "GCD is O(log min(a,b))",
          "Used in fractions, modular arithmetic"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "math",
              "label": "Math Fundamentals",
              "why": "Number theory"
            }
          ],
          "nextTopics": [
            {
              "id": "euclidean",
              "label": "Euclidean Algorithm",
              "why": "Implementation"
            }
          ]
        }
      }
    },
    {
      "id": "euclidean",
      "label": "Euclidean Algorithm",
      "type": "algo-math",
      "description": "Efficient GCD computation.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Euclidean_algorithm"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/algebra/euclid-algorithm.html"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2-3 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Math",
      "categoryIcon": "üî£",
      "content": {
        "definition": {
          "simple": "GCD(a,b) = GCD(b, a mod b). Repeat until b=0, then GCD is a.",
          "technical": "O(log min(a,b)) iterations. Based on: GCD(a,b) = GCD(b, a mod b)."
        },
        "keyTakeaways": [
          "GCD(a,b) = GCD(b, a%b)",
          "Stop when b=0",
          "O(log min(a,b))",
          "Fundamental algorithm"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "math",
              "label": "Math",
              "why": "Number theory"
            }
          ],
          "nextTopics": [
            {
              "id": "extended_euclidean",
              "label": "Extended Euclidean",
              "why": "Find coefficients"
            }
          ]
        }
      }
    },
    {
      "id": "extended_euclidean",
      "label": "Extended Euclidean",
      "type": "algo-math",
      "description": "Find x,y such that ax + by = gcd(a,b).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/algebra/extended-euclid-algorithm.html"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Math",
      "categoryIcon": "üî£",
      "content": {
        "definition": {
          "simple": "Find x, y such that ax + by = GCD(a,b). Used for modular inverse.",
          "technical": "Backtrack through Euclidean algorithm. If GCD=1, x is modular inverse of a mod b."
        },
        "keyTakeaways": [
          "Finds Bezout coefficients",
          "ax + by = GCD(a,b)",
          "Used for mod inverse",
          "O(log min(a,b))"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "euclidean",
              "label": "Euclidean",
              "why": "Extends basic algorithm"
            }
          ],
          "nextTopics": [
            {
              "id": "mod_inverse",
              "label": "Mod Inverse",
              "why": "Application"
            }
          ]
        }
      }
    },
    {
      "id": "sieve",
      "label": "Sieve of Eratosthenes",
      "type": "algo-math",
      "description": "Generate all primes up to n in O(n log log n).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/sieve-of-eratosthenes/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "3-4 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Math",
      "categoryIcon": "üî£",
      "content": {
        "definition": {
          "simple": "Find all primes up to N by marking multiples of each prime as composite.",
          "technical": "Start with 2, mark all multiples. Move to next unmarked, repeat. O(n log log n)."
        },
        "keyTakeaways": [
          "O(n log log n) time",
          "O(n) space",
          "Mark multiples as composite",
          "Starting from p¬≤, mark p√óp, p√ó(p+1), ..."
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "math",
              "label": "Math",
              "why": "Prime numbers"
            }
          ],
          "nextTopics": [
            {
              "id": "prime_factorization",
              "label": "Prime Factorization",
              "why": "Uses primes"
            }
          ]
        }
      }
    },
    {
      "id": "prime_factorization",
      "label": "Prime Factorization",
      "type": "algo-math",
      "description": "Decompose number into prime factors.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Integer_factorization"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/algebra/factorization.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/print-all-prime-factors-of-a-given-number/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Math",
      "categoryIcon": "üî£",
      "content": {
        "definition": {
          "simple": "Express number as product of prime powers: n = p1^a1 √ó p2^a2 √ó ...",
          "technical": "Trial division O(‚àön). With smallest prime factor array (from sieve), O(log n)."
        },
        "keyTakeaways": [
          "Trial division: O(‚àön)",
          "SPF array: O(log n)",
          "Unique factorization",
          "Used in GCD, LCM, divisors"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "sieve",
              "label": "Sieve",
              "why": "SPF optimization"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "modular_arithmetic",
      "label": "Modular Arithmetic",
      "type": "concept",
      "description": "Arithmetic under modulo; used in cryptography/hashing.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Modular_arithmetic"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/algebra/module-inverse.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/modular-arithmetic/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "3-4 hours",
      "companies": [
        "Google"
      ],
      "interviewFrequency": "low",
      "category": "Concept",
      "categoryIcon": "üí°",
      "content": {
        "definition": {
          "simple": "Arithmetic where numbers wrap around at modulus. (a+b) mod m = ((a mod m) + (b mod m)) mod m.",
          "technical": "Ring Z/mZ. Preserves +, -, √ó. Division requires modular inverse. Used to avoid overflow."
        },
        "keyTakeaways": [
          "(a+b)%m = (a%m + b%m)%m",
          "(a√ób)%m = (a%m √ó b%m)%m",
          "Division needs inverse",
          "Keeps numbers bounded"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "math",
              "label": "Math",
              "why": "Fundamentals"
            }
          ],
          "nextTopics": [
            {
              "id": "mod_inverse",
              "label": "Mod Inverse",
              "why": "For division"
            }
          ]
        }
      }
    },
    {
      "id": "mod_inverse",
      "label": "Modular Inverse",
      "type": "algo-math",
      "description": "Find a^(-1) mod m using extended Euclidean or Fermat.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Modular_multiplicative_inverse"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/algebra/module-inverse.html"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Math",
      "categoryIcon": "üî£",
      "content": {
        "definition": {
          "simple": "Find x where a√óx ‚â° 1 (mod m). Enables 'division' in modular arithmetic.",
          "technical": "Exists iff GCD(a,m)=1. Compute via extended Euclidean or a^(m-2) mod m (if m prime)."
        },
        "keyTakeaways": [
          "a √ó a^(-1) ‚â° 1 (mod m)",
          "Requires GCD(a,m)=1",
          "Fermat: a^(m-2) if m prime",
          "Extended Euclidean: general case"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "extended_euclidean",
              "label": "Extended Euclidean",
              "why": "Computation method"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "fast_exponentiation",
      "label": "Fast Exponentiation",
      "type": "algo-math",
      "description": "Compute a^n in O(log n) via binary exponentiation.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Exponentiation_by_squaring"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/algebra/binary-exp.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/modular-exponentiation-power-in-modular-arithmetic/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "3-4 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Math",
      "categoryIcon": "üî£",
      "content": {
        "definition": {
          "simple": "Compute a^n in O(log n) by squaring. a^10 = (a^5)^2 = (a^4 √ó a)^2.",
          "technical": "Binary exponentiation. If n odd: a √ó a^(n-1). If even: (a^(n/2))^2. O(log n) multiplications."
        },
        "keyTakeaways": [
          "O(log n) multiplications",
          "Square when n even",
          "Multiply when n odd",
          "Works with mod for large numbers"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "math",
              "label": "Math",
              "why": "Exponents"
            }
          ],
          "nextTopics": [
            {
              "id": "matrix_exponentiation",
              "label": "Matrix Exp",
              "why": "Apply to matrices"
            }
          ]
        }
      }
    },
    {
      "id": "chinese_remainder",
      "label": "Chinese Remainder Theorem",
      "type": "algo-math",
      "description": "Solve system of modular congruences.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Chinese_remainder_theorem"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/algebra/chinese-remainder-theorem.html"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Math",
      "categoryIcon": "üî£",
      "content": {
        "definition": {
          "simple": "Find x satisfying multiple congruences: x ‚â° a1 (mod m1), x ‚â° a2 (mod m2), ...",
          "technical": "If m_i pairwise coprime, unique solution mod M = m1√óm2√ó... Compute via construction."
        },
        "keyTakeaways": [
          "System of congruences",
          "Requires coprime moduli",
          "Unique solution mod product",
          "Used in RSA, big number computation"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "modular_arithmetic",
              "label": "Mod Arithmetic",
              "why": "Foundation"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "combinatorics",
      "label": "Combinatorics (nCr, nPr)",
      "type": "algo-math",
      "description": "Counting combinations and permutations.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Combinatorics"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/combinatorics/binomial-coefficients.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/combinatorics/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Math",
      "categoryIcon": "üî£",
      "content": {
        "definition": {
          "simple": "Counting: nCr = ways to choose r from n. nPr = ordered arrangements.",
          "technical": "nCr = n!/(r!(n-r)!). Pascal's triangle. Lucas theorem for nCr mod p."
        },
        "keyTakeaways": [
          "nCr = n! / (r! √ó (n-r)!)",
          "nPr = n! / (n-r)!",
          "Pascal: nCr = (n-1)C(r-1) + (n-1)Cr",
          "Precompute factorials for mod"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "math",
              "label": "Math",
              "why": "Factorials"
            }
          ],
          "nextTopics": [
            {
              "id": "dp_catalan",
              "label": "Catalan Numbers",
              "why": "Counting application"
            }
          ]
        }
      }
    },
    {
      "id": "matrix_exponentiation",
      "label": "Matrix Exponentiation",
      "type": "algo-math",
      "description": "Fast computation of linear recurrences (e.g., Fibonacci).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Matrix_exponentiation"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/algebra/binary-exp.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/matrix-exponentiation/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "5-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Math",
      "categoryIcon": "üî£",
      "content": {
        "definition": {
          "simple": "Compute M^n in O(k¬≥ log n) for k√ók matrix. Used for linear recurrences.",
          "technical": "Same binary exponentiation but with matrix multiplication. Fibonacci in O(log n)."
        },
        "keyTakeaways": [
          "O(k¬≥ log n) for k√ók matrix",
          "Linear recurrence in O(log n)",
          "Fibonacci: [[1,1],[1,0]]^n",
          "State transitions as matrices"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "fast_exponentiation",
              "label": "Fast Exp",
              "why": "Same technique"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "fermats_little",
      "label": "Fermat's Little Theorem",
      "type": "concept",
      "description": "a^(p-1) = 1 mod p for prime p; used for mod inverse.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Fermat%27s_little_theorem"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/fermats-little-theorem/"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2-3 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Concept",
      "categoryIcon": "üí°",
      "content": {
        "definition": {
          "simple": "If p prime and GCD(a,p)=1, then a^(p-1) ‚â° 1 (mod p).",
          "technical": "Corollary: a^(-1) ‚â° a^(p-2) (mod p). Used for modular inverse when modulus is prime."
        },
        "keyTakeaways": [
          "a^(p-1) ‚â° 1 (mod p)",
          "Mod inverse: a^(p-2)",
          "Only for prime modulus",
          "Basis for primality tests"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "modular_arithmetic",
              "label": "Mod Arithmetic",
              "why": "Foundation"
            }
          ],
          "nextTopics": [
            {
              "id": "miller_rabin",
              "label": "Miller-Rabin",
              "why": "Primality test"
            }
          ]
        }
      }
    },
    {
      "id": "probability_theory",
      "label": "Probability Theory",
      "type": "concept",
      "description": "Mathematical framework for randomness.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Probability_theory"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/math/"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2-3 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Concept",
      "categoryIcon": "üí°",
      "content": {
        "definition": {
          "simple": "Study of random events. Expected value, probability distributions, independence.",
          "technical": "E[X+Y] = E[X] + E[Y]. P(A‚à©B) = P(A)√óP(B) if independent. Used in randomized algorithms."
        },
        "keyTakeaways": [
          "Linearity of expectation",
          "Independence: P(A‚à©B) = P(A)P(B)",
          "Expected value for algorithm analysis",
          "Randomized algorithms"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "math",
              "label": "Math",
              "why": "Foundation"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "convex_hull",
      "label": "Convex Hull",
      "type": "algo-geometry",
      "description": "Smallest convex polygon enclosing all points.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Convex_hull_algorithms"
          }
        ],
        "community": [
          {
            "title": "VisualGo Interactive",
            "url": "https://visualgo.net/en/convexhull"
          },
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/geometry/convex-hull.html"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/geometry/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "5-6 hours",
      "companies": [
        "Google"
      ],
      "interviewFrequency": "low",
      "category": "Geometry",
      "categoryIcon": "üìê",
      "content": {
        "definition": {
          "simple": "Smallest convex polygon containing all points. Like rubber band around nails.",
          "technical": "Graham scan O(n log n), Jarvis march O(nh). Points ordered CCW on hull boundary."
        },
        "keyTakeaways": [
          "Smallest enclosing convex polygon",
          "Graham scan: O(n log n)",
          "Jarvis march: O(nh)",
          "Applications: collision, shape analysis"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "sorting",
              "label": "Sorting",
              "why": "Sort by angle"
            }
          ],
          "nextTopics": [
            {
              "id": "rotating_calipers",
              "label": "Rotating Calipers",
              "why": "Hull applications"
            }
          ]
        }
      }
    },
    {
      "id": "line_intersection",
      "label": "Line Intersection",
      "type": "algo-geometry",
      "description": "Detect/find intersection of line segments.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Line‚Äìline_intersection"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/geometry/lines-intersection.html"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "4-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Geometry",
      "categoryIcon": "üìê",
      "content": {
        "definition": {
          "simple": "Find if/where two line segments intersect.",
          "technical": "Use cross products to check orientation. Four points define two segments. Handle collinear cases."
        },
        "keyTakeaways": [
          "Cross product for orientation",
          "Handle collinear cases",
          "Used in polygon algorithms",
          "O(1) per pair"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "math",
              "label": "Math",
              "why": "Vector math"
            }
          ],
          "nextTopics": [
            {
              "id": "sweep_line",
              "label": "Sweep Line",
              "why": "Many intersections"
            }
          ]
        }
      }
    },
    {
      "id": "closest_pair",
      "label": "Closest Pair of Points",
      "type": "algo-geometry",
      "description": "Find two closest points in O(n log n).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Closest_pair_of_points_problem"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/closest-pair-of-points-onlogn-implementation/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "5-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Geometry",
      "categoryIcon": "üìê",
      "content": {
        "definition": {
          "simple": "Find two points with minimum distance. O(n log n) divide and conquer.",
          "technical": "Sort by x. Divide. Combine by checking strip of width 2Œ¥. Only O(1) points per point in strip."
        },
        "keyTakeaways": [
          "O(n log n) divide and conquer",
          "Strip optimization: O(1) per point",
          "Randomized O(n) possible",
          "Foundation for clustering"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "divide_conquer",
              "label": "Divide & Conquer",
              "why": "Algorithm type"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "sweep_line",
      "label": "Sweep Line Algorithm",
      "type": "algo-geometry",
      "description": "Process geometric events in sorted order.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Sweep_line_algorithm"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/geometry/intersecting_segments.html"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-6 hours",
      "companies": [
        "Google"
      ],
      "interviewFrequency": "low",
      "category": "Geometry",
      "categoryIcon": "üìê",
      "content": {
        "definition": {
          "simple": "Process events left-to-right with a vertical sweep line. Maintains active set.",
          "technical": "Sort events by x. Process with balanced BST of active elements. O(n log n) typical."
        },
        "keyTakeaways": [
          "Events sorted by x",
          "Active set in balanced BST",
          "O(n log n) typical",
          "Used for intersections, closest pair"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bst",
              "label": "BST",
              "why": "Active set structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "point_in_polygon",
      "label": "Point in Polygon",
      "type": "algo-geometry",
      "description": "Test if point lies inside a polygon.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Point_in_polygon"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/how-to-check-if-a-given-point-lies-inside-a-polygon/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "4-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Geometry",
      "categoryIcon": "üìê",
      "content": {
        "definition": {
          "simple": "Determine if point is inside, outside, or on polygon boundary.",
          "technical": "Ray casting: count crossings. Odd = inside. Handle edge cases at vertices."
        },
        "keyTakeaways": [
          "Ray casting algorithm",
          "Odd crossings = inside",
          "Handle vertex edge cases",
          "O(n) for n-vertex polygon"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "line_intersection",
              "label": "Line Intersection",
              "why": "Ray-edge test"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "polygon_area",
      "label": "Polygon Area",
      "type": "algo-geometry",
      "description": "Compute area using Shoelace formula.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Shoelace_formula"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/area-of-a-polygon-with-given-n-ordered-vertices/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "4-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Geometry",
      "categoryIcon": "üìê",
      "content": {
        "definition": {
          "simple": "Area of polygon given vertices. Shoelace formula.",
          "technical": "Area = 0.5 √ó |Œ£(x[i]√óy[i+1] - x[i+1]√óy[i])|. Works for any simple polygon."
        },
        "keyTakeaways": [
          "Shoelace formula",
          "O(n) for n vertices",
          "Signed area for orientation",
          "Works for convex/concave"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "math",
              "label": "Math",
              "why": "Coordinate geometry"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "minimax",
      "label": "Minimax",
      "type": "algo-game",
      "description": "Optimal strategy for two-player zero-sum games.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Minimax"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/minimax-algorithm-in-game-theory-set-1-introduction/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "4-5 hours",
      "companies": [
        "Google"
      ],
      "interviewFrequency": "low",
      "category": "Game Theory",
      "categoryIcon": "üéÆ",
      "content": {
        "definition": {
          "simple": "Game algorithm: maximize your score, assume opponent minimizes it.",
          "technical": "Recursive evaluation of game tree. Maximizer picks max child, minimizer picks min. O(b^d)."
        },
        "keyTakeaways": [
          "You maximize, opponent minimizes",
          "Game tree exploration",
          "O(b^d) complexity",
          "Used in chess, tic-tac-toe"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "recursion",
              "label": "Recursion",
              "why": "Recursive algorithm"
            }
          ],
          "nextTopics": [
            {
              "id": "alpha_beta",
              "label": "Alpha-Beta",
              "why": "Optimization"
            }
          ]
        }
      }
    },
    {
      "id": "alpha_beta",
      "label": "Alpha-Beta Pruning",
      "type": "algo-game",
      "description": "Optimization of minimax by pruning branches.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Alpha‚Äìbeta_pruning"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/minimax-algorithm-in-game-theory-set-4-alpha-beta-pruning/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "5-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Game Theory",
      "categoryIcon": "üéÆ",
      "content": {
        "definition": {
          "simple": "Minimax optimization: prune branches that can't affect result.",
          "technical": "Track alpha (best for max) and beta (best for min). Prune when alpha ‚â• beta. Same result, fewer nodes."
        },
        "keyTakeaways": [
          "Prunes minimax tree",
          "Alpha = best for max",
          "Beta = best for min",
          "Up to O(b^(d/2)) with good ordering"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "minimax",
              "label": "Minimax",
              "why": "Base algorithm"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "nim",
      "label": "Nim / Sprague-Grundy",
      "type": "algo-game",
      "description": "Game theory for impartial games; XOR-based analysis.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Nim"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/game_theory/sprague-grundy-nim.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/combinatorial-game-theory-set-2-game-nim/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "5-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Game Theory",
      "categoryIcon": "üéÆ",
      "content": {
        "definition": {
          "simple": "Game theory: Nim-sum (XOR of pile sizes) determines winner. Zero = losing position.",
          "technical": "Sprague-Grundy theorem generalizes. Every impartial game equivalent to Nim heap."
        },
        "keyTakeaways": [
          "XOR of sizes = 0 means losing",
          "Sprague-Grundy numbers",
          "Impartial game theory",
          "Combine games with XOR"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bits",
              "label": "Bit Manipulation",
              "why": "XOR operation"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "game_tree",
      "label": "Game Tree",
      "type": "ds-specialized",
      "description": "Tree representing all possible game states.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Game_tree"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/game-theory-gfg/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "4-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Tree of all possible game states and moves. Root = initial state.",
          "technical": "Nodes = game states, edges = moves. Exponential size. Basis for minimax, MCTS."
        },
        "keyTakeaways": [
          "States as nodes",
          "Moves as edges",
          "Exponential size",
          "Search with minimax/MCTS"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "tree",
              "label": "Trees",
              "why": "Tree structure"
            }
          ],
          "nextTopics": [
            {
              "id": "minimax",
              "label": "Minimax",
              "why": "Game tree search"
            }
          ]
        }
      }
    },
    {
      "id": "comparison",
      "label": "Comparison",
      "type": "concept",
      "description": "Ordering relation between elements; basis of comparison sorts.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Comparison_sort"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/know-your-sorting-algorithm-set-1-sorting-weapons-used-by-programming-languages/"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2-3 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Concept",
      "categoryIcon": "üí°",
      "content": {
        "definition": {
          "simple": "Algorithm comparison: when to use which data structure or algorithm.",
          "technical": "Trade-offs: time vs space, insert vs query, simplicity vs performance."
        },
        "keyTakeaways": [
          "Trade-offs are key",
          "Profile before optimizing",
          "Right tool for job",
          "Benchmarking matters"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "big_o",
              "label": "Big O",
              "why": "Complexity analysis"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "circular_ll",
      "label": "Circular Linked List",
      "type": "ds-linear",
      "description": "Linked list where tail points back to head.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Linked_list#Circular_linked_list"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/circular-linked-list/"
          }
        ]
      },
      "difficulty": 2,
      "timeEstimate": "1-2 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Linear DS",
      "categoryIcon": "üìä",
      "content": {
        "definition": {
          "simple": "Linked list where last node points to first. No null terminator.",
          "technical": "Tail.next = head. Useful for round-robin, cycling. Detect with fast/slow pointers."
        },
        "keyTakeaways": [
          "Last ‚Üí first",
          "No null terminator",
          "Round-robin applications",
          "Detect cycle with two pointers"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "linked_list",
              "label": "Linked List",
              "why": "List variant"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "sparse_matrix",
      "label": "Sparse Matrix",
      "type": "ds-specialized",
      "description": "Efficient storage for matrices with mostly zeros.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Sparse_matrix"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/sparse-matrix-representation/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "4-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "A matrix is a 2D grid of values. Key patterns: traverse in spirals, search in sorted matrix, use rows as 1D problems (histogram), and apply 2D prefix sums for submatrix queries.",
          "technical": "A matrix is an m√ón array where elements are accessed via matrix[row][col]. Matrix problems leverage 2D structure for efficient algorithms: O(m+n) search in row/col sorted matrix, O(mn) DP for paths, and O(1) submatrix sum with 2D prefix sums."
        },
        "howItWorks": {
          "explanation": "Think of a matrix as a city grid. To find something, you need strategies: spiral (follow the perimeter inward), diagonal (move along slopes), or layer-by-layer (process row by row, treating each as a sub-problem).",
          "steps": [
            {
              "step": 1,
              "title": "Understand Matrix Type",
              "description": "Is it sorted? By rows? Columns? Both?",
              "why": "Determines search strategy."
            },
            {
              "step": 2,
              "title": "Choose Traversal",
              "description": "Spiral, diagonal, layer-by-layer, or BFS/DFS",
              "why": "Problem dictates traversal order."
            },
            {
              "step": 3,
              "title": "Track Boundaries",
              "description": "top, bottom, left, right for spiral; (r, c) for position",
              "why": "Avoid out-of-bounds errors."
            },
            {
              "step": 4,
              "title": "Reduce to 1D",
              "description": "Often treat each row as an array problem",
              "why": "Histogram in maximal rectangle, prefix sum per row."
            },
            {
              "step": 5,
              "title": "Use DP if Needed",
              "description": "For paths, cumulative properties",
              "why": "dp[i][j] = f(dp[i-1][j], dp[i][j-1])"
            }
          ],
          "diagram": {
            "type": "mermaid",
            "code": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\ngraph LR\n    subgraph \"Common Matrix Patterns\"\n        A[Spiral Traversal] \n        B[Binary Search]\n        C[BFS/DFS Flood Fill]\n        D[DP for Paths]\n        E[Row-by-Row Reduction]\n    end\n    \n    style A fill:#ee6c4d\n    style B fill:#98c1d9\n    style C fill:#3d5a80\n    style D fill:#ee6c4d\n    style E fill:#98c1d9",
            "caption": "Matrix problems reduce to one of these core patterns"
          }
        },
        "whenToUse": {
          "summary": "Matrix patterns apply to grids, images, game boards, and any 2D data.",
          "patterns": [
            {
              "pattern": "Spiral Traversal",
              "signal": "Visit all cells in spiral order",
              "example": "Spiral Matrix, Print in spiral",
              "withoutIt": "Complex nested loops, error-prone",
              "withIt": "4-direction walk with boundaries"
            },
            {
              "pattern": "Search in Sorted Matrix",
              "signal": "Matrix sorted row-wise and/or column-wise",
              "example": "Search 2D Matrix, Find target",
              "withoutIt": "O(mn) brute force",
              "withIt": "O(m+n) from top-right or O(log mn) binary search"
            },
            {
              "pattern": "Island/Flood Fill",
              "signal": "Connected regions in grid",
              "example": "Number of Islands, Max Area",
              "withoutIt": "Complex tracking",
              "withIt": "BFS/DFS from each unvisited 1"
            },
            {
              "pattern": "Maximal Rectangle",
              "signal": "Largest rectangle of 1s in binary matrix",
              "example": "Maximal Rectangle, Max Square",
              "withoutIt": "O(m¬≤n¬≤) checking all rectangles",
              "withIt": "O(mn) using histogram per row + monotonic stack"
            }
          ]
        },
        "whenNotToUse": {
          "summary": "When grid structure doesn't help or problem is fundamentally different.",
          "antiPatterns": [
            {
              "situation": "Sparse Data",
              "why": "Most cells empty wastes memory",
              "useInstead": "Adjacency list or coordinate map",
              "example": "Million x Million grid with 100 points"
            },
            {
              "situation": "Graph with Non-Grid Edges",
              "why": "Matrix implies 4-directional neighbors",
              "useInstead": "Adjacency list",
              "example": "Cities connected by arbitrary roads"
            },
            {
              "situation": "No Spatial Relationship",
              "why": "Matrix structure adds no value",
              "useInstead": "Linear array or other DS",
              "example": "Data has no 2D relationship"
            }
          ]
        },
        "intuition": {
          "analogy": {
            "title": "The City Grid Navigator",
            "story": "A city grid is a matrix. Finding a restaurant in a sorted directory (rows = streets, cols = avenues, both numbered) - start at one corner and eliminate rows/columns. Flood fill is like water spreading through connected streets. Spiral is like a tourist walking the perimeter, then going inward.",
            "connection": "Every matrix operation has a real-world grid analogy. Think spatially!"
          },
          "keyInsight": "Most matrix problems reduce to: (1) smart traversal, (2) treating rows/cols as 1D problems, or (3) graph algorithms on grid cells.",
          "commonConfusion": [
            {
              "confusion": "Row vs Column indexing?",
              "clarification": "matrix[row][col] = matrix[y][x]. Row is vertical (y), column is horizontal (x). Confusing but standard."
            },
            {
              "confusion": "4-directional vs 8-directional?",
              "clarification": "Most problems use 4 (up/down/left/right). Some (word search, chess) use 8 including diagonals."
            },
            {
              "confusion": "When to use DP vs BFS?",
              "clarification": "DP for optimization (min path, max area). BFS for reachability, shortest path in unweighted grid."
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Spiral Traversal",
                "average": "O(mn)",
                "worst": "O(mn)",
                "note": "Visit each cell once"
              },
              {
                "operation": "Search Sorted Matrix",
                "average": "O(m+n)",
                "worst": "O(m+n)",
                "note": "From corner, eliminate row/col"
              },
              {
                "operation": "Number of Islands (BFS)",
                "average": "O(mn)",
                "worst": "O(mn)",
                "note": "Visit each cell once"
              },
              {
                "operation": "Maximal Rectangle",
                "average": "O(mn)",
                "worst": "O(mn)",
                "note": "Histogram per row"
              }
            ],
            "explanation": "Most matrix algorithms are O(mn) - must touch each cell at least once."
          },
          "space": {
            "complexity": "O(mn) or O(min(m,n))",
            "explanation": "O(mn) for DP table or visited. O(min(m,n)) for queue in BFS."
          }
        },
        "underTheHood": {
          "memoryLayout": {
            "explanation": "Matrices are stored row-major (row 0, then row 1, etc). Access matrix[i][j] = base + i*cols + j.",
            "keyPoints": [
              "Row-major: iterating row-wise is cache-friendly",
              "Column-major iteration causes cache misses",
              "For large matrices, access pattern matters for performance",
              "In-place modification vs. separate visited array tradeoff"
            ]
          },
          "languageNotes": {
            "javascript": {
              "implementation": "Array of arrays. Create with Array.from().",
              "gotchas": [
                "new Array(m).fill(new Array(n)) creates SAME inner array (bug!)",
                "Use Array.from({length: m}, () => new Array(n).fill(0))",
                "Destructure directions: const dirs = [[0,1],[1,0],[0,-1],[-1,0]]"
              ]
            },
            "python": {
              "implementation": "List of lists. Create with list comprehension.",
              "gotchas": [
                "[[0]*n]*m creates m references to SAME list (bug!)",
                "Use [[0]*n for _ in range(m)] for independent rows",
                "zip(*matrix) transposes matrix"
              ]
            }
          }
        },
        "whyItWorks": {
          "complexityProof": {
            "claim": "Search in sorted matrix is O(m+n)",
            "proof": {
              "step1": {
                "action": "Start at top-right (or bottom-left)",
                "cost": "O(1)"
              },
              "step2": {
                "action": "If target < current, move left (eliminate column)",
                "cost": "At most n left moves"
              },
              "step3": {
                "action": "If target > current, move down (eliminate row)",
                "cost": "At most m down moves"
              },
              "step4": {
                "action": "Each step eliminates row or column, never backtrack",
                "cost": "O(m+n) total"
              }
            },
            "totalCost": "O(m + n)"
          }
        },
        "codeTemplates": [
          {
            "name": "Spiral Matrix Traversal",
            "description": "Visit all cells in spiral order",
            "javascript": {
              "code": "function spiralOrder(matrix) {\n  const result = [];\n  if (!matrix.length) return result;\n  \n  let top = 0, bottom = matrix.length - 1;\n  let left = 0, right = matrix[0].length - 1;\n  \n  while (top <= bottom && left <= right) {\n    // Right\n    for (let c = left; c <= right; c++) {\n      result.push(matrix[top][c]);\n    }\n    top++;\n    \n    // Down\n    for (let r = top; r <= bottom; r++) {\n      result.push(matrix[r][right]);\n    }\n    right--;\n    \n    // Left (if rows remaining)\n    if (top <= bottom) {\n      for (let c = right; c >= left; c--) {\n        result.push(matrix[bottom][c]);\n      }\n      bottom--;\n    }\n    \n    // Up (if columns remaining)\n    if (left <= right) {\n      for (let r = bottom; r >= top; r--) {\n        result.push(matrix[r][left]);\n      }\n      left++;\n    }\n  }\n  \n  return result;\n}\n\n// Key: 4 directions, update boundaries after each pass\n// Check conditions before left/up passes for non-square matrices",
              "notes": "Boundary checks after down and right prevent duplicate visits."
            },
            "python": {
              "code": "def spiral_order(matrix):\n    if not matrix:\n        return []\n    \n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    \n    while top <= bottom and left <= right:\n        # Right\n        for c in range(left, right + 1):\n            result.append(matrix[top][c])\n        top += 1\n        \n        # Down\n        for r in range(top, bottom + 1):\n            result.append(matrix[r][right])\n        right -= 1\n        \n        # Left\n        if top <= bottom:\n            for c in range(right, left - 1, -1):\n                result.append(matrix[bottom][c])\n            bottom -= 1\n        \n        # Up\n        if left <= right:\n            for r in range(bottom, top - 1, -1):\n                result.append(matrix[r][left])\n            left += 1\n    \n    return result",
              "notes": "range(right, left-1, -1) goes from right to left inclusive."
            }
          },
          {
            "name": "Search in Sorted 2D Matrix",
            "description": "Matrix sorted row-wise and column-wise (each row and col ascending)",
            "javascript": {
              "code": "function searchMatrix(matrix, target) {\n  if (!matrix.length || !matrix[0].length) return false;\n  \n  const m = matrix.length;\n  const n = matrix[0].length;\n  \n  // Start at top-right corner\n  let row = 0;\n  let col = n - 1;\n  \n  while (row < m && col >= 0) {\n    const current = matrix[row][col];\n    \n    if (current === target) {\n      return true;  // or return [row, col]\n    } else if (current > target) {\n      col--;  // Target is left\n    } else {\n      row++;  // Target is below\n    }\n  }\n  \n  return false;\n}\n\n// Why top-right? \n// - Going left: smaller values\n// - Going down: larger values\n// Each step eliminates a row OR column\n// Total: O(m + n) moves\n\n// Alternative for fully sorted matrix (row[i][-1] < row[i+1][0]):\n// Treat as 1D array, binary search O(log(mn))",
              "notes": "Works when each row sorted AND each column sorted. Start from corner."
            },
            "python": {
              "code": "def search_matrix(matrix, target):\n    if not matrix or not matrix[0]:\n        return False\n    \n    m, n = len(matrix), len(matrix[0])\n    \n    # Start at top-right\n    row, col = 0, n - 1\n    \n    while row < m and col >= 0:\n        current = matrix[row][col]\n        \n        if current == target:\n            return True\n        elif current > target:\n            col -= 1\n        else:\n            row += 1\n    \n    return False\n\n# For matrix where each row is sorted and row[i][-1] < row[i+1][0]\n# (all elements fully sorted), use binary search:\ndef search_matrix_binary(matrix, target):\n    if not matrix or not matrix[0]:\n        return False\n    \n    m, n = len(matrix), len(matrix[0])\n    lo, hi = 0, m * n - 1\n    \n    while lo <= hi:\n        mid = (lo + hi) // 2\n        row, col = mid // n, mid % n\n        val = matrix[row][col]\n        \n        if val == target:\n            return True\n        elif val < target:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    \n    return False",
              "notes": "Two variants: O(m+n) corner search vs O(log mn) binary search."
            }
          },
          {
            "name": "Number of Islands (BFS)",
            "description": "Count connected regions of 1s",
            "javascript": {
              "code": "function numIslands(grid) {\n  if (!grid.length) return 0;\n  \n  const m = grid.length;\n  const n = grid[0].length;\n  let islands = 0;\n  \n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n  \n  function bfs(startR, startC) {\n    const queue = [[startR, startC]];\n    grid[startR][startC] = '0';  // Mark visited\n    \n    while (queue.length) {\n      const [r, c] = queue.shift();\n      \n      for (const [dr, dc] of directions) {\n        const nr = r + dr;\n        const nc = c + dc;\n        \n        if (nr >= 0 && nr < m && nc >= 0 && nc < n \n            && grid[nr][nc] === '1') {\n          grid[nr][nc] = '0';  // Mark before adding to queue\n          queue.push([nr, nc]);\n        }\n      }\n    }\n  }\n  \n  for (let r = 0; r < m; r++) {\n    for (let c = 0; c < n; c++) {\n      if (grid[r][c] === '1') {\n        islands++;\n        bfs(r, c);\n      }\n    }\n  }\n  \n  return islands;\n}\n\n// Key optimization: mark visited WHEN ADDING to queue, not when processing\n// This prevents adding same cell multiple times",
              "notes": "Modify grid in-place to mark visited. Use separate visited array if can't modify."
            },
            "python": {
              "code": "from collections import deque\n\ndef num_islands(grid):\n    if not grid:\n        return 0\n    \n    m, n = len(grid), len(grid[0])\n    islands = 0\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    def bfs(start_r, start_c):\n        queue = deque([(start_r, start_c)])\n        grid[start_r][start_c] = '0'\n        \n        while queue:\n            r, c = queue.popleft()\n            \n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                \n                if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == '1':\n                    grid[nr][nc] = '0'  # Mark before adding\n                    queue.append((nr, nc))\n    \n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == '1':\n                islands += 1\n                bfs(r, c)\n    \n    return islands\n\n# DFS version (usually shorter, but risks stack overflow on large grids)\ndef num_islands_dfs(grid):\n    if not grid:\n        return 0\n    \n    m, n = len(grid), len(grid[0])\n    \n    def dfs(r, c):\n        if r < 0 or r >= m or c < 0 or c >= n or grid[r][c] == '0':\n            return\n        grid[r][c] = '0'\n        dfs(r+1, c)\n        dfs(r-1, c)\n        dfs(r, c+1)\n        dfs(r, c-1)\n    \n    return sum(1 for r in range(m) for c in range(n) \n               if grid[r][c] == '1' and not dfs(r, c))",
              "notes": "BFS is safer for large grids (no recursion limit). DFS is shorter."
            }
          }
        ],
        "visualTrace": {
          "title": "Search Sorted Matrix for target=5",
          "input": {
            "matrix": "[[1,4,7,11],[2,5,8,12],[3,6,9,16]]",
            "target": 5
          },
          "steps": [
            {
              "step": 1,
              "position": "(0,3)",
              "value": 11,
              "action": "11 > 5, move left",
              "eliminated": "Column 3"
            },
            {
              "step": 2,
              "position": "(0,2)",
              "value": 7,
              "action": "7 > 5, move left",
              "eliminated": "Column 2"
            },
            {
              "step": 3,
              "position": "(0,1)",
              "value": 4,
              "action": "4 < 5, move down",
              "eliminated": "Row 0"
            },
            {
              "step": 4,
              "position": "(1,1)",
              "value": 5,
              "action": "Found!",
              "eliminated": ""
            }
          ],
          "output": "Found at (1,1) in 4 steps"
        },
        "commonMistakes": [
          {
            "mistake": "Wrong matrix initialization",
            "wrong": "[[0]*n]*m (same reference)",
            "right": "[[0]*n for _ in range(m)]",
            "explanation": "Multiplication creates shallow copies, all rows point to same list."
          },
          {
            "mistake": "Confusing row/col",
            "wrong": "matrix[x][y]",
            "right": "matrix[row][col] or matrix[y][x]",
            "explanation": "Row is y (vertical), col is x (horizontal). Consistent naming helps."
          },
          {
            "mistake": "BFS marking after dequeue",
            "wrong": "visited[nr][nc] = True after pop",
            "right": "Mark when adding to queue",
            "explanation": "Marking after pop allows same cell to be added multiple times."
          }
        ],
        "keyTakeaways": [
          "Matrices are row-major: iterate rows for cache efficiency",
          "Spiral: 4 directions with shrinking boundaries",
          "Sorted matrix search: O(m+n) from corner, or O(log mn) binary search",
          "Islands/flood fill: BFS/DFS marking visited when adding to queue",
          "Maximal rectangle: histogram approach row by row",
          "Common bug: [[0]*n]*m creates shared references"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Arrays",
              "why": "Matrix is 2D array"
            },
            {
              "id": "bfs",
              "label": "BFS",
              "why": "Grid traversal"
            },
            {
              "id": "dfs",
              "label": "DFS",
              "why": "Grid exploration"
            }
          ],
          "nextTopics": [
            {
              "id": "dp",
              "label": "Dynamic Programming",
              "why": "2D DP on grids"
            },
            {
              "id": "prefix_sum",
              "label": "2D Prefix Sum",
              "why": "Submatrix queries"
            },
            {
              "id": "monotonic_stack",
              "label": "Monotonic Stack",
              "why": "Maximal rectangle"
            }
          ]
        },
        "patternChain": {
          "description": "Matrix problems combine traversal, search, and graph algorithms on 2D grids",
          "buildsOn": [
            {
              "id": "array",
              "relationship": "2D extension of arrays",
              "whatToKnow": "Linear iteration"
            },
            {
              "id": "bfs",
              "relationship": "Grid as implicit graph",
              "whatToKnow": "Level-order traversal"
            },
            {
              "id": "binary_search",
              "relationship": "Search in sorted matrix",
              "whatToKnow": "Search space reduction"
            }
          ],
          "enables": [
            {
              "id": "spiral",
              "relationship": "Boundary management pattern",
              "patternName": "Spiral Traversal",
              "interviewFrequency": "High"
            },
            {
              "id": "islands",
              "relationship": "Connected components",
              "patternName": "Flood Fill",
              "interviewFrequency": "Very High"
            },
            {
              "id": "path_dp",
              "relationship": "Unique paths, min path sum",
              "patternName": "Grid DP",
              "interviewFrequency": "High"
            }
          ],
          "lineagePath": {
            "mermaidDiagram": "%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#1e3a5f', 'primaryTextColor': '#ffffff'}}}%%\nflowchart TD\n    ARR[Arrays] --> MAT[Matrix / 2D Patterns]\n    BFS[BFS] --> MAT\n    DFS[DFS] --> MAT\n    BS[Binary Search] --> MAT\n    MAT --> SPIRAL[Spiral Traversal]\n    MAT --> ISLANDS[Number of Islands]\n    MAT --> SEARCH[Search 2D Matrix]\n    MAT --> DP2D[2D DP Problems]\n    \n    style MAT fill:#ee6c4d,stroke:#1e3a5f,stroke-width:3px"
          }
        }
      }
    },
    {
      "id": "shell_sort",
      "label": "Shell Sort",
      "type": "algo-sorting",
      "description": "Generalized insertion sort with gap sequences.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Shellsort"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/shellsort/"
          }
        ]
      },
      "difficulty": 3,
      "timeEstimate": "2-3 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Sorting",
      "categoryIcon": "üî¢",
      "content": {
        "definition": {
          "simple": "Insertion sort with decreasing gap sequence. Moves elements faster.",
          "technical": "Gap sequence determines complexity. O(n^1.5) for Shell's sequence. In-place, unstable."
        },
        "keyTakeaways": [
          "Improved insertion sort",
          "Gap sequence matters",
          "O(n log¬≤ n) to O(n^1.5)",
          "In-place, unstable"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "insertion_sort",
              "label": "Insertion Sort",
              "why": "Based on insertion sort"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "a_star",
      "label": "A* Search",
      "type": "algo-graph",
      "description": "Best-first search with heuristic for optimal pathfinding.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/A*_search_algorithm"
          }
        ],
        "community": [
          {
            "title": "Red Blob Games: A*",
            "url": "https://www.redblobgames.com/pathfinding/a-star/introduction.html"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "5-6 hours",
      "companies": [
        "Google",
        "Uber",
        "LinkedIn"
      ],
      "interviewFrequency": "low",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Dijkstra with a heuristic to guide search toward goal. Used in pathfinding.",
          "technical": "f(n) = g(n) + h(n) where g = cost so far, h = heuristic to goal. Optimal if h is admissible."
        },
        "keyTakeaways": [
          "Dijkstra + heuristic",
          "f(n) = g(n) + h(n)",
          "Admissible h: never overestimates",
          "Used in games, maps, robotics"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dijkstra",
              "label": "Dijkstra",
              "why": "A* extends Dijkstra"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "johnson",
      "label": "Johnson's Algorithm",
      "type": "algo-graph",
      "description": "All-pairs shortest paths; reweights for Dijkstra.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Johnson%27s_algorithm"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/johnsons-algorithm/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "4-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "All-pairs shortest paths for sparse graphs. Reweights to remove negative edges, then runs Dijkstra.",
          "technical": "Add vertex s with 0-weight edges to all. Bellman-Ford from s. Reweight: w'(u,v) = w(u,v) + h(u) - h(v). Run Dijkstra from each vertex."
        },
        "keyTakeaways": [
          "All-pairs for sparse graphs",
          "O(V¬≤ log V + VE) time",
          "Reweighting removes negatives",
          "Better than Floyd-Warshall when E << V¬≤"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dijkstra",
              "label": "Dijkstra",
              "why": "Runs V times"
            },
            {
              "id": "bellman_ford",
              "label": "Bellman-Ford",
              "why": "For reweighting"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "hungarian",
      "label": "Hungarian Algorithm",
      "type": "algo-graph",
      "description": "Optimal assignment problem in bipartite graphs.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Hungarian_algorithm"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/hungarian-algorithm.html"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "4-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Graph Algo",
      "categoryIcon": "üìà",
      "content": {
        "definition": {
          "simple": "Optimal assignment: match workers to jobs minimizing total cost.",
          "technical": "O(n¬≥) algorithm. Build augmenting paths with slack variables. Primal-dual method."
        },
        "keyTakeaways": [
          "Optimal assignment",
          "O(n¬≥) algorithm",
          "Bipartite weighted matching",
          "Alternative: min-cost max-flow"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bipartite_matching",
              "label": "Bipartite Matching",
              "why": "Unweighted version"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "aho_corasick",
      "label": "Aho-Corasick",
      "type": "algo",
      "description": "Multi-pattern string search using automaton.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Aho‚ÄìCorasick_algorithm"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/string/aho_corasick.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/aho-corasick-algorithm-pattern-searching/"
          }
        ]
      },
      "difficulty": 8,
      "timeEstimate": "6-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Algorithm",
      "categoryIcon": "‚ö°",
      "content": {
        "definition": {
          "simple": "Multi-pattern matching. Build trie of patterns with failure links, scan text once.",
          "technical": "Trie + KMP failure links. O(n + m + z) where z = matches. Used in spam filters, intrusion detection."
        },
        "keyTakeaways": [
          "Multiple patterns at once",
          "O(n + m + z) time",
          "Trie + failure links",
          "Used in grep, virus scanners"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "trie",
              "label": "Trie",
              "why": "Built on trie"
            },
            {
              "id": "kmp",
              "label": "KMP",
              "why": "Uses failure function concept"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "manacher",
      "label": "Manacher's Algorithm",
      "type": "algo",
      "description": "Longest palindromic substring in O(n).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/string/manacher.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/manachers-algorithm-linear-time-longest-palindromic-substring-part-1/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Algorithm",
      "categoryIcon": "‚ö°",
      "content": {
        "definition": {
          "simple": "Find all palindromic substrings in O(n). Expands palindromes efficiently.",
          "technical": "Insert separators to handle even/odd. Track center and right boundary. Each position processed in amortized O(1)."
        },
        "keyTakeaways": [
          "O(n) for all palindromes",
          "Longest palindromic substring",
          "Uses symmetry of palindromes",
          "Handles even and odd lengths"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "two_pointers",
              "label": "Two Pointers",
              "why": "Expand around center"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "boyer_moore",
      "label": "Boyer-Moore",
      "type": "algo",
      "description": "Fast string search with bad character/good suffix rules.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Boyer‚ÄìMoore_string-search_algorithm"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/boyer-moore-algorithm-for-pattern-searching/"
          }
        ]
      },
      "difficulty": 4,
      "timeEstimate": "2-4 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Algorithm",
      "categoryIcon": "‚ö°",
      "content": {
        "definition": {
          "simple": "Pattern matching that skips characters using bad character and good suffix rules.",
          "technical": "Preprocess pattern. Skip based on mismatch character. O(n/m) best case, O(nm) worst. Very fast in practice."
        },
        "keyTakeaways": [
          "O(n/m) best case",
          "Skip based on mismatch",
          "Bad character + good suffix rules",
          "Fastest in practice for long patterns"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "string",
              "label": "Strings",
              "why": "String matching"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "kd_tree",
      "label": "K-D Tree",
      "type": "ds-specialized",
      "description": "Space-partitioning tree for k-dimensional points.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/K-d_tree"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/k-dimensional-tree/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "4-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "k-dimensional tree for spatial search. Alternates splitting dimension.",
          "technical": "Binary tree splitting on different axis each level. O(log n) average, O(n) worst for search."
        },
        "keyTakeaways": [
          "Spatial partitioning",
          "Alternating split dimensions",
          "O(log n) average search",
          "Range and nearest neighbor"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bst",
              "label": "BST",
              "why": "Tree structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "r_tree",
      "label": "R-Tree",
      "type": "ds-specialized",
      "description": "Spatial index for bounding boxes (GIS, databases).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/R-tree"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/introduction-to-r-tree/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "4-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Tree for spatial data using bounding rectangles. Used in databases.",
          "technical": "Each node has bounding box of children. B-tree-like balancing. PostGIS, SQLite R*Tree."
        },
        "keyTakeaways": [
          "Bounding rectangles",
          "B-tree-like structure",
          "Range and intersection queries",
          "Used in GIS databases"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "btree",
              "label": "B-Tree",
              "why": "Similar structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "merkle_tree",
      "label": "Merkle Tree",
      "type": "ds-specialized",
      "description": "Hash tree for data integrity verification.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Merkle_tree"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/introduction-to-merkle-tree/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "4-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Hash tree: leaf hashes ‚Üí parent hashes ‚Üí root. Verify data integrity.",
          "technical": "Parent = hash(left_child || right_child). Change in data changes path to root. O(log n) proof."
        },
        "keyTakeaways": [
          "Hash tree structure",
          "Root summarizes all data",
          "O(log n) membership proof",
          "Used in Git, Bitcoin, IPFS"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "hashing",
              "label": "Hashing",
              "why": "Hash functions"
            },
            {
              "id": "tree",
              "label": "Trees",
              "why": "Tree structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "quad_tree",
      "label": "Quad Tree",
      "type": "ds-specialized",
      "description": "Tree partitioning 2D space into quadrants.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Quadtree"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/quad-tree/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "4-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Tree where each node has exactly 4 children. Partition 2D space recursively.",
          "technical": "Each node represents square region. Subdivide into quadrants. Used in image compression, collision."
        },
        "keyTakeaways": [
          "4 children per node",
          "2D space partitioning",
          "Recursive subdivision",
          "Image compression, games"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "tree",
              "label": "Trees",
              "why": "Tree structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "mo_algorithm",
      "label": "Mo's Algorithm",
      "type": "algo-pattern",
      "description": "Sqrt decomposition for offline range queries.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Queries_on_interval"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/data_structures/sqrt_decomposition.html"
          },
          {
            "title": "Codeforces Blog",
            "url": "https://codeforces.com/blog/entry/83558"
          }
        ]
      },
      "difficulty": 8,
      "timeEstimate": "6-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "content": {
        "definition": {
          "simple": "Answer offline range queries by sorting queries and moving pointers.",
          "technical": "Sort queries by (L/‚àön, R). Add/remove elements at boundaries. O((n+q)‚àön) total."
        },
        "keyTakeaways": [
          "Offline queries",
          "Sort by block, then R",
          "O((n+q)‚àön)",
          "Requires add/remove operations"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "sqrt_decomposition",
              "label": "SQRT Decomposition",
              "why": "Block size"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "sqrt_decomposition",
      "label": "SQRT Decomposition",
      "type": "algo-pattern",
      "description": "Divide array into sqrt(n) blocks for balanced queries.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Queries_on_interval"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/data_structures/sqrt_decomposition.html"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "content": {
        "definition": {
          "simple": "Divide array into ‚àön blocks. Precompute per block. O(‚àön) queries.",
          "technical": "Block size ‚àön balances block traversal and element traversal. Simpler than segment tree."
        },
        "keyTakeaways": [
          "‚àön block size",
          "O(‚àön) queries",
          "Simpler than segment tree",
          "Good for complex queries"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Arrays",
              "why": "Array technique"
            }
          ],
          "nextTopics": [
            {
              "id": "mo_algorithm",
              "label": "Mo's Algorithm",
              "why": "Application"
            }
          ]
        }
      }
    },
    {
      "id": "centroid_decomposition",
      "label": "Centroid Decomposition",
      "type": "algo-pattern",
      "description": "Divide tree by centroids for path queries.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Centroid_decomposition"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/centroid-decomposition.html"
          },
          {
            "title": "Codeforces Blog",
            "url": "https://codeforces.com/blog/entry/101215"
          }
        ]
      },
      "difficulty": 9,
      "timeEstimate": "8-10 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "content": {
        "definition": {
          "simple": "Decompose tree by repeatedly finding and removing centroids. O(n log n) queries.",
          "technical": "Centroid = node whose removal leaves subtrees ‚â§ n/2. Build recursively. O(log n) depth."
        },
        "keyTakeaways": [
          "Tree decomposition",
          "O(log n) depth",
          "Path queries",
          "Divide and conquer on trees"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "tree",
              "label": "Trees",
              "why": "Tree algorithm"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "heavy_light",
      "label": "Heavy-Light Decomposition",
      "type": "algo-pattern",
      "description": "Decompose tree into chains for path queries.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Heavy_path_decomposition"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/hld.html"
          },
          {
            "title": "Codeforces Blog",
            "url": "https://codeforces.com/blog/entry/22072"
          }
        ]
      },
      "difficulty": 9,
      "timeEstimate": "8-10 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "content": {
        "definition": {
          "simple": "Decompose tree into heavy/light chains. O(log n) path queries with segment tree.",
          "technical": "Heavy edge = to largest subtree. O(log n) chains per path. Query with segment tree per chain."
        },
        "keyTakeaways": [
          "O(log n) chains per path",
          "Heavy edge = largest child",
          "Segment tree per chain",
          "Path queries/updates"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "segment_tree",
              "label": "Segment Tree",
              "why": "Query structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "fft",
      "label": "FFT (Fast Fourier Transform)",
      "type": "algo-math",
      "description": "O(n log n) polynomial multiplication via frequency domain.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Fast_Fourier_transform"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/algebra/fft.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/fast-fourier-transformation-poynomial-multiplication/"
          }
        ]
      },
      "difficulty": 9,
      "timeEstimate": "8-10 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Math",
      "categoryIcon": "üî£",
      "content": {
        "definition": {
          "simple": "Fast Fourier Transform: multiply polynomials in O(n log n).",
          "technical": "Convert to point-value form, multiply pointwise, convert back. Uses roots of unity."
        },
        "keyTakeaways": [
          "O(n log n) polynomial multiplication",
          "Divide and conquer",
          "Complex roots of unity",
          "Used in signal processing"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "divide_conquer",
              "label": "Divide & Conquer",
              "why": "Algorithm type"
            }
          ],
          "nextTopics": [
            {
              "id": "ntt",
              "label": "NTT",
              "why": "Integer version"
            }
          ]
        }
      }
    },
    {
      "id": "ntt",
      "label": "NTT (Number Theoretic Transform)",
      "type": "algo-math",
      "description": "FFT over finite fields; avoids floating point.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Number-theoretic_transform"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/algebra/fft.html#toc-tgt-4"
          }
        ]
      },
      "difficulty": 9,
      "timeEstimate": "8-10 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Math",
      "categoryIcon": "üî£",
      "content": {
        "definition": {
          "simple": "Number Theoretic Transform: FFT with modular arithmetic. Integer results.",
          "technical": "Use primitive root instead of complex roots. Works mod prime. Exact integer arithmetic."
        },
        "keyTakeaways": [
          "FFT with modular arithmetic",
          "Exact integers",
          "Primitive roots",
          "Used in competitive programming"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "fft",
              "label": "FFT",
              "why": "Base algorithm"
            },
            {
              "id": "modular_arithmetic",
              "label": "Mod Arithmetic",
              "why": "Modular ops"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "lucas",
      "label": "Lucas Theorem",
      "type": "algo-math",
      "description": "Compute nCr mod prime efficiently.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Lucas%27s_theorem"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/algebra/factorial-divisors.html"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Math",
      "categoryIcon": "üî£",
      "content": {
        "definition": {
          "simple": "Compute nCr mod p (prime) when n is large. Uses base-p representation.",
          "technical": "nCr mod p = Œ† (n_i C r_i) mod p where n_i, r_i are base-p digits. O(p + log_p(n))."
        },
        "keyTakeaways": [
          "Large nCr mod prime p",
          "Base-p digit decomposition",
          "Precompute factorials mod p",
          "Handles very large n"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "combinatorics",
              "label": "Combinatorics",
              "why": "nCr computation"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "mobius",
      "label": "Mobius Function / Inversion",
      "type": "algo-math",
      "description": "Number theory tool for inclusion-exclusion.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/M√∂bius_function"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/algebra/mobius-function.html"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Math",
      "categoryIcon": "üî£",
      "content": {
        "definition": {
          "simple": "Mobius function Œº(n): -1^k if n = product of k distinct primes, 0 if has square factor.",
          "technical": "Mobius inversion: if g(n) = Œ£d|n f(d), then f(n) = Œ£d|n Œº(d)g(n/d)."
        },
        "keyTakeaways": [
          "Œº(n) = (-1)^k for k distinct primes",
          "Œº(n) = 0 if square factor",
          "Inversion formula",
          "Used in counting problems"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "prime_factorization",
              "label": "Prime Factorization",
              "why": "Number theory"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "pollard_rho",
      "label": "Pollard's Rho",
      "type": "algo-math",
      "description": "Probabilistic factorization algorithm.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/algebra/factorization.html"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Math",
      "categoryIcon": "üî£",
      "content": {
        "definition": {
          "simple": "Probabilistic factorization algorithm. Find factor faster than trial division.",
          "technical": "Floyd's cycle detection on f(x) = x¬≤ + c mod n. Expected O(n^(1/4)) for factor."
        },
        "keyTakeaways": [
          "Probabilistic factoring",
          "Faster than trial division",
          "Uses cycle detection",
          "O(n^(1/4)) expected"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "prime_factorization",
              "label": "Factorization",
              "why": "Problem domain"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "miller_rabin",
      "label": "Miller-Rabin Primality",
      "type": "algo-math",
      "description": "Probabilistic primality test.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Miller‚ÄìRabin_primality_test"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/algebra/primality_tests.html"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Math",
      "categoryIcon": "üî£",
      "content": {
        "definition": {
          "simple": "Probabilistic primality test. Fast and accurate with multiple rounds.",
          "technical": "Test witnesses a. If n-1 = 2^s √ó d, check a^d ‚â† 1 and a^(2^r √ó d) ‚â† -1 for all r."
        },
        "keyTakeaways": [
          "Probabilistic primality",
          "O(k log¬≥ n)",
          "Deterministic for n < 3,317,044,064,679,887,385,961,981",
          "Used in cryptography"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "fast_exponentiation",
              "label": "Fast Exp",
              "why": "Modular exponentiation"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "dp_sos",
      "label": "SOS DP (Sum over Subsets)",
      "type": "algo-dp",
      "description": "DP to compute sums over all subsets efficiently.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Dynamic_programming"
          }
        ],
        "community": [
          {
            "title": "Codeforces Blog",
            "url": "https://codeforces.com/blog/entry/45223"
          }
        ]
      },
      "difficulty": 9,
      "timeEstimate": "8-10 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "Sum over Subsets DP: compute f(S) = Œ£ g(T) for all T ‚äÜ S.",
          "technical": "O(n √ó 2^n) instead of O(3^n). Process dimension by dimension."
        },
        "keyTakeaways": [
          "Sum over all subsets",
          "O(n √ó 2^n)",
          "Dimension by dimension",
          "Used in bitmask problems"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bitmask_dp",
              "label": "Bitmask DP",
              "why": "Bitmask operations"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "dp_broken_profile",
      "label": "Broken Profile DP",
      "type": "algo-dp",
      "description": "DP for grid problems with irregular boundaries.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Dynamic_programming"
          }
        ],
        "community": [
          {
            "title": "Codeforces Blog",
            "url": "https://codeforces.com/blog/entry/18051"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "DP for tiling problems. State = boundary profile as bitmask.",
          "technical": "State encodes filled/unfilled cells at boundary. Transition by placing next tile. O(n √ó m √ó 2^m)."
        },
        "keyTakeaways": [
          "Tiling problems",
          "Profile as bitmask",
          "O(n √ó m √ó 2^m)",
          "Domino, L-tromino tiling"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bitmask_dp",
              "label": "Bitmask DP",
              "why": "Bitmask state"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "dp_convex_hull_trick",
      "label": "Convex Hull Trick",
      "type": "algo-dp",
      "description": "Optimize DP with linear functions using convex hull.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Dynamic_programming"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/geometry/convex_hull_trick.html"
          },
          {
            "title": "Codeforces Blog",
            "url": "https://codeforces.com/blog/entry/63823"
          }
        ]
      },
      "difficulty": 9,
      "timeEstimate": "8-10 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "Optimize DP with linear functions. Maintain convex hull for O(1) or O(log n) query.",
          "technical": "dp[i] = min(a[j] √ó b[i] + c[j]). Maintain lines in convex hull. Query optimal line."
        },
        "keyTakeaways": [
          "Linear function optimization",
          "Convex hull of lines",
          "O(n) or O(n log n)",
          "Used in 1D/1D DP"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp",
              "label": "DP",
              "why": "DP optimization"
            }
          ],
          "nextTopics": [
            {
              "id": "li_chao_tree",
              "label": "Li Chao Tree",
              "why": "Alternative"
            }
          ]
        }
      }
    },
    {
      "id": "dp_divide_conquer",
      "label": "Divide & Conquer DP",
      "type": "algo-dp",
      "description": "Optimize DP using monotonicity in transitions.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Divide-and-conquer_optimization"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/dynamic_programming/divide-and-conquer-dp.html"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "content": {
        "definition": {
          "simple": "Optimize DP when optimal j is monotonic. Divide and conquer on ranges.",
          "technical": "If opt(i) ‚â§ opt(i+1), use D&C. Compute mid, split range. O(n log n) instead of O(n¬≤)."
        },
        "keyTakeaways": [
          "Monotonic optimal point",
          "Divide and conquer",
          "O(n log n)",
          "Used in segment DP"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "divide_conquer",
              "label": "Divide & Conquer",
              "why": "Technique"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "lca",
      "label": "LCA (Lowest Common Ancestor)",
      "type": "algo-pattern",
      "description": "Find common ancestor of two tree nodes.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Lowest_common_ancestor"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/lca.html"
          },
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/tree/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "5-6 hours",
      "companies": [
        "Google"
      ],
      "interviewFrequency": "low",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "content": {
        "definition": {
          "simple": "Lowest common ancestor: deepest node that is ancestor of both given nodes.",
          "technical": "O(log n) with binary lifting. O(1) with Euler tour + RMQ. O(n) preprocessing."
        },
        "keyTakeaways": [
          "Deepest common ancestor",
          "Binary lifting: O(log n) query",
          "Euler tour + RMQ: O(1) query",
          "Used in tree path queries"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "tree",
              "label": "Trees",
              "why": "Tree structure"
            }
          ],
          "nextTopics": [
            {
              "id": "binary_lifting",
              "label": "Binary Lifting",
              "why": "LCA technique"
            }
          ]
        }
      }
    },
    {
      "id": "rmq",
      "label": "RMQ (Range Minimum Query)",
      "type": "algo-pattern",
      "description": "Query minimum in a range; O(1) with preprocessing.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Range_minimum_query"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/data_structures/sparse-table.html"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "content": {
        "definition": {
          "simple": "Range minimum query: find minimum in subarray [L, R].",
          "technical": "Sparse table: O(n log n) build, O(1) query. Segment tree: O(n) build, O(log n) query."
        },
        "keyTakeaways": [
          "Find min/max in range",
          "Sparse table: O(1) query",
          "Segment tree: O(log n) query",
          "Trade-off: build time vs query time"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "array",
              "label": "Arrays",
              "why": "Array queries"
            }
          ],
          "nextTopics": [
            {
              "id": "sparse_table",
              "label": "Sparse Table",
              "why": "O(1) queries"
            }
          ]
        }
      }
    },
    {
      "id": "sparse_table",
      "label": "Sparse Table",
      "type": "ds-specialized",
      "description": "O(1) RMQ with O(n log n) preprocessing; immutable.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Range_minimum_query"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/data_structures/sparse-table.html"
          },
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/sparse-table/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "4-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Precompute answers for all power-of-2 ranges. O(1) query for idempotent ops.",
          "technical": "st[i][j] = answer for range [i, i+2^j). Query: overlap two ranges covering [L,R]. O(n log n) space/build."
        },
        "keyTakeaways": [
          "O(1) query for min/max/GCD",
          "O(n log n) preprocessing",
          "Only for idempotent operations",
          "Overlap technique for queries"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "rmq",
              "label": "RMQ",
              "why": "Problem it solves"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "binary_lifting",
      "label": "Binary Lifting",
      "type": "algo-pattern",
      "description": "Jump 2^k ancestors for O(log n) LCA queries.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Lowest_common_ancestor#Binary_lifting"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/lca_binary_lifting.html"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-6 hours",
      "companies": [
        "Google"
      ],
      "interviewFrequency": "low",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "content": {
        "definition": {
          "simple": "Precompute 2^k-th ancestors. Jump in O(log n) using binary representation.",
          "technical": "up[v][k] = 2^k-th ancestor of v. LCA: lift to same depth, then lift together. O(n log n) preprocessing."
        },
        "keyTakeaways": [
          "Jump 2^k ancestors at once",
          "O(log n) ancestor queries",
          "Used for LCA",
          "O(n log n) preprocessing"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "tree",
              "label": "Trees",
              "why": "Tree structure"
            }
          ],
          "nextTopics": [
            {
              "id": "lca",
              "label": "LCA",
              "why": "Application"
            }
          ]
        }
      }
    },
    {
      "id": "euler_tour",
      "label": "Euler Tour Technique",
      "type": "algo-pattern",
      "description": "Flatten tree to array for range queries.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Euler_tour_technique"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/graph/euler_path.html"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "content": {
        "definition": {
          "simple": "Flatten tree into array by recording nodes on DFS entry/exit. Enables range queries.",
          "technical": "Enter at time[v], exit at time[v] + size[v] - 1. Subtree = contiguous range. LCA via RMQ."
        },
        "keyTakeaways": [
          "Tree to array",
          "Subtree = contiguous range",
          "Enables range queries",
          "LCA with RMQ"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dfs",
              "label": "DFS",
              "why": "DFS traversal"
            }
          ],
          "nextTopics": [
            {
              "id": "lca",
              "label": "LCA",
              "why": "Application"
            }
          ]
        }
      }
    },
    {
      "id": "meet_in_middle",
      "label": "Meet in the Middle",
      "type": "algo-pattern",
      "description": "Split search space; combine halves. O(2^(n/2)).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Meet-in-the-middle_attack"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/meet-in-the-middle/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "5-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "content": {
        "definition": {
          "simple": "Split problem in half, solve each, combine. O(2^(n/2)) instead of O(2^n).",
          "technical": "Generate all 2^(n/2) solutions for each half. Merge (sort + binary search or hash). Huge speedup."
        },
        "keyTakeaways": [
          "Split problem in half",
          "O(2^(n/2)) vs O(2^n)",
          "Merge with sorting/hashing",
          "Subset sum, 4-sum"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "divide_conquer",
              "label": "Divide & Conquer",
              "why": "Splitting technique"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "small_to_large",
      "label": "Small-to-Large Merging",
      "type": "algo-pattern",
      "description": "Merge smaller set into larger; O(n log n) total.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Disjoint-set_data_structure"
          }
        ],
        "community": [
          {
            "title": "Codeforces Blog",
            "url": "https://codeforces.com/blog/entry/44351"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "content": {
        "definition": {
          "simple": "Merge smaller set into larger. Total O(n log n) merges.",
          "technical": "Each element merged O(log n) times (doubles set size each time). DSU on trees variant."
        },
        "keyTakeaways": [
          "Merge small into large",
          "O(n log n) total",
          "DSU on trees",
          "Set/map merging"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "union_find",
              "label": "Union-Find",
              "why": "Similar idea"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "virtual_tree",
      "label": "Virtual Tree (Auxiliary Tree)",
      "type": "ds-specialized",
      "description": "Compressed tree containing only relevant nodes.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Virtual_tree"
          }
        ],
        "community": [
          {
            "title": "Codeforces Blog",
            "url": "https://codeforces.com/blog/entry/43917"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "4-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Auxiliary tree containing only relevant nodes and their LCAs.",
          "technical": "Given k nodes, build tree with O(k) nodes preserving ancestor relationships. LCA queries for edges."
        },
        "keyTakeaways": [
          "O(k) nodes from k relevant",
          "Preserves structure",
          "Use LCA for edges",
          "Efficient tree DP on subset"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "lca",
              "label": "LCA",
              "why": "For construction"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "coord_compression",
      "label": "Coordinate Compression",
      "type": "algo-pattern",
      "description": "Map large value range to small indices.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Data_compression"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/convert-an-array-to-reduced-form-set-1-simple-and-hashing/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "content": {
        "definition": {
          "simple": "Map large sparse values to small dense range. Preserve relative order.",
          "technical": "Sort unique values. Map to indices 0, 1, 2, ... Use when values large but count small."
        },
        "keyTakeaways": [
          "Large range ‚Üí small range",
          "Preserves order",
          "Sort and index",
          "Enables array-based solutions"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "sorting",
              "label": "Sorting",
              "why": "Sort values"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "cdq_divide_conquer",
      "label": "CDQ Divide & Conquer",
      "type": "algo-pattern",
      "description": "Offline D&C for multidimensional problems.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm"
          }
        ],
        "community": [
          {
            "title": "Codeforces Blog",
            "url": "https://codeforces.com/blog/entry/68467"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Pattern",
      "categoryIcon": "üß©",
      "content": {
        "definition": {
          "simple": "Divide and conquer for 3D partial order problems. Chinese technique.",
          "technical": "Sort by one dimension. D&C: left contributes to right. Reduce 3D to 2D with BIT."
        },
        "keyTakeaways": [
          "3D problems in O(n log¬≤ n)",
          "Left contributes to right",
          "Reduce dimension with D&C",
          "Alternative to 2D segment tree"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "divide_conquer",
              "label": "Divide & Conquer",
              "why": "Technique"
            },
            {
              "id": "fenwick",
              "label": "Fenwick",
              "why": "Inner structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "li_chao_tree",
      "label": "Li Chao Tree",
      "type": "ds-specialized",
      "description": "Segment tree for line/convex hull queries.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Li_Chao_tree"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/geometry/convex_hull_trick.html"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "4-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Segment tree for line insertion and point minimum query.",
          "technical": "Each node stores line. Insert by comparing midpoint, push loser down. O(log n) insert/query."
        },
        "keyTakeaways": [
          "Line insertion, point query",
          "O(log n) operations",
          "Alternative to convex hull trick",
          "Handles non-monotonic"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "segment_tree",
              "label": "Segment Tree",
              "why": "Base structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "link_cut_tree",
      "label": "Link-Cut Tree",
      "type": "ds-specialized",
      "description": "Dynamic tree connectivity with path queries.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Link/cut_tree"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/data_structures/link-cut-tree.html"
          }
        ]
      },
      "difficulty": 10,
      "timeEstimate": "10+ hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Dynamic tree: link, cut, path queries. Splay tree-based.",
          "technical": "Represents tree as paths (preferred paths). O(log n) amortized for link, cut, path query."
        },
        "keyTakeaways": [
          "Dynamic connectivity",
          "Link and cut edges",
          "O(log n) amortized",
          "Path queries"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "splay_tree",
              "label": "Splay Tree",
              "why": "Base structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "euler_tour_tree",
      "label": "Euler Tour Tree",
      "type": "ds-specialized",
      "description": "Dynamic forest with subtree queries.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Euler_tour_technique"
          }
        ],
        "community": [
          {
            "title": "Codeforces Blog",
            "url": "https://codeforces.com/blog/entry/17044"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "4-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Represent tree as Euler tour sequence for dynamic connectivity.",
          "technical": "Store Euler tour in balanced BST. Link/cut by sequence manipulation. O(log n) operations."
        },
        "keyTakeaways": [
          "Euler tour in BST",
          "Dynamic connectivity",
          "O(log n) operations",
          "Alternative to link-cut tree"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "euler_tour",
              "label": "Euler Tour",
              "why": "Base concept"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "wavelet_tree",
      "label": "Wavelet Tree",
      "type": "ds-specialized",
      "description": "Range quantile/frequency queries in O(log sigma).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Wavelet_tree"
          }
        ],
        "community": [
          {
            "title": "Codeforces Blog",
            "url": "https://codeforces.com/blog/entry/17044"
          }
        ]
      },
      "difficulty": 9,
      "timeEstimate": "8-10 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Tree for range rank, select, quantile queries. O(log œÉ) operations.",
          "technical": "Binary tree on alphabet. Each level splits by bit. O(log œÉ) rank/select/quantile."
        },
        "keyTakeaways": [
          "Range rank/select queries",
          "O(log œÉ) operations",
          "Space efficient",
          "Alphabet-based splitting"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "segment_tree",
              "label": "Segment Tree",
              "why": "Tree queries"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "dancing_links",
      "label": "Dancing Links (DLX)",
      "type": "ds-specialized",
      "description": "Efficient backtracking for exact cover problems.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Dancing_Links"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/exact-cover-problem-algorithm-x-set-2-implementation-dlx/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "4-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Specialized DS",
      "categoryIcon": "‚öôÔ∏è",
      "content": {
        "definition": {
          "simple": "Efficient backtracking for exact cover. Doubly linked list with column headers.",
          "technical": "Knuth's Algorithm X with DLX. O(1) cover/uncover operations. Used for Sudoku, N-queens."
        },
        "keyTakeaways": [
          "Exact cover solver",
          "O(1) cover/uncover",
          "Algorithm X implementation",
          "Sudoku, pentomino puzzles"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "backtracking",
              "label": "Backtracking",
              "why": "Base technique"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "kadane",
      "label": "Kadane's Algorithm",
      "type": "algo-dp",
      "description": "Maximum subarray sum in O(n).",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Maximum_subarray_problem"
          }
        ],
        "community": [
          {
            "title": "LeetCode Problems",
            "url": "https://leetcode.com/tag/dynamic-programming/"
          },
          {
            "title": "LeetCode #53",
            "url": "https://leetcode.com/problems/maximum-subarray/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-8 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Microsoft",
        "Apple"
      ],
      "interviewFrequency": "high",
      "category": "Dynamic Programming",
      "categoryIcon": "üíé",
      "interviewQuestions": [
        {
          "name": "Maximum Subarray",
          "leetcode": "https://leetcode.com/problems/maximum-subarray/",
          "difficulty": "Medium",
          "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "LinkedIn"
          ],
          "frequency": "Very High",
          "whyAsked": "Classic Kadane's - local vs global optimum",
          "approach": "maxEndingHere = max(num, maxEndingHere + num). Track global max. O(n)",
          "followUps": [
            {
              "question": "Return subarray indices?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Circular variant?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Maximum Product Subarray",
          "leetcode": "https://leetcode.com/problems/maximum-product-subarray/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google",
            "Microsoft",
            "LinkedIn"
          ],
          "frequency": "Very High",
          "whyAsked": "Modified Kadane's - track both max and min (for negative flip)",
          "approach": "Track maxProduct and minProduct. Swap when negative. Update global max",
          "followUps": [
            {
              "question": "With zeros handling?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "Subarray length constraint?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        },
        {
          "name": "Best Time to Buy and Sell Stock",
          "leetcode": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
          "difficulty": "Easy",
          "companies": [
            "Amazon",
            "Meta",
            "Google"
          ],
          "frequency": "Very High",
          "whyAsked": "Kadane's variant - track min so far, max profit",
          "approach": "Track minPrice. For each price, profit = price - minPrice. Track maxProfit",
          "followUps": [
            {
              "question": "Multiple transactions?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            },
            {
              "question": "With cooldown?",
              "answer": "State machine DP: hold[i], sold[i], rest[i]. Transitions between states based on action."
            }
          ],
          "sources": [
            "blind75",
            "neetcode150",
            "grind75"
          ],
          "sourceDetails": [
            {
              "name": "Blind 75",
              "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
              "note": "Most essential interview problems"
            },
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            },
            {
              "name": "Grind 75",
              "url": "https://www.techinterviewhandbook.org/grind75",
              "note": "Customizable study plan"
            }
          ]
        },
        {
          "name": "Maximum Sum Circular Subarray",
          "leetcode": "https://leetcode.com/problems/maximum-sum-circular-subarray/",
          "difficulty": "Medium",
          "companies": [
            "Amazon",
            "Google"
          ],
          "frequency": "Medium",
          "whyAsked": "Kadane's with circular array handling",
          "approach": "Answer is max(normal Kadane, total - minSubarray). Handle all-negative case",
          "followUps": [
            {
              "question": "With limited wrap?",
              "answer": "Consider the constraints and edge cases. Apply the same core technique with modifications."
            }
          ],
          "sources": [
            "neetcode150"
          ],
          "sourceDetails": [
            {
              "name": "NeetCode 150",
              "url": "https://neetcode.io/practice",
              "note": "Extended Blind 75 with videos"
            }
          ]
        }
      ],
      "patternSources": [
        {
          "name": "NeetCode 150",
          "url": "https://neetcode.io/practice",
          "note": "Extended Blind 75 with videos"
        },
        {
          "name": "Sean Prashad's Patterns",
          "url": "https://seanprashad.com/leetcode-patterns/",
          "note": "Pattern-based categorization"
        }
      ],
      "content": {
        "definition": {
          "simple": "Find maximum sum subarray in O(n). Track current and best sum.",
          "technical": "current = max(arr[i], current + arr[i]). Reset when negative prefix hurts. Best = max of all current."
        },
        "keyTakeaways": [
          "O(n) max subarray",
          "Reset on negative prefix",
          "Classic DP",
          "Extend to 2D with O(n¬≤m)"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp",
              "label": "DP",
              "why": "Simple DP"
            }
          ],
          "nextTopics": [
            {
              "id": "subarray_sum",
              "label": "Subarray Sum",
              "why": "Related problems"
            }
          ]
        }
      }
    },
    {
      "id": "rotating_calipers",
      "label": "Rotating Calipers",
      "type": "algo-geometry",
      "description": "Antipodal points on convex hull; diameter, width.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Rotating_calipers"
          }
        ],
        "community": [
          {
            "title": "CP-Algorithms",
            "url": "https://cp-algorithms.com/geometry/rotating_calipers.html"
          }
        ]
      },
      "difficulty": 8,
      "timeEstimate": "6-8 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Geometry",
      "categoryIcon": "üìê",
      "content": {
        "definition": {
          "simple": "Rotate parallel lines around convex hull to find diameter, width, etc.",
          "technical": "Two pointers on hull, rotate together. O(n) after hull computed. Finds furthest pair."
        },
        "keyTakeaways": [
          "Works on convex hull",
          "O(n) after hull construction",
          "Finds diameter, width",
          "Antipodal points technique"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "convex_hull",
              "label": "Convex Hull",
              "why": "Input requirement"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "voronoi",
      "label": "Voronoi Diagram",
      "type": "algo-geometry",
      "description": "Partition plane by nearest site.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Voronoi_diagram"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/voronoi-diagram/"
          }
        ]
      },
      "difficulty": 9,
      "timeEstimate": "8-10 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Geometry",
      "categoryIcon": "üìê",
      "content": {
        "definition": {
          "simple": "Partition plane into regions closest to each point.",
          "technical": "Dual of Delaunay triangulation. Fortune's algorithm O(n log n). Used in nearest neighbor."
        },
        "keyTakeaways": [
          "Region = closest to point",
          "Dual of Delaunay",
          "Fortune's algorithm O(n log n)",
          "Nearest neighbor queries"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "convex_hull",
              "label": "Convex Hull",
              "why": "Geometric algorithms"
            }
          ],
          "nextTopics": [
            {
              "id": "delaunay",
              "label": "Delaunay",
              "why": "Dual structure"
            }
          ]
        }
      }
    },
    {
      "id": "delaunay",
      "label": "Delaunay Triangulation",
      "type": "algo-geometry",
      "description": "Triangulation maximizing minimum angle; dual of Voronoi.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Delaunay_triangulation"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/delaunay-triangulation/"
          }
        ]
      },
      "difficulty": 9,
      "timeEstimate": "8-10 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Geometry",
      "categoryIcon": "üìê",
      "content": {
        "definition": {
          "simple": "Triangulation maximizing minimum angle. No point inside circumcircle of any triangle.",
          "technical": "Dual of Voronoi. O(n log n) construction. Used in mesh generation, interpolation."
        },
        "keyTakeaways": [
          "Maximizes minimum angle",
          "Empty circumcircle property",
          "Dual of Voronoi diagram",
          "Used for mesh generation"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "voronoi",
              "label": "Voronoi",
              "why": "Dual structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "consistent_hash",
      "label": "Consistent Hashing",
      "type": "ds-distributed",
      "description": "Distributed hashing with minimal remapping on node change.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Consistent_hashing"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/consistent-hashing/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "4-5 hours",
      "companies": [
        "Google",
        "Meta",
        "Amazon",
        "Uber",
        "DoorDash"
      ],
      "interviewFrequency": "medium",
      "category": "Distributed DS",
      "categoryIcon": "‚òÅÔ∏è",
      "content": {
        "definition": {
          "simple": "Hash ring that minimizes remapping when nodes added/removed. Used in distributed systems.",
          "technical": "Map keys and nodes to ring [0, 2^32). Key assigned to next node clockwise. Only K/n keys remap on changes."
        },
        "keyTakeaways": [
          "Minimizes remapping",
          "Ring-based assignment",
          "Virtual nodes for balance",
          "Used in Dynamo, Cassandra"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "hashing",
              "label": "Hashing",
              "why": "Hash function basics"
            }
          ],
          "nextTopics": [
            {
              "id": "dht",
              "label": "DHT",
              "why": "Application"
            }
          ]
        }
      }
    },
    {
      "id": "dht",
      "label": "Distributed Hash Table",
      "type": "ds-distributed",
      "description": "Decentralized key-value store across nodes.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Distributed_hash_table"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/distributed-hash-table/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Distributed DS",
      "categoryIcon": "‚òÅÔ∏è",
      "content": {
        "definition": {
          "simple": "Distributed Hash Table: key-value storage across multiple nodes. No central server.",
          "technical": "Chord, Kademlia, Pastry protocols. O(log n) lookups. Each node stores part of key space."
        },
        "keyTakeaways": [
          "Decentralized key-value store",
          "O(log n) routing",
          "Chord, Kademlia protocols",
          "Used in P2P, IPFS"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "consistent_hash",
              "label": "Consistent Hashing",
              "why": "Key distribution"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "lsm_tree",
      "label": "LSM Tree",
      "type": "ds-distributed",
      "description": "Log-structured merge tree for write-heavy workloads.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Log-structured_merge-tree"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/introduction-to-lsm-trees/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-6 hours",
      "companies": [
        "Google",
        "Meta"
      ],
      "interviewFrequency": "low",
      "category": "Distributed DS",
      "categoryIcon": "‚òÅÔ∏è",
      "content": {
        "definition": {
          "simple": "Log-Structured Merge Tree: write-optimized. Buffer in memory, flush to sorted files, merge.",
          "technical": "MemTable ‚Üí SSTable. Compaction merges levels. Bloom filters for reads. O(1) write, O(log n) read."
        },
        "keyTakeaways": [
          "Write-optimized",
          "Memory buffer + disk files",
          "Compaction for space",
          "Used in LevelDB, RocksDB, Cassandra"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "btree",
              "label": "B-Tree",
              "why": "Compare approaches"
            }
          ],
          "nextTopics": [
            {
              "id": "sstable",
              "label": "SSTable",
              "why": "Component"
            }
          ]
        }
      }
    },
    {
      "id": "sstable",
      "label": "SSTable",
      "type": "ds-distributed",
      "description": "Sorted String Table; immutable on-disk storage.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Apache_Cassandra#SSTables"
          }
        ],
        "community": [
          {
            "title": "Cassandra Docs",
            "url": "https://cassandra.apache.org/doc/latest/cassandra/architecture/storage-engine.html"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Distributed DS",
      "categoryIcon": "‚òÅÔ∏è",
      "content": {
        "definition": {
          "simple": "Sorted String Table: immutable sorted key-value file. Building block of LSM trees.",
          "technical": "Keys sorted within file. Index for O(log n) lookup. Bloom filter for negative queries. Immutable."
        },
        "keyTakeaways": [
          "Sorted, immutable file",
          "Index + bloom filter",
          "Efficient range scans",
          "LSM tree component"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "lsm_tree",
              "label": "LSM Tree",
              "why": "Part of LSM"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "wal",
      "label": "Write-Ahead Log (WAL)",
      "type": "ds-distributed",
      "description": "Durability via logging before writes.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Write-ahead_logging"
          }
        ],
        "community": [
          {
            "title": "PostgreSQL WAL",
            "url": "https://www.postgresql.org/docs/current/wal-intro.html"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Distributed DS",
      "categoryIcon": "‚òÅÔ∏è",
      "content": {
        "definition": {
          "simple": "Write-Ahead Log: durability via logging before modifying data. Crash recovery.",
          "technical": "Append-only log of operations. Replay on crash. Checkpointing for log truncation."
        },
        "keyTakeaways": [
          "Log before writing data",
          "Crash recovery",
          "Append-only for speed",
          "Checkpoints trim log"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "lsm_tree",
              "label": "LSM Tree",
              "why": "Uses WAL"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "inverted_index",
      "label": "Inverted Index",
      "type": "ds-distributed",
      "description": "Map terms to documents; basis of search engines.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Inverted_index"
          }
        ],
        "community": [
          {
            "title": "Elasticsearch: Inverted Index",
            "url": "https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Distributed DS",
      "categoryIcon": "‚òÅÔ∏è",
      "content": {
        "definition": {
          "simple": "Map from terms to documents containing them. Core of search engines.",
          "technical": "term ‚Üí [(doc_id, positions)]. Enables O(1) term lookup. Posting lists compressed."
        },
        "keyTakeaways": [
          "Term ‚Üí document mapping",
          "Core of search engines",
          "Posting list per term",
          "TF-IDF scoring"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "hash_map",
              "label": "Hash Map",
              "why": "Term lookup"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "dag",
      "label": "DAG (Directed Acyclic Graph)",
      "type": "ds-complex",
      "description": "Graph with no cycles; enables topological order.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Directed_acyclic_graph"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/introduction-to-directed-acyclic-graph/"
          }
        ]
      },
      "difficulty": 5,
      "timeEstimate": "4-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Complex DS",
      "categoryIcon": "üï∏Ô∏è",
      "content": {
        "definition": {
          "simple": "Directed Acyclic Graph: directed edges, no cycles. Models dependencies.",
          "technical": "Has topological ordering. Shortest/longest path in O(V+E). Used in build systems, scheduling."
        },
        "keyTakeaways": [
          "No cycles",
          "Topological order exists",
          "Models dependencies",
          "O(V+E) path algorithms"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "graph",
              "label": "Graphs",
              "why": "Graph type"
            }
          ],
          "nextTopics": [
            {
              "id": "topological_sort",
              "label": "Topo Sort",
              "why": "DAG ordering"
            }
          ]
        }
      }
    },
    {
      "id": "crdt",
      "label": "CRDT",
      "type": "ds-distributed",
      "description": "Conflict-free replicated data type for distributed sync.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type"
          }
        ],
        "community": [
          {
            "title": "CRDT.tech",
            "url": "https://crdt.tech/"
          }
        ]
      },
      "difficulty": 7,
      "timeEstimate": "5-6 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Distributed DS",
      "categoryIcon": "‚òÅÔ∏è",
      "content": {
        "definition": {
          "simple": "Conflict-free Replicated Data Type: merge without coordination. Eventually consistent.",
          "technical": "State-based or operation-based. Merge is commutative/associative/idempotent. No conflicts."
        },
        "keyTakeaways": [
          "No merge conflicts",
          "Eventually consistent",
          "G-Counter, LWW-Register examples",
          "Used in distributed DBs"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "distributed",
              "label": "Distributed Systems",
              "why": "Use case"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "cuckoo_filter",
      "label": "Cuckoo Filter",
      "type": "ds-probabilistic",
      "description": "Bloom filter variant supporting deletions.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Cuckoo_filter"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/cuckoo-filter-in-python/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Probabilistic DS",
      "categoryIcon": "üé≤",
      "content": {
        "definition": {
          "simple": "Like Bloom filter but supports deletion. Uses cuckoo hashing.",
          "technical": "Store fingerprints. Two buckets per item. Relocate on collision. Supports delete."
        },
        "keyTakeaways": [
          "Supports deletion",
          "Lower false positive rate",
          "Cuckoo hashing relocation",
          "Alternative to Bloom"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bloom",
              "label": "Bloom Filter",
              "why": "Similar purpose"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "counting_bloom",
      "label": "Counting Bloom Filter",
      "type": "ds-probabilistic",
      "description": "Bloom filter with counters for deletions.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Counting_Bloom_filter"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/counting-bloom-filters-an-introduction/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Probabilistic DS",
      "categoryIcon": "üé≤",
      "content": {
        "definition": {
          "simple": "Bloom filter with counters instead of bits. Supports deletion.",
          "technical": "Each position is counter, not bit. Increment on insert, decrement on delete. More space."
        },
        "keyTakeaways": [
          "Counters instead of bits",
          "Supports deletion",
          "4-8 bits per counter typical",
          "Counter overflow risk"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bloom",
              "label": "Bloom Filter",
              "why": "Base structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "t_digest",
      "label": "T-Digest",
      "type": "ds-probabilistic",
      "description": "Streaming percentile/quantile estimation.",
      "references": {
        "official": [
          {
            "title": "T-Digest Paper",
            "url": "https://arxiv.org/abs/1902.04023"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/t-digest/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Probabilistic DS",
      "categoryIcon": "üé≤",
      "content": {
        "definition": {
          "simple": "Estimate percentiles from streaming data. Accurate at extremes.",
          "technical": "Cluster centroids with varying precision. Merge-friendly. O(1) to add, O(log n) query."
        },
        "keyTakeaways": [
          "Streaming percentiles",
          "Accurate at tails",
          "Merge-friendly",
          "Used in Elasticsearch"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "statistics",
              "label": "Statistics",
              "why": "Percentiles"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "token_bucket",
      "label": "Token Bucket",
      "type": "ds-distributed",
      "description": "Rate limiting algorithm with burst capacity.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Token_bucket"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/rate-limiter-system-design/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Distributed DS",
      "categoryIcon": "‚òÅÔ∏è",
      "content": {
        "definition": {
          "simple": "Rate limiting: bucket fills with tokens over time. Request consumes token.",
          "technical": "Tokens added at rate r, capacity b. Allows bursts up to b. Smooth rate over time."
        },
        "keyTakeaways": [
          "Allows bursts",
          "Tokens added continuously",
          "Request needs token",
          "Smooth long-term rate"
        ],
        "learningPath": {
          "prerequisites": [],
          "nextTopics": [
            {
              "id": "leaky_bucket",
              "label": "Leaky Bucket",
              "why": "Alternative"
            }
          ]
        }
      }
    },
    {
      "id": "leaky_bucket",
      "label": "Leaky Bucket",
      "type": "ds-distributed",
      "description": "Rate limiting with constant output rate.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Leaky_bucket"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/rate-limiter-system-design/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Distributed DS",
      "categoryIcon": "‚òÅÔ∏è",
      "content": {
        "definition": {
          "simple": "Rate limiting: requests enter bucket, leak out at fixed rate. No bursts.",
          "technical": "Queue with fixed output rate. Overflow rejected. Smooths traffic completely."
        },
        "keyTakeaways": [
          "Fixed output rate",
          "No bursts allowed",
          "Queue-based",
          "Stricter than token bucket"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "token_bucket",
              "label": "Token Bucket",
              "why": "Compare approaches"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "time_series_db",
      "label": "Time Series Structures",
      "type": "ds-distributed",
      "description": "Optimized storage for time-indexed data.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Time_series_database"
          }
        ],
        "community": [
          {
            "title": "InfluxDB Docs",
            "url": "https://docs.influxdata.com/influxdb/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Distributed DS",
      "categoryIcon": "‚òÅÔ∏è",
      "content": {
        "definition": {
          "simple": "Database optimized for time-stamped data. Efficient append and range queries.",
          "technical": "Columnar storage, time-based partitioning, compression. InfluxDB, TimescaleDB, Prometheus."
        },
        "keyTakeaways": [
          "Optimized for timestamps",
          "Append-heavy workload",
          "Range queries efficient",
          "High compression"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "btree",
              "label": "B-Tree",
              "why": "Index structures"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "geohash",
      "label": "Geohash",
      "type": "ds-distributed",
      "description": "Encode lat/lng to string for spatial indexing.",
      "references": {
        "official": [
          {
            "title": "Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Geohash"
          }
        ],
        "community": [
          {
            "title": "GeeksforGeeks",
            "url": "https://www.geeksforgeeks.org/geohash/"
          }
        ]
      },
      "difficulty": 6,
      "timeEstimate": "3-5 hours",
      "companies": [],
      "interviewFrequency": "rare",
      "category": "Distributed DS",
      "categoryIcon": "‚òÅÔ∏è",
      "content": {
        "definition": {
          "simple": "Encode latitude/longitude into string. Nearby locations share prefix.",
          "technical": "Interleave lat/lng bits, base32 encode. Longer prefix = more precise. Z-order curve."
        },
        "keyTakeaways": [
          "Location ‚Üí string",
          "Nearby = shared prefix",
          "Hierarchical precision",
          "Used in spatial indexing"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bits",
              "label": "Bit Manipulation",
              "why": "Bit interleaving"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "binary",
      "label": "Binary Numbers",
      "type": "primitive",
      "description": "Base-2 number representation. Foundation for bit manipulation.",
      "category": "Foundation",
      "categoryIcon": "üßÆ",
      "difficulty": 1,
      "timeEstimate": "30 min",
      "content": {
        "definition": {
          "simple": "Binary is a base-2 number system using only 0s and 1s. It's how computers represent ALL data internally.",
          "technical": "Each digit (bit) represents a power of 2. Position n from the right represents 2^n. Example: 1101‚ÇÇ = 1√ó8 + 1√ó4 + 0√ó2 + 1√ó1 = 13‚ÇÅ‚ÇÄ"
        },
        "howItWorks": {
          "explanation": "Computers use binary because transistors have two states: on (1) or off (0). Everything‚Äînumbers, text, images‚Äîis stored as sequences of bits.",
          "steps": [
            {
              "step": 1,
              "title": "Decimal to Binary",
              "description": "Divide by 2 repeatedly, collect remainders right-to-left",
              "why": "Each division extracts one bit"
            },
            {
              "step": 2,
              "title": "Binary to Decimal",
              "description": "Multiply each bit by its position's power of 2, sum all",
              "why": "Reconstructs the base-10 value"
            },
            {
              "step": 3,
              "title": "Binary Arithmetic",
              "description": "Add like decimal but carry at 2 instead of 10",
              "why": "1+1=10 in binary (carry the 1)"
            }
          ]
        },
        "whenToUse": {
          "summary": "Understanding binary is essential for bit manipulation, understanding memory, and low-level optimizations.",
          "patterns": [
            {
              "pattern": "Bit Manipulation",
              "signal": "Need to toggle/check individual bits",
              "example": "Check if number is odd: n & 1",
              "withoutIt": "Use modulo (slower)",
              "withIt": "Single AND operation"
            },
            {
              "pattern": "Flags/Bitmasks",
              "signal": "Store multiple boolean states efficiently",
              "example": "Unix file permissions (rwx)",
              "withoutIt": "Array of booleans",
              "withIt": "Single integer"
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "Decimal to Binary",
                "average": "O(log n)",
                "worst": "O(log n)",
                "note": "log‚ÇÇ(n) divisions"
              },
              {
                "operation": "Binary to Decimal",
                "average": "O(k)",
                "worst": "O(k)",
                "note": "k = number of bits"
              }
            ]
          },
          "space": {
            "complexity": "O(log n)",
            "explanation": "log‚ÇÇ(n) bits needed to represent n"
          }
        },
        "keyTakeaways": [
          "Binary is base-2: only 0 and 1",
          "Each bit position = power of 2 (1, 2, 4, 8, 16...)",
          "n bits can represent 2^n different values (0 to 2^n - 1)",
          "Computers use binary because transistors are on/off switches",
          "Understanding binary unlocks bit manipulation tricks"
        ],
        "learningPath": {
          "prerequisites": [],
          "nextTopics": [
            {
              "id": "bits",
              "label": "Bit Manipulation",
              "why": "Apply binary knowledge to algorithms"
            },
            {
              "id": "memory",
              "label": "Memory",
              "why": "Understand how data is stored"
            }
          ]
        }
      }
    },
    {
      "id": "math",
      "label": "Math Fundamentals",
      "type": "primitive",
      "description": "Powers of 2, modular arithmetic, and number theory basics.",
      "category": "Foundation",
      "categoryIcon": "‚ûó",
      "difficulty": 2,
      "timeEstimate": "1 hour",
      "content": {
        "definition": {
          "simple": "Core mathematical concepts used throughout DSA: powers of 2, modular arithmetic, logarithms, and number theory.",
          "technical": "Includes: exponentiation (a^n), modulo operation (a % m), logarithms (log‚ÇÇ n), GCD/LCM, prime factorization, and combinatorics."
        },
        "howItWorks": {
          "explanation": "These math concepts form the foundation for complexity analysis, cryptography, hashing, and many algorithms.",
          "steps": [
            {
              "step": 1,
              "title": "Powers of 2",
              "description": "2^0=1, 2^1=2, 2^2=4, 2^3=8, 2^10=1024",
              "why": "Fundamental to binary and memory sizing"
            },
            {
              "step": 2,
              "title": "Logarithms",
              "description": "log‚ÇÇ(n) = how many times divide n by 2 to reach 1",
              "why": "Explains O(log n) complexity"
            },
            {
              "step": 3,
              "title": "Modular Arithmetic",
              "description": "a % m = remainder when a divided by m",
              "why": "Keeps numbers in bounds, used in hashing"
            },
            {
              "step": 4,
              "title": "GCD",
              "description": "Greatest Common Divisor via Euclidean algorithm",
              "why": "Used in fractions, LCM, cryptography"
            }
          ]
        },
        "whenToUse": {
          "summary": "Math fundamentals appear in complexity analysis, number theory problems, and optimization techniques.",
          "patterns": [
            {
              "pattern": "Modular Arithmetic",
              "signal": "Answer can overflow or need 'mod 10^9+7'",
              "example": "Count combinations mod 10^9+7",
              "withoutIt": "Overflow errors",
              "withIt": "Safe bounded results"
            },
            {
              "pattern": "Binary Exponentiation",
              "signal": "Calculate a^n efficiently",
              "example": "Power(x, n) in O(log n)",
              "withoutIt": "O(n) multiplications",
              "withIt": "O(log n) with squaring"
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "GCD (Euclidean)",
                "average": "O(log min(a,b))",
                "worst": "O(log min(a,b))",
                "note": "Very efficient"
              },
              {
                "operation": "Power (naive)",
                "average": "O(n)",
                "worst": "O(n)",
                "note": "n multiplications"
              },
              {
                "operation": "Power (binary exp)",
                "average": "O(log n)",
                "worst": "O(log n)",
                "note": "Square and multiply"
              }
            ]
          },
          "space": {
            "complexity": "O(1)",
            "explanation": "Most operations use constant space"
          }
        },
        "codeTemplates": [
          {
            "name": "Binary Exponentiation",
            "description": "Calculate a^n mod m in O(log n)",
            "javascript": {
              "code": "function power(a, n, mod = 1e9 + 7) {\\n  let result = 1n;\\n  a = BigInt(a) % BigInt(mod);\\n  n = BigInt(n);\\n  while (n > 0n) {\\n    if (n % 2n === 1n) result = (result * a) % BigInt(mod);\\n    n = n / 2n;\\n    a = (a * a) % BigInt(mod);\\n  }\\n  return Number(result);\\n}",
              "notes": "Uses BigInt to avoid overflow. Square a each iteration, multiply into result when bit is set."
            },
            "python": {
              "code": "def power(a, n, mod=10**9+7):\\n    result = 1\\n    a = a % mod\\n    while n > 0:\\n        if n % 2 == 1:\\n            result = (result * a) % mod\\n        n //= 2\\n        a = (a * a) % mod\\n    return result\\n\\n# Or use built-in: pow(a, n, mod)",
              "notes": "Python's built-in pow(a, n, mod) does this efficiently."
            }
          },
          {
            "name": "GCD (Euclidean Algorithm)",
            "description": "Find greatest common divisor",
            "javascript": {
              "code": "function gcd(a, b) {\\n  while (b !== 0) {\\n    [a, b] = [b, a % b];\\n  }\\n  return a;\\n}\\n\\nfunction lcm(a, b) {\\n  return (a / gcd(a, b)) * b; // Divide first to avoid overflow\\n}",
              "notes": "Iterative is cleaner than recursive. LCM = a*b/gcd(a,b)"
            },
            "python": {
              "code": "from math import gcd, lcm  # Python 3.9+\\n\\n# Or manual:\\ndef gcd(a, b):\\n    while b:\\n        a, b = b, a % b\\n    return a",
              "notes": "Use math.gcd and math.lcm from standard library"
            }
          }
        ],
        "keyTakeaways": [
          "Powers of 2: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024...",
          "log‚ÇÇ(n) = number of times to halve n ‚Üí explains binary search O(log n)",
          "Modulo keeps numbers bounded: (a + b) % m = ((a % m) + (b % m)) % m",
          "Binary exponentiation: O(log n) instead of O(n) for power calculation",
          "GCD via Euclidean algorithm is O(log min(a,b))"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "binary",
              "label": "Binary Numbers",
              "why": "Powers of 2 foundation"
            }
          ],
          "nextTopics": [
            {
              "id": "big_o",
              "label": "Big O Notation",
              "why": "Apply log concepts to complexity"
            },
            {
              "id": "modular_arithmetic",
              "label": "Modular Arithmetic",
              "why": "Deep dive into mod operations"
            }
          ]
        }
      }
    },
    {
      "id": "subset_sum",
      "label": "Subset Sum",
      "type": "algo-dp",
      "description": "Find subsets that sum to target. Classic DP problem.",
      "category": "Dynamic Programming",
      "categoryIcon": "üéØ",
      "difficulty": 5,
      "timeEstimate": "2 hours",
      "content": {
        "definition": {
          "simple": "Does any subset sum to target? Classic NP-complete problem.",
          "technical": "DP: O(n√ósum). Backtracking: O(2^n). Pseudo-polynomial due to dependency on sum value."
        },
        "keyTakeaways": [
          "NP-complete",
          "O(n√ósum) DP",
          "O(2^n) brute force",
          "Reduce many problems to this"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp",
              "label": "Dynamic Programming",
              "why": "Solved with DP"
            }
          ],
          "nextTopics": [
            {
              "id": "dp_subset_sum",
              "label": "Subset Sum DP",
              "why": "Implementation"
            }
          ]
        }
      }
    },
    {
      "id": "xor_tricks",
      "label": "XOR Tricks",
      "type": "algo",
      "description": "Advanced XOR-based algorithms and bit manipulation tricks.",
      "category": "Bit Manipulation",
      "categoryIcon": "‚äï",
      "difficulty": 4,
      "timeEstimate": "1.5 hours",
      "content": {
        "definition": {
          "simple": "XOR properties for solving problems: a^a=0, a^0=a, associative/commutative.",
          "technical": "Find missing number, single number, swap without temp. XOR basis for linear algebra over GF(2)."
        },
        "keyTakeaways": [
          "a XOR a = 0",
          "a XOR 0 = a",
          "Find unique element",
          "Swap: a^=b; b^=a; a^=b"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bits",
              "label": "Bit Manipulation",
              "why": "XOR is bit operation"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "big_o",
      "label": "Big O Notation",
      "type": "concept",
      "description": "Asymptotic analysis of algorithm time and space complexity.",
      "category": "Foundation",
      "categoryIcon": "üìä",
      "difficulty": 2,
      "timeEstimate": "1 hour",
      "content": {
        "definition": {
          "simple": "Big O describes how an algorithm's time or space grows as input size increases. It's the language we use to compare algorithm efficiency.",
          "technical": "Asymptotic upper bound on growth rate. O(f(n)) means the function grows no faster than f(n) for large n, ignoring constants and lower-order terms."
        },
        "howItWorks": {
          "explanation": "We analyze the worst-case number of operations relative to input size n. Drop constants (2n ‚Üí n) and keep only the dominant term (n¬≤ + n ‚Üí n¬≤).",
          "steps": [
            {
              "step": 1,
              "title": "Count Operations",
              "description": "Identify the basic operations that scale with input",
              "why": "These determine the complexity"
            },
            {
              "step": 2,
              "title": "Express as Function of n",
              "description": "Write operation count in terms of input size n",
              "why": "Relates performance to input"
            },
            {
              "step": 3,
              "title": "Drop Constants",
              "description": "O(2n) ‚Üí O(n), O(n/2) ‚Üí O(n)",
              "why": "Constants don't affect growth rate"
            },
            {
              "step": 4,
              "title": "Keep Dominant Term",
              "description": "O(n¬≤ + n + 1) ‚Üí O(n¬≤)",
              "why": "Largest term dominates for big n"
            }
          ]
        },
        "whenToUse": {
          "summary": "Use Big O to compare algorithms, predict scalability, and identify bottlenecks.",
          "patterns": [
            {
              "pattern": "Algorithm Comparison",
              "signal": "Which approach is faster?",
              "example": "O(n¬≤) sort vs O(n log n) sort",
              "withoutIt": "Guess from benchmarks",
              "withIt": "Clear winner for large n"
            },
            {
              "pattern": "Scalability Check",
              "signal": "Will this work for 10^6 inputs?",
              "example": "O(n¬≤) with n=10^6 = 10^12 ops = too slow",
              "withoutIt": "Find out at runtime (crash)",
              "withIt": "Predict before coding"
            }
          ]
        },
        "complexity": {
          "time": {
            "operations": [
              {
                "operation": "O(1)",
                "average": "Constant",
                "worst": "Constant",
                "note": "Array access, hash lookup"
              },
              {
                "operation": "O(log n)",
                "average": "Logarithmic",
                "worst": "Logarithmic",
                "note": "Binary search, balanced tree ops"
              },
              {
                "operation": "O(n)",
                "average": "Linear",
                "worst": "Linear",
                "note": "Single loop through array"
              },
              {
                "operation": "O(n log n)",
                "average": "Linearithmic",
                "worst": "Linearithmic",
                "note": "Efficient sorting (merge, heap)"
              },
              {
                "operation": "O(n¬≤)",
                "average": "Quadratic",
                "worst": "Quadratic",
                "note": "Nested loops, bubble sort"
              },
              {
                "operation": "O(2^n)",
                "average": "Exponential",
                "worst": "Exponential",
                "note": "Subsets, naive recursion"
              }
            ],
            "explanation": "Rule of thumb: 10^8 simple operations per second. For n=10^6: O(n)=‚úì, O(n¬≤)=‚úó"
          },
          "space": {
            "complexity": "Varies",
            "explanation": "Same analysis applies to memory usage"
          }
        },
        "keyTakeaways": [
          "O(1) < O(log n) < O(n) < O(n log n) < O(n¬≤) < O(2^n) < O(n!)",
          "Drop constants: O(3n) = O(n)",
          "Keep dominant term: O(n¬≤ + n) = O(n¬≤)",
          "~10^8 operations/second is typical benchmark",
          "For n=10^6: O(n log n) is fine, O(n¬≤) is too slow",
          "Space complexity uses same notation for memory"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "math",
              "label": "Math Fundamentals",
              "why": "Understand logarithms and exponents"
            }
          ],
          "nextTopics": [
            {
              "id": "array",
              "label": "Arrays",
              "why": "Analyze array operations"
            },
            {
              "id": "sorting",
              "label": "Sorting",
              "why": "Compare O(n¬≤) vs O(n log n) sorts"
            }
          ]
        }
      }
    },
    {
      "id": "memory_model",
      "label": "Memory Model",
      "type": "concept",
      "description": "How data is stored in RAM, stack vs heap, memory allocation.",
      "category": "Foundation",
      "categoryIcon": "üß†",
      "difficulty": 2,
      "timeEstimate": "1 hour",
      "content": {
        "definition": {
          "simple": "How data is organized in computer memory. Understanding this explains WHY certain operations are fast or slow.",
          "technical": "RAM is a sequence of bytes with addresses. Contiguous data (arrays) is cache-friendly; scattered data (linked lists) is not."
        },
        "howItWorks": {
          "explanation": "Memory is like a giant array of bytes. Stack for local variables, heap for dynamic data.",
          "steps": [
            {
              "step": 1,
              "title": "Stack Memory",
              "description": "Fast, automatic allocation for local variables",
              "why": "LIFO order"
            },
            {
              "step": 2,
              "title": "Heap Memory",
              "description": "Dynamic allocation for objects",
              "why": "Flexible size"
            },
            {
              "step": 3,
              "title": "Cache Lines",
              "description": "CPU loads 64 bytes at a time",
              "why": "Adjacent data comes free"
            }
          ]
        },
        "keyTakeaways": [
          "Stack: fast, auto-managed",
          "Heap: flexible, slower",
          "Contiguous = cache-friendly",
          "RAM is 100x slower than L1 cache"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "binary",
              "label": "Binary Numbers",
              "why": "Addresses are numbers"
            }
          ],
          "nextTopics": [
            {
              "id": "array",
              "label": "Arrays",
              "why": "See contiguous memory"
            },
            {
              "id": "linked_list",
              "label": "Linked Lists",
              "why": "Contrast with scattered"
            }
          ]
        }
      }
    },
    {
      "id": "functions",
      "label": "Functions & Closures",
      "type": "primitive",
      "description": "Function calls, call stack, closures and scope.",
      "category": "Foundation",
      "categoryIcon": "∆í",
      "difficulty": 2,
      "timeEstimate": "45 min",
      "content": {
        "definition": {
          "simple": "Functions are reusable code blocks. Closures remember variables from their creation context.",
          "technical": "Each call creates a stack frame. Closures capture outer variables, enabling memoization."
        },
        "howItWorks": {
          "explanation": "Each function call pushes a frame onto the call stack. Return pops it.",
          "steps": [
            {
              "step": 1,
              "title": "Call Stack",
              "description": "LIFO structure for function calls",
              "why": "Matches nesting"
            },
            {
              "step": 2,
              "title": "Closures",
              "description": "Inner function captures outer variables",
              "why": "Enables memoization"
            }
          ]
        },
        "keyTakeaways": [
          "Call stack: LIFO for function calls",
          "Each call has own local vars",
          "Closures capture outer vars",
          "Essential for recursion"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "memory_model",
              "label": "Memory Model",
              "why": "Stack vs heap"
            }
          ],
          "nextTopics": [
            {
              "id": "recursion",
              "label": "Recursion",
              "why": "Apply call stack"
            }
          ]
        }
      }
    },
    {
      "id": "binary_search_variations",
      "label": "Binary Search Variations",
      "type": "algo-pattern",
      "description": "Lower bound, upper bound, rotated arrays, answer space search.",
      "category": "Search Patterns",
      "categoryIcon": "üîç",
      "difficulty": 4,
      "timeEstimate": "2 hours",
      "content": {
        "definition": {
          "simple": "Variations: lower_bound, upper_bound, first/last occurrence, search in rotated array.",
          "technical": "Key: identify which half to search. Condition determines left/right move."
        },
        "keyTakeaways": [
          "lower_bound: first ‚â• target",
          "upper_bound: first > target",
          "Rotated array: identify sorted half",
          "Condition-based movement"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "binary_search",
              "label": "Binary Search",
              "why": "Base technique"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "three_sum",
      "label": "Three Sum Pattern",
      "type": "algo-pattern",
      "description": "Find triplets that sum to target using two pointers.",
      "category": "Two Pointers",
      "categoryIcon": "3Ô∏è‚É£",
      "difficulty": 4,
      "timeEstimate": "1.5 hours",
      "content": {
        "definition": {
          "simple": "Find triplets summing to target. Sort + two pointers after fixing first element.",
          "technical": "O(n¬≤) with sorting + two pointers. Handle duplicates carefully. Generalize to k-sum."
        },
        "keyTakeaways": [
          "Sort + two pointers",
          "O(n¬≤) time",
          "Skip duplicates",
          "Generalizes to k-sum"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "two_pointers",
              "label": "Two Pointers",
              "why": "Core technique"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "linked_list_techniques",
      "label": "Linked List Techniques",
      "type": "algo-pattern",
      "description": "Dummy head, runner technique, in-place reversal patterns.",
      "category": "Linked List",
      "categoryIcon": "üîó",
      "difficulty": 3,
      "timeEstimate": "1.5 hours",
      "content": {
        "definition": {
          "simple": "Common patterns: fast/slow pointers, dummy head, reversal, merge.",
          "technical": "Fast/slow for cycle, middle. Dummy head simplifies edge cases. In-place reversal."
        },
        "keyTakeaways": [
          "Fast/slow pointers",
          "Dummy head node",
          "In-place reversal",
          "Merge two lists"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "linked_list",
              "label": "Linked Lists",
              "why": "Data structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "sliding_window_max",
      "label": "Sliding Window Maximum",
      "type": "algo-pattern",
      "description": "Track max/min in sliding window using monotonic deque.",
      "category": "Sliding Window",
      "categoryIcon": "üìä",
      "difficulty": 5,
      "timeEstimate": "2 hours",
      "content": {
        "definition": {
          "simple": "Maximum in each window of size k. Use monotonic deque for O(n).",
          "technical": "Deque stores indices in decreasing value order. Pop smaller, push new, front is max."
        },
        "keyTakeaways": [
          "Monotonic deque",
          "O(n) total time",
          "Each element pushed/popped once",
          "Classic pattern"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "sliding_window",
              "label": "Sliding Window",
              "why": "Window pattern"
            },
            {
              "id": "monotonic_queue",
              "label": "Monotonic Queue",
              "why": "Data structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "subarray_sum",
      "label": "Subarray Sum Patterns",
      "type": "algo-pattern",
      "description": "Prefix sum + hashmap for subarray sum problems.",
      "category": "Prefix Sum",
      "categoryIcon": "‚àë",
      "difficulty": 4,
      "timeEstimate": "1.5 hours",
      "content": {
        "definition": {
          "simple": "Problems involving subarray sums: prefix sums, hash maps for target sums.",
          "technical": "Prefix sum for range query. Hash map for count/find subarrays with target sum."
        },
        "keyTakeaways": [
          "Prefix sum technique",
          "Hash map for target sum",
          "Kadane for max subarray",
          "Handle negatives carefully"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "prefix_sum",
              "label": "Prefix Sum",
              "why": "Core technique"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "dijkstra",
      "label": "Dijkstra Algorithm",
      "type": "algo-graph",
      "description": "Single-source shortest path with non-negative weights.",
      "category": "Graph Algorithms",
      "categoryIcon": "üõ§Ô∏è",
      "difficulty": 5,
      "timeEstimate": "2.5 hours",
      "content": {
        "definition": {
          "simple": "Find shortest paths from source to all vertices. Greedy, uses priority queue.",
          "technical": "Process vertices in order of distance from source. Relax edges. O(E log V) with min-heap. No negative edges."
        },
        "keyTakeaways": [
          "Non-negative edges only",
          "Min-heap for next closest vertex",
          "O(E log V) with heap",
          "Greedy: closest vertex is finalized"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "heap",
              "label": "Heaps",
              "why": "Uses priority queue"
            },
            {
              "id": "bfs",
              "label": "BFS",
              "why": "Similar structure"
            }
          ],
          "nextTopics": [
            {
              "id": "a_star",
              "label": "A*",
              "why": "Dijkstra with heuristic"
            }
          ]
        }
      }
    },
    {
      "id": "top_k",
      "label": "Top K Elements",
      "type": "algo-pattern",
      "description": "Find k largest/smallest using heap or quickselect.",
      "category": "Heap Patterns",
      "categoryIcon": "üîù",
      "difficulty": 4,
      "timeEstimate": "1.5 hours",
      "content": {
        "definition": {
          "simple": "Find k largest/smallest elements. Heap or quickselect.",
          "technical": "Min-heap of size k: O(n log k). Quickselect: O(n) average. Bucket sort for bounded range."
        },
        "keyTakeaways": [
          "Heap: O(n log k)",
          "Quickselect: O(n) average",
          "Don't sort everything",
          "Min-heap for k largest"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "heap",
              "label": "Heaps",
              "why": "Primary technique"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "median_finder",
      "label": "Find Median",
      "type": "algo-pattern",
      "description": "Maintain median using two heaps (max-heap + min-heap).",
      "category": "Heap Patterns",
      "categoryIcon": "üìä",
      "difficulty": 5,
      "timeEstimate": "2 hours",
      "content": {
        "definition": {
          "simple": "Find median in stream. Two heaps: max-heap for lower, min-heap for upper.",
          "technical": "Balance heaps to differ by at most 1. Median is top of larger or average of tops."
        },
        "keyTakeaways": [
          "Two heaps technique",
          "Max-heap + min-heap",
          "Balance sizes",
          "O(log n) insert, O(1) median"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "heap",
              "label": "Heaps",
              "why": "Uses two heaps"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "bidirectional_bfs",
      "label": "Bidirectional BFS",
      "type": "algo-graph",
      "description": "Search from both ends to reduce search space.",
      "category": "Graph Algorithms",
      "categoryIcon": "‚ÜîÔ∏è",
      "difficulty": 5,
      "timeEstimate": "2 hours",
      "content": {
        "definition": {
          "simple": "BFS from both source and target simultaneously. Meet in the middle.",
          "technical": "Expands from both ends. Meets when frontiers overlap. O(b^(d/2)) vs O(b^d)."
        },
        "keyTakeaways": [
          "Search from both ends",
          "Meet in middle",
          "Exponentially faster",
          "Works when target known"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "bfs",
              "label": "BFS",
              "why": "Base technique"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "shortest_path_dag",
      "label": "Shortest Path in DAG",
      "type": "algo-graph",
      "description": "Topological sort + relaxation for DAG shortest paths.",
      "category": "Graph Algorithms",
      "categoryIcon": "üìâ",
      "difficulty": 4,
      "timeEstimate": "1.5 hours",
      "content": {
        "definition": {
          "simple": "Shortest paths in DAG using topological order. O(V+E).",
          "technical": "Topological sort. Relax edges in order. Works with negative weights (no cycles)."
        },
        "keyTakeaways": [
          "O(V+E) for DAG",
          "Topo sort first",
          "Handles negative edges",
          "Faster than Dijkstra for DAGs"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "topological_sort",
              "label": "Topo Sort",
              "why": "Required ordering"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "critical_path",
      "label": "Critical Path Method",
      "type": "algo-graph",
      "description": "Longest path in DAG for project scheduling.",
      "category": "Graph Algorithms",
      "categoryIcon": "‚è±Ô∏è",
      "difficulty": 5,
      "timeEstimate": "2 hours",
      "content": {
        "definition": {
          "simple": "Longest path in DAG of tasks. Determines minimum project duration.",
          "technical": "Topo sort + longest path DP. No slack on critical tasks. Used in project management."
        },
        "keyTakeaways": [
          "Longest path in DAG",
          "Minimum project time",
          "Critical tasks: zero slack",
          "PERT/CPM methods"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "shortest_path_dag",
              "label": "DAG Shortest Path",
              "why": "Similar technique"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "constraint_satisfaction",
      "label": "Constraint Satisfaction",
      "type": "algo",
      "description": "CSP problems with backtracking and constraint propagation.",
      "category": "Advanced Algorithms",
      "categoryIcon": "üß©",
      "difficulty": 6,
      "timeEstimate": "3 hours",
      "content": {
        "definition": {
          "simple": "Find assignment to variables satisfying all constraints. Backtracking + pruning.",
          "technical": "Arc consistency, forward checking. Heuristics: MRV, LCV. Used in scheduling, Sudoku."
        },
        "keyTakeaways": [
          "Variables, domains, constraints",
          "Backtracking search",
          "Arc consistency pruning",
          "MRV/LCV heuristics"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "backtracking",
              "label": "Backtracking",
              "why": "Base technique"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "branch_bound",
      "label": "Branch and Bound",
      "type": "algo",
      "description": "Optimization technique with pruning for exponential problems.",
      "category": "Advanced Algorithms",
      "categoryIcon": "‚úÇÔ∏è",
      "difficulty": 6,
      "timeEstimate": "3 hours",
      "content": {
        "definition": {
          "simple": "Explore solution tree, prune branches that can't beat best known solution.",
          "technical": "Compute bound for subtree. If bound ‚â• best, prune. Often with relaxation (LP relaxation)."
        },
        "keyTakeaways": [
          "Prune by bounding",
          "Best-first or DFS",
          "LP relaxation for bound",
          "Used in TSP, knapsack"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "backtracking",
              "label": "Backtracking",
              "why": "Tree search"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "dp_patterns",
      "label": "DP Patterns Overview",
      "type": "algo-dp",
      "description": "Common DP patterns: 1D, 2D, interval, bitmask, trees.",
      "category": "Dynamic Programming",
      "categoryIcon": "üìã",
      "difficulty": 5,
      "timeEstimate": "2 hours",
      "content": {
        "definition": {
          "simple": "Common patterns in DP problems: subsequence, knapsack, interval, digit, bitmask, tree.",
          "technical": "Recognizing patterns helps identify state and transitions. Each pattern has characteristic recurrence."
        },
        "keyTakeaways": [
          "Pattern recognition is key",
          "State definition varies by pattern",
          "Transitions follow structure",
          "Knapsack, LCS, interval, digit, tree DP"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp",
              "label": "Dynamic Programming",
              "why": "Core DP understanding"
            }
          ],
          "nextTopics": [
            {
              "id": "dp_knapsack_01",
              "label": "0/1 Knapsack",
              "why": "Classic pattern"
            }
          ]
        }
      }
    },
    {
      "id": "memoization",
      "label": "Memoization",
      "type": "concept",
      "description": "Top-down DP using recursion with caching.",
      "category": "Dynamic Programming",
      "categoryIcon": "üíæ",
      "difficulty": 3,
      "timeEstimate": "1 hour",
      "content": {
        "definition": {
          "simple": "Cache results of expensive function calls. Return cached result for same inputs.",
          "technical": "Top-down DP. Store results in map/array. Trade O(n) space for avoiding recomputation."
        },
        "keyTakeaways": [
          "Top-down approach",
          "Cache function results",
          "Avoids recomputation",
          "Natural with recursion"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "recursion",
              "label": "Recursion",
              "why": "Applied to recursive calls"
            }
          ],
          "nextTopics": [
            {
              "id": "tabulation",
              "label": "Tabulation",
              "why": "Bottom-up alternative"
            }
          ]
        }
      }
    },
    {
      "id": "tabulation",
      "label": "Tabulation",
      "type": "concept",
      "description": "Bottom-up DP using iterative table filling.",
      "category": "Dynamic Programming",
      "categoryIcon": "üìä",
      "difficulty": 3,
      "timeEstimate": "1 hour",
      "content": {
        "definition": {
          "simple": "Build solution bottom-up by filling a table from smallest subproblems to largest.",
          "technical": "Bottom-up DP. Iteratively fill table. Often better cache performance than memoization."
        },
        "keyTakeaways": [
          "Bottom-up approach",
          "Fill table iteratively",
          "No recursion overhead",
          "Better cache performance"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "memoization",
              "label": "Memoization",
              "why": "Understand DP first"
            }
          ],
          "nextTopics": [
            {
              "id": "dp_patterns",
              "label": "DP Patterns",
              "why": "Apply to problems"
            }
          ]
        }
      }
    },
    {
      "id": "radix_tree",
      "label": "Radix Tree",
      "type": "ds-specialized",
      "description": "Compressed trie for space-efficient string storage.",
      "category": "Trees",
      "categoryIcon": "üå≤",
      "difficulty": 5,
      "timeEstimate": "2 hours",
      "content": {
        "definition": {
          "simple": "Compressed trie: merge single-child nodes. Space efficient.",
          "technical": "Also called Patricia trie. Edge labels are strings, not single chars. O(m) lookup for length m."
        },
        "keyTakeaways": [
          "Compressed trie",
          "Merge single-child paths",
          "Space efficient",
          "Used in IP routing"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "trie",
              "label": "Trie",
              "why": "Base structure"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "percolation",
      "label": "Percolation",
      "type": "algo",
      "description": "Union-Find application for connectivity problems.",
      "category": "Union Find",
      "categoryIcon": "üíß",
      "difficulty": 4,
      "timeEstimate": "1.5 hours",
      "content": {
        "definition": {
          "simple": "Model connectivity in grid. Sites open/blocked. Does top connect to bottom?",
          "technical": "Union-Find to track components. Threshold ~0.593 for infinite grid. Monte Carlo simulation."
        },
        "keyTakeaways": [
          "Grid connectivity model",
          "Union-Find based",
          "Phase transition",
          "Monte Carlo for threshold"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "union_find",
              "label": "Union-Find",
              "why": "Connectivity"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "histogram",
      "label": "Histogram Problems",
      "type": "algo-pattern",
      "description": "Largest rectangle, trapping water using stacks.",
      "category": "Stack Patterns",
      "categoryIcon": "üìä",
      "difficulty": 5,
      "timeEstimate": "2 hours",
      "content": {
        "definition": {
          "simple": "Largest rectangle in histogram. Monotonic stack O(n).",
          "technical": "Stack of indices in increasing height. Pop when smaller found, compute area. Each bar pushed/popped once."
        },
        "keyTakeaways": [
          "Monotonic stack solution",
          "O(n) time",
          "Largest rectangle",
          "Extend to maximal rectangle in matrix"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "stack",
              "label": "Stack",
              "why": "Monotonic stack"
            }
          ],
          "nextTopics": []
        }
      }
    },
    {
      "id": "stock_problems",
      "label": "Stock Buy/Sell Patterns",
      "type": "algo-dp",
      "description": "DP patterns for stock trading with various constraints.",
      "category": "Dynamic Programming",
      "categoryIcon": "üìà",
      "difficulty": 5,
      "timeEstimate": "2.5 hours",
      "content": {
        "definition": {
          "simple": "Buy/sell stock problems: one transaction, multiple, with cooldown, with fee.",
          "technical": "State machine DP. States: holding, not holding, cooldown. Transitions on buy/sell."
        },
        "keyTakeaways": [
          "State machine DP",
          "Holding/not holding states",
          "Variants: k transactions, cooldown",
          "O(n) for most variants"
        ],
        "learningPath": {
          "prerequisites": [
            {
              "id": "dp",
              "label": "DP",
              "why": "State machine DP"
            }
          ],
          "nextTopics": []
        }
      }
    }
  ],
  "edges": [
    {
      "source": "memory",
      "target": "bits",
      "relation": "composed_of"
    },
    {
      "source": "memory",
      "target": "array",
      "relation": "allocates_contiguous"
    },
    {
      "source": "memory",
      "target": "pointers",
      "relation": "addresses"
    },
    {
      "source": "pointers",
      "target": "ll",
      "relation": "enables_linking"
    },
    {
      "source": "array",
      "target": "string",
      "relation": "specialization"
    },
    {
      "source": "array",
      "target": "stack",
      "relation": "implements"
    },
    {
      "source": "ll",
      "target": "stack",
      "relation": "implements"
    },
    {
      "source": "array",
      "target": "queue",
      "relation": "implements"
    },
    {
      "source": "ll",
      "target": "queue",
      "relation": "implements"
    },
    {
      "source": "array",
      "target": "hashing",
      "relation": "provides_indices"
    },
    {
      "source": "hashing",
      "target": "hashmap",
      "relation": "enables"
    },
    {
      "source": "ll",
      "target": "hashmap",
      "relation": "handles_collisions"
    },
    {
      "source": "hashing",
      "target": "bloom",
      "relation": "enables"
    },
    {
      "source": "bits",
      "target": "bloom",
      "relation": "storage_mechanism"
    },
    {
      "source": "array",
      "target": "two_pointers",
      "relation": "pattern_target"
    },
    {
      "source": "ll",
      "target": "two_pointers",
      "relation": "pattern_target"
    },
    {
      "source": "array",
      "target": "sliding_window",
      "relation": "pattern_target"
    },
    {
      "source": "string",
      "target": "sliding_window",
      "relation": "pattern_target"
    },
    {
      "source": "array",
      "target": "sorting",
      "relation": "common_target"
    },
    {
      "source": "array",
      "target": "binary_search",
      "relation": "requires_sorted"
    },
    {
      "source": "sorting",
      "target": "binary_search",
      "relation": "enables"
    },
    {
      "source": "ll",
      "target": "tree",
      "relation": "conceptual_basis"
    },
    {
      "source": "tree",
      "target": "bst",
      "relation": "specialization"
    },
    {
      "source": "bst",
      "target": "avl",
      "relation": "optimization"
    },
    {
      "source": "tree",
      "target": "heap",
      "relation": "specialization"
    },
    {
      "source": "array",
      "target": "heap",
      "relation": "efficient_implementation"
    },
    {
      "source": "tree",
      "target": "graph",
      "relation": "is_subset_of"
    },
    {
      "source": "hashmap",
      "target": "graph",
      "relation": "represents_adjacency"
    },
    {
      "source": "stack",
      "target": "recursion",
      "relation": "underlying_mechanism"
    },
    {
      "source": "recursion",
      "target": "tree",
      "relation": "natural_traversal"
    },
    {
      "source": "recursion",
      "target": "dfs",
      "relation": "implements"
    },
    {
      "source": "stack",
      "target": "dfs",
      "relation": "iterative_implementation"
    },
    {
      "source": "queue",
      "target": "bfs",
      "relation": "implements"
    },
    {
      "source": "recursion",
      "target": "backtracking",
      "relation": "basis_of"
    },
    {
      "source": "recursion",
      "target": "dp",
      "relation": "basis_of"
    },
    {
      "source": "hashmap",
      "target": "dp",
      "relation": "memoization_cache"
    },
    {
      "source": "array",
      "target": "dp",
      "relation": "tabulation_cache"
    },
    {
      "source": "graph",
      "target": "bfs",
      "relation": "traversed_by"
    },
    {
      "source": "graph",
      "target": "dfs",
      "relation": "traversed_by"
    },
    {
      "source": "graph",
      "target": "union_find",
      "relation": "cycle_detection"
    },
    {
      "source": "graph",
      "target": "shortest_path",
      "relation": "problem_domain"
    },
    {
      "source": "bfs",
      "target": "shortest_path",
      "relation": "unweighted_solution"
    },
    {
      "source": "heap",
      "target": "shortest_path",
      "relation": "weighted_solution_dijkstra"
    },
    {
      "source": "graph",
      "target": "topo_sort",
      "relation": "dependency_resolution"
    },
    {
      "source": "dfs",
      "target": "topo_sort",
      "relation": "implementation"
    },
    {
      "source": "tree",
      "target": "trie",
      "relation": "specialization"
    },
    {
      "source": "heap",
      "target": "greedy",
      "relation": "enables_efficient_choice"
    },
    {
      "source": "array",
      "target": "vector_db",
      "relation": "high_dimensional_storage"
    },
    {
      "source": "tree",
      "target": "vector_db",
      "relation": "indexing_mechanism_ann"
    },
    {
      "source": "array",
      "target": "dynamic_array",
      "relation": "specialization"
    },
    {
      "source": "dynamic_array",
      "target": "amortized_analysis",
      "relation": "analyzed_by"
    },
    {
      "source": "hashmap",
      "target": "set",
      "relation": "implementation_option"
    },
    {
      "source": "bst",
      "target": "set",
      "relation": "implementation_option"
    },
    {
      "source": "deque",
      "target": "monotonic_queue",
      "relation": "underlying_container"
    },
    {
      "source": "queue",
      "target": "deque",
      "relation": "generalization"
    },
    {
      "source": "pointers",
      "target": "dll",
      "relation": "enables_linking"
    },
    {
      "source": "hashmap",
      "target": "lru_cache",
      "relation": "composes"
    },
    {
      "source": "dll",
      "target": "lru_cache",
      "relation": "composes"
    },
    {
      "source": "array",
      "target": "prefix_sum",
      "relation": "pattern_target"
    },
    {
      "source": "prefix_sum",
      "target": "sliding_window",
      "relation": "optimization_tool"
    },
    {
      "source": "array",
      "target": "difference_array",
      "relation": "pattern_target"
    },
    {
      "source": "stack",
      "target": "monotonic_stack",
      "relation": "specialization"
    },
    {
      "source": "deque",
      "target": "monotonic_queue",
      "relation": "specialization"
    },
    {
      "source": "monotonic_queue",
      "target": "sliding_window",
      "relation": "classic_solution"
    },
    {
      "source": "recursion",
      "target": "divide_conquer",
      "relation": "basis_of"
    },
    {
      "source": "divide_conquer",
      "target": "sorting",
      "relation": "basis_of"
    },
    {
      "source": "bits",
      "target": "bitmasking",
      "relation": "enables"
    },
    {
      "source": "bitmasking",
      "target": "bitmask_dp",
      "relation": "enables"
    },
    {
      "source": "dp",
      "target": "bitmask_dp",
      "relation": "specialization"
    },
    {
      "source": "array",
      "target": "fenwick",
      "relation": "base_storage"
    },
    {
      "source": "prefix_sum",
      "target": "fenwick",
      "relation": "generalization"
    },
    {
      "source": "array",
      "target": "segment_tree",
      "relation": "base_storage"
    },
    {
      "source": "divide_conquer",
      "target": "segment_tree",
      "relation": "conceptual_basis"
    },
    {
      "source": "ll",
      "target": "skip_list",
      "relation": "conceptual_basis"
    },
    {
      "source": "tree",
      "target": "btree",
      "relation": "specialization"
    },
    {
      "source": "graph",
      "target": "mst",
      "relation": "problem_domain"
    },
    {
      "source": "mst",
      "target": "kruskal",
      "relation": "solved_by"
    },
    {
      "source": "mst",
      "target": "prim",
      "relation": "solved_by"
    },
    {
      "source": "sorting",
      "target": "kruskal",
      "relation": "uses"
    },
    {
      "source": "union_find",
      "target": "kruskal",
      "relation": "uses"
    },
    {
      "source": "heap",
      "target": "prim",
      "relation": "uses"
    },
    {
      "source": "graph",
      "target": "scc",
      "relation": "problem_domain"
    },
    {
      "source": "scc",
      "target": "kosaraju",
      "relation": "solved_by"
    },
    {
      "source": "scc",
      "target": "tarjan",
      "relation": "solved_by"
    },
    {
      "source": "dfs",
      "target": "kosaraju",
      "relation": "uses"
    },
    {
      "source": "dfs",
      "target": "tarjan",
      "relation": "uses"
    },
    {
      "source": "graph",
      "target": "bellman_ford",
      "relation": "shortest_paths"
    },
    {
      "source": "graph",
      "target": "floyd_warshall",
      "relation": "all_pairs_shortest_paths"
    },
    {
      "source": "dp",
      "target": "floyd_warshall",
      "relation": "uses"
    },
    {
      "source": "graph",
      "target": "max_flow",
      "relation": "problem_domain"
    },
    {
      "source": "max_flow",
      "target": "edmonds_karp",
      "relation": "solved_by"
    },
    {
      "source": "max_flow",
      "target": "dinic",
      "relation": "solved_by"
    },
    {
      "source": "bfs",
      "target": "edmonds_karp",
      "relation": "uses"
    },
    {
      "source": "bfs",
      "target": "dinic",
      "relation": "uses"
    },
    {
      "source": "dfs",
      "target": "dinic",
      "relation": "uses"
    },
    {
      "source": "graph",
      "target": "bipartite_matching",
      "relation": "problem_domain"
    },
    {
      "source": "bipartite_matching",
      "target": "hopcroft_karp",
      "relation": "solved_by"
    },
    {
      "source": "bfs",
      "target": "hopcroft_karp",
      "relation": "uses"
    },
    {
      "source": "dfs",
      "target": "hopcroft_karp",
      "relation": "uses"
    },
    {
      "source": "string",
      "target": "kmp",
      "relation": "searched_by"
    },
    {
      "source": "string",
      "target": "rabin_karp",
      "relation": "searched_by"
    },
    {
      "source": "string",
      "target": "z_algorithm",
      "relation": "searched_by"
    },
    {
      "source": "hashing",
      "target": "rabin_karp",
      "relation": "uses"
    },
    {
      "source": "string",
      "target": "suffix_array",
      "relation": "indexed_by"
    },
    {
      "source": "string",
      "target": "suffix_tree",
      "relation": "indexed_by"
    },
    {
      "source": "string",
      "target": "suffix_automaton",
      "relation": "indexed_by"
    },
    {
      "source": "trie",
      "target": "suffix_tree",
      "relation": "conceptual_basis"
    },
    {
      "source": "hashing",
      "target": "count_min_sketch",
      "relation": "enables"
    },
    {
      "source": "bits",
      "target": "count_min_sketch",
      "relation": "storage_mechanism"
    },
    {
      "source": "hashing",
      "target": "hyperloglog",
      "relation": "enables"
    },
    {
      "source": "bits",
      "target": "hyperloglog",
      "relation": "storage_mechanism"
    },
    {
      "source": "vector_db",
      "target": "ann",
      "relation": "supports"
    },
    {
      "source": "ann",
      "target": "hnsw",
      "relation": "indexed_by"
    },
    {
      "source": "ann",
      "target": "ivf",
      "relation": "indexed_by"
    },
    {
      "source": "ann",
      "target": "pq",
      "relation": "accelerated_by"
    },
    {
      "source": "sorting",
      "target": "merge_sort",
      "relation": "implementation"
    },
    {
      "source": "sorting",
      "target": "quick_sort",
      "relation": "implementation"
    },
    {
      "source": "sorting",
      "target": "heap_sort",
      "relation": "implementation"
    },
    {
      "source": "sorting",
      "target": "insertion_sort",
      "relation": "implementation"
    },
    {
      "source": "sorting",
      "target": "selection_sort",
      "relation": "implementation"
    },
    {
      "source": "sorting",
      "target": "bubble_sort",
      "relation": "implementation"
    },
    {
      "source": "sorting",
      "target": "counting_sort",
      "relation": "implementation"
    },
    {
      "source": "sorting",
      "target": "radix_sort",
      "relation": "implementation"
    },
    {
      "source": "sorting",
      "target": "bucket_sort",
      "relation": "implementation"
    },
    {
      "source": "sorting",
      "target": "tim_sort",
      "relation": "implementation"
    },
    {
      "source": "divide_conquer",
      "target": "merge_sort",
      "relation": "basis_of"
    },
    {
      "source": "divide_conquer",
      "target": "quick_sort",
      "relation": "basis_of"
    },
    {
      "source": "heap",
      "target": "heap_sort",
      "relation": "uses"
    },
    {
      "source": "comparison",
      "target": "merge_sort",
      "relation": "basis_of"
    },
    {
      "source": "comparison",
      "target": "quick_sort",
      "relation": "basis_of"
    },
    {
      "source": "comparison",
      "target": "heap_sort",
      "relation": "basis_of"
    },
    {
      "source": "comparison",
      "target": "insertion_sort",
      "relation": "basis_of"
    },
    {
      "source": "bits",
      "target": "counting_sort",
      "relation": "key_representation"
    },
    {
      "source": "counting_sort",
      "target": "radix_sort",
      "relation": "subroutine"
    },
    {
      "source": "merge_sort",
      "target": "tim_sort",
      "relation": "combines"
    },
    {
      "source": "insertion_sort",
      "target": "tim_sort",
      "relation": "combines"
    },
    {
      "source": "array",
      "target": "linear_search",
      "relation": "searched_by"
    },
    {
      "source": "binary_search",
      "target": "ternary_search",
      "relation": "related"
    },
    {
      "source": "binary_search",
      "target": "interpolation_search",
      "relation": "variant"
    },
    {
      "source": "binary_search",
      "target": "exponential_search",
      "relation": "variant"
    },
    {
      "source": "tree",
      "target": "nary_tree",
      "relation": "generalization"
    },
    {
      "source": "avl",
      "target": "red_black_tree",
      "relation": "alternative"
    },
    {
      "source": "bst",
      "target": "splay_tree",
      "relation": "specialization"
    },
    {
      "source": "bst",
      "target": "treap",
      "relation": "randomized_variant"
    },
    {
      "source": "segment_tree",
      "target": "interval_tree",
      "relation": "related"
    },
    {
      "source": "fenwick",
      "target": "fenwick_2d",
      "relation": "extension"
    },
    {
      "source": "segment_tree",
      "target": "segment_tree_lazy",
      "relation": "optimization"
    },
    {
      "source": "tree",
      "target": "persistent_ds",
      "relation": "versioned_variant"
    },
    {
      "source": "ll",
      "target": "immutable_ds",
      "relation": "conceptual_basis"
    },
    {
      "source": "tree",
      "target": "rope",
      "relation": "specialization"
    },
    {
      "source": "string",
      "target": "rope",
      "relation": "efficient_for"
    },
    {
      "source": "array",
      "target": "circular_buffer",
      "relation": "specialization"
    },
    {
      "source": "queue",
      "target": "circular_buffer",
      "relation": "implements"
    },
    {
      "source": "dfs",
      "target": "articulation_points",
      "relation": "finds"
    },
    {
      "source": "dfs",
      "target": "bridges",
      "relation": "finds"
    },
    {
      "source": "tarjan",
      "target": "articulation_points",
      "relation": "uses"
    },
    {
      "source": "tarjan",
      "target": "bridges",
      "relation": "uses"
    },
    {
      "source": "graph",
      "target": "euler_path",
      "relation": "problem_domain"
    },
    {
      "source": "graph",
      "target": "hamiltonian_path",
      "relation": "problem_domain"
    },
    {
      "source": "backtracking",
      "target": "hamiltonian_path",
      "relation": "solves"
    },
    {
      "source": "dfs",
      "target": "cycle_detection",
      "relation": "implements"
    },
    {
      "source": "union_find",
      "target": "cycle_detection",
      "relation": "implements"
    },
    {
      "source": "bfs",
      "target": "bipartite_check",
      "relation": "implements"
    },
    {
      "source": "graph",
      "target": "graph_coloring",
      "relation": "problem_domain"
    },
    {
      "source": "backtracking",
      "target": "graph_coloring",
      "relation": "solves"
    },
    {
      "source": "dp",
      "target": "dp_lcs",
      "relation": "classic_problem"
    },
    {
      "source": "dp",
      "target": "dp_lis",
      "relation": "classic_problem"
    },
    {
      "source": "dp",
      "target": "dp_knapsack_01",
      "relation": "classic_problem"
    },
    {
      "source": "dp",
      "target": "dp_knapsack_unbounded",
      "relation": "classic_problem"
    },
    {
      "source": "dp",
      "target": "dp_edit_distance",
      "relation": "classic_problem"
    },
    {
      "source": "dp",
      "target": "dp_matrix_chain",
      "relation": "classic_problem"
    },
    {
      "source": "dp",
      "target": "dp_coin_change",
      "relation": "classic_problem"
    },
    {
      "source": "dp",
      "target": "dp_rod_cutting",
      "relation": "classic_problem"
    },
    {
      "source": "dp",
      "target": "dp_palindrome",
      "relation": "classic_problem"
    },
    {
      "source": "dp",
      "target": "dp_subset_sum",
      "relation": "classic_problem"
    },
    {
      "source": "dp",
      "target": "dp_partition",
      "relation": "classic_problem"
    },
    {
      "source": "dp",
      "target": "dp_catalan",
      "relation": "classic_problem"
    },
    {
      "source": "dp",
      "target": "dp_digit",
      "relation": "specialization"
    },
    {
      "source": "dp",
      "target": "dp_on_trees",
      "relation": "specialization"
    },
    {
      "source": "dp",
      "target": "dp_interval",
      "relation": "specialization"
    },
    {
      "source": "string",
      "target": "dp_lcs",
      "relation": "problem_domain"
    },
    {
      "source": "string",
      "target": "dp_edit_distance",
      "relation": "problem_domain"
    },
    {
      "source": "tree",
      "target": "dp_on_trees",
      "relation": "problem_domain"
    },
    {
      "source": "binary_search",
      "target": "dp_lis",
      "relation": "optimization"
    },
    {
      "source": "dp_knapsack_01",
      "target": "dp_subset_sum",
      "relation": "related"
    },
    {
      "source": "dp_subset_sum",
      "target": "dp_partition",
      "relation": "related"
    },
    {
      "source": "dp_matrix_chain",
      "target": "dp_interval",
      "relation": "example_of"
    },
    {
      "source": "bits",
      "target": "gcd_lcm",
      "relation": "number_operations"
    },
    {
      "source": "gcd_lcm",
      "target": "euclidean",
      "relation": "computed_by"
    },
    {
      "source": "euclidean",
      "target": "extended_euclidean",
      "relation": "extension"
    },
    {
      "source": "array",
      "target": "sieve",
      "relation": "storage"
    },
    {
      "source": "sieve",
      "target": "prime_factorization",
      "relation": "enables"
    },
    {
      "source": "bits",
      "target": "modular_arithmetic",
      "relation": "foundation"
    },
    {
      "source": "extended_euclidean",
      "target": "mod_inverse",
      "relation": "computes"
    },
    {
      "source": "fermats_little",
      "target": "mod_inverse",
      "relation": "alternative"
    },
    {
      "source": "divide_conquer",
      "target": "fast_exponentiation",
      "relation": "basis_of"
    },
    {
      "source": "modular_arithmetic",
      "target": "fast_exponentiation",
      "relation": "used_with"
    },
    {
      "source": "modular_arithmetic",
      "target": "chinese_remainder",
      "relation": "application"
    },
    {
      "source": "dp",
      "target": "combinatorics",
      "relation": "computes"
    },
    {
      "source": "fast_exponentiation",
      "target": "matrix_exponentiation",
      "relation": "generalizes"
    },
    {
      "source": "dp",
      "target": "matrix_exponentiation",
      "relation": "optimizes_linear_recurrence"
    },
    {
      "source": "hashing",
      "target": "probability_theory",
      "relation": "analysis_tool"
    },
    {
      "source": "skip_list",
      "target": "probability_theory",
      "relation": "analysis_tool"
    },
    {
      "source": "divide_conquer",
      "target": "convex_hull",
      "relation": "approach"
    },
    {
      "source": "sorting",
      "target": "convex_hull",
      "relation": "preprocessing"
    },
    {
      "source": "array",
      "target": "line_intersection",
      "relation": "points_storage"
    },
    {
      "source": "divide_conquer",
      "target": "closest_pair",
      "relation": "approach"
    },
    {
      "source": "sorting",
      "target": "sweep_line",
      "relation": "event_ordering"
    },
    {
      "source": "tree",
      "target": "sweep_line",
      "relation": "status_structure"
    },
    {
      "source": "array",
      "target": "point_in_polygon",
      "relation": "vertices_storage"
    },
    {
      "source": "array",
      "target": "polygon_area",
      "relation": "vertices_storage"
    },
    {
      "source": "recursion",
      "target": "minimax",
      "relation": "basis_of"
    },
    {
      "source": "tree",
      "target": "game_tree",
      "relation": "specialization"
    },
    {
      "source": "game_tree",
      "target": "minimax",
      "relation": "traversed_by"
    },
    {
      "source": "minimax",
      "target": "alpha_beta",
      "relation": "optimized_by"
    },
    {
      "source": "dp",
      "target": "nim",
      "relation": "analysis_tool"
    },
    {
      "source": "bitmasking",
      "target": "nim",
      "relation": "xor_operation"
    },
    {
      "source": "memory",
      "target": "comparison",
      "relation": "primitive_operation"
    },
    {
      "source": "modular_arithmetic",
      "target": "fermats_little",
      "relation": "theorem"
    },
    {
      "source": "ll",
      "target": "circular_ll",
      "relation": "variant"
    },
    {
      "source": "array",
      "target": "sparse_matrix",
      "relation": "efficient_for"
    },
    {
      "source": "hashmap",
      "target": "sparse_matrix",
      "relation": "implementation"
    },
    {
      "source": "sorting",
      "target": "shell_sort",
      "relation": "implementation"
    },
    {
      "source": "insertion_sort",
      "target": "shell_sort",
      "relation": "generalization"
    },
    {
      "source": "shortest_path",
      "target": "a_star",
      "relation": "heuristic_variant"
    },
    {
      "source": "heap",
      "target": "a_star",
      "relation": "uses"
    },
    {
      "source": "bfs",
      "target": "a_star",
      "relation": "conceptual_basis"
    },
    {
      "source": "graph",
      "target": "johnson",
      "relation": "all_pairs_shortest_paths"
    },
    {
      "source": "bellman_ford",
      "target": "johnson",
      "relation": "uses"
    },
    {
      "source": "shortest_path",
      "target": "johnson",
      "relation": "implementation"
    },
    {
      "source": "bipartite_matching",
      "target": "hungarian",
      "relation": "solved_by"
    },
    {
      "source": "graph",
      "target": "hungarian",
      "relation": "assignment_problem"
    },
    {
      "source": "trie",
      "target": "aho_corasick",
      "relation": "basis_of"
    },
    {
      "source": "string",
      "target": "aho_corasick",
      "relation": "searched_by"
    },
    {
      "source": "bfs",
      "target": "aho_corasick",
      "relation": "failure_link_construction"
    },
    {
      "source": "string",
      "target": "manacher",
      "relation": "palindrome_search"
    },
    {
      "source": "dp_palindrome",
      "target": "manacher",
      "relation": "related"
    },
    {
      "source": "string",
      "target": "boyer_moore",
      "relation": "searched_by"
    },
    {
      "source": "kmp",
      "target": "boyer_moore",
      "relation": "alternative"
    },
    {
      "source": "tree",
      "target": "kd_tree",
      "relation": "specialization"
    },
    {
      "source": "divide_conquer",
      "target": "kd_tree",
      "relation": "construction"
    },
    {
      "source": "ann",
      "target": "kd_tree",
      "relation": "indexed_by"
    },
    {
      "source": "tree",
      "target": "r_tree",
      "relation": "specialization"
    },
    {
      "source": "btree",
      "target": "r_tree",
      "relation": "conceptual_basis"
    },
    {
      "source": "tree",
      "target": "merkle_tree",
      "relation": "specialization"
    },
    {
      "source": "hashing",
      "target": "merkle_tree",
      "relation": "uses"
    },
    {
      "source": "tree",
      "target": "quad_tree",
      "relation": "specialization"
    },
    {
      "source": "kd_tree",
      "target": "quad_tree",
      "relation": "related"
    },
    {
      "source": "array",
      "target": "sqrt_decomposition",
      "relation": "pattern_target"
    },
    {
      "source": "sqrt_decomposition",
      "target": "mo_algorithm",
      "relation": "basis_of"
    },
    {
      "source": "sorting",
      "target": "mo_algorithm",
      "relation": "query_ordering"
    },
    {
      "source": "tree",
      "target": "centroid_decomposition",
      "relation": "decomposed_by"
    },
    {
      "source": "divide_conquer",
      "target": "centroid_decomposition",
      "relation": "conceptual_basis"
    },
    {
      "source": "tree",
      "target": "heavy_light",
      "relation": "decomposed_by"
    },
    {
      "source": "segment_tree",
      "target": "heavy_light",
      "relation": "used_with"
    },
    {
      "source": "divide_conquer",
      "target": "fft",
      "relation": "basis_of"
    },
    {
      "source": "array",
      "target": "fft",
      "relation": "coefficients_storage"
    },
    {
      "source": "fft",
      "target": "ntt",
      "relation": "modular_variant"
    },
    {
      "source": "modular_arithmetic",
      "target": "ntt",
      "relation": "uses"
    },
    {
      "source": "combinatorics",
      "target": "lucas",
      "relation": "computes_ncr"
    },
    {
      "source": "modular_arithmetic",
      "target": "lucas",
      "relation": "uses"
    },
    {
      "source": "fermats_little",
      "target": "lucas",
      "relation": "related"
    },
    {
      "source": "prime_factorization",
      "target": "mobius",
      "relation": "uses"
    },
    {
      "source": "sieve",
      "target": "mobius",
      "relation": "precomputes"
    },
    {
      "source": "gcd_lcm",
      "target": "pollard_rho",
      "relation": "uses"
    },
    {
      "source": "prime_factorization",
      "target": "pollard_rho",
      "relation": "solved_by"
    },
    {
      "source": "probability_theory",
      "target": "pollard_rho",
      "relation": "randomized"
    },
    {
      "source": "fast_exponentiation",
      "target": "miller_rabin",
      "relation": "uses"
    },
    {
      "source": "sieve",
      "target": "miller_rabin",
      "relation": "alternative"
    },
    {
      "source": "probability_theory",
      "target": "miller_rabin",
      "relation": "probabilistic"
    },
    {
      "source": "bitmask_dp",
      "target": "dp_sos",
      "relation": "specialization"
    },
    {
      "source": "dp",
      "target": "dp_sos",
      "relation": "technique"
    },
    {
      "source": "bitmask_dp",
      "target": "dp_broken_profile",
      "relation": "specialization"
    },
    {
      "source": "dp",
      "target": "dp_broken_profile",
      "relation": "technique"
    },
    {
      "source": "dp",
      "target": "dp_convex_hull_trick",
      "relation": "optimization"
    },
    {
      "source": "convex_hull",
      "target": "dp_convex_hull_trick",
      "relation": "uses"
    },
    {
      "source": "dp",
      "target": "dp_divide_conquer",
      "relation": "optimization"
    },
    {
      "source": "divide_conquer",
      "target": "dp_divide_conquer",
      "relation": "combines"
    },
    {
      "source": "tree",
      "target": "lca",
      "relation": "problem_domain"
    },
    {
      "source": "binary_lifting",
      "target": "lca",
      "relation": "solves"
    },
    {
      "source": "euler_tour",
      "target": "lca",
      "relation": "reduces_to_rmq"
    },
    {
      "source": "array",
      "target": "rmq",
      "relation": "problem_domain"
    },
    {
      "source": "sparse_table",
      "target": "rmq",
      "relation": "solves"
    },
    {
      "source": "segment_tree",
      "target": "rmq",
      "relation": "solves"
    },
    {
      "source": "array",
      "target": "sparse_table",
      "relation": "base_storage"
    },
    {
      "source": "dp",
      "target": "sparse_table",
      "relation": "preprocessing"
    },
    {
      "source": "tree",
      "target": "binary_lifting",
      "relation": "traversed_by"
    },
    {
      "source": "dp",
      "target": "binary_lifting",
      "relation": "uses"
    },
    {
      "source": "tree",
      "target": "euler_tour",
      "relation": "flattened_by"
    },
    {
      "source": "dfs",
      "target": "euler_tour",
      "relation": "implements"
    },
    {
      "source": "divide_conquer",
      "target": "meet_in_middle",
      "relation": "variant"
    },
    {
      "source": "backtracking",
      "target": "meet_in_middle",
      "relation": "optimization"
    },
    {
      "source": "union_find",
      "target": "small_to_large",
      "relation": "uses"
    },
    {
      "source": "tree",
      "target": "small_to_large",
      "relation": "pattern_for"
    },
    {
      "source": "tree",
      "target": "virtual_tree",
      "relation": "compressed_into"
    },
    {
      "source": "lca",
      "target": "virtual_tree",
      "relation": "uses"
    },
    {
      "source": "sorting",
      "target": "coord_compression",
      "relation": "uses"
    },
    {
      "source": "hashmap",
      "target": "coord_compression",
      "relation": "implements"
    },
    {
      "source": "divide_conquer",
      "target": "cdq_divide_conquer",
      "relation": "specialization"
    },
    {
      "source": "sorting",
      "target": "cdq_divide_conquer",
      "relation": "uses"
    },
    {
      "source": "segment_tree",
      "target": "li_chao_tree",
      "relation": "specialization"
    },
    {
      "source": "dp_convex_hull_trick",
      "target": "li_chao_tree",
      "relation": "implemented_by"
    },
    {
      "source": "splay_tree",
      "target": "link_cut_tree",
      "relation": "uses"
    },
    {
      "source": "tree",
      "target": "link_cut_tree",
      "relation": "dynamic_connectivity"
    },
    {
      "source": "euler_tour",
      "target": "euler_tour_tree",
      "relation": "basis_of"
    },
    {
      "source": "tree",
      "target": "euler_tour_tree",
      "relation": "dynamic_queries"
    },
    {
      "source": "segment_tree",
      "target": "wavelet_tree",
      "relation": "related"
    },
    {
      "source": "binary_search",
      "target": "wavelet_tree",
      "relation": "conceptual_basis"
    },
    {
      "source": "dll",
      "target": "dancing_links",
      "relation": "uses"
    },
    {
      "source": "backtracking",
      "target": "dancing_links",
      "relation": "optimizes"
    },
    {
      "source": "dp",
      "target": "kadane",
      "relation": "classic_problem"
    },
    {
      "source": "array",
      "target": "kadane",
      "relation": "problem_domain"
    },
    {
      "source": "convex_hull",
      "target": "rotating_calipers",
      "relation": "technique_for"
    },
    {
      "source": "two_pointers",
      "target": "rotating_calipers",
      "relation": "conceptual_basis"
    },
    {
      "source": "divide_conquer",
      "target": "voronoi",
      "relation": "construction"
    },
    {
      "source": "sweep_line",
      "target": "voronoi",
      "relation": "fortune_algorithm"
    },
    {
      "source": "voronoi",
      "target": "delaunay",
      "relation": "dual_of"
    },
    {
      "source": "convex_hull",
      "target": "delaunay",
      "relation": "related"
    },
    {
      "source": "hashing",
      "target": "consistent_hash",
      "relation": "distributed_variant"
    },
    {
      "source": "hashmap",
      "target": "consistent_hash",
      "relation": "distributed_variant"
    },
    {
      "source": "consistent_hash",
      "target": "dht",
      "relation": "basis_of"
    },
    {
      "source": "hashmap",
      "target": "dht",
      "relation": "distributed_variant"
    },
    {
      "source": "tree",
      "target": "lsm_tree",
      "relation": "specialization"
    },
    {
      "source": "sorting",
      "target": "lsm_tree",
      "relation": "merge_process"
    },
    {
      "source": "lsm_tree",
      "target": "sstable",
      "relation": "uses"
    },
    {
      "source": "array",
      "target": "sstable",
      "relation": "sorted_storage"
    },
    {
      "source": "array",
      "target": "wal",
      "relation": "log_storage"
    },
    {
      "source": "lsm_tree",
      "target": "wal",
      "relation": "durability"
    },
    {
      "source": "hashmap",
      "target": "inverted_index",
      "relation": "core_structure"
    },
    {
      "source": "trie",
      "target": "inverted_index",
      "relation": "term_lookup"
    },
    {
      "source": "graph",
      "target": "dag",
      "relation": "specialization"
    },
    {
      "source": "topo_sort",
      "target": "dag",
      "relation": "applies_to"
    },
    {
      "source": "hashmap",
      "target": "crdt",
      "relation": "replicated_variant"
    },
    {
      "source": "set",
      "target": "crdt",
      "relation": "replicated_variant"
    },
    {
      "source": "bloom",
      "target": "cuckoo_filter",
      "relation": "improved_variant"
    },
    {
      "source": "hashing",
      "target": "cuckoo_filter",
      "relation": "uses"
    },
    {
      "source": "bloom",
      "target": "counting_bloom",
      "relation": "variant"
    },
    {
      "source": "array",
      "target": "counting_bloom",
      "relation": "counter_storage"
    },
    {
      "source": "probability_theory",
      "target": "t_digest",
      "relation": "basis"
    },
    {
      "source": "tree",
      "target": "t_digest",
      "relation": "centroid_storage"
    },
    {
      "source": "queue",
      "target": "token_bucket",
      "relation": "conceptual"
    },
    {
      "source": "circular_buffer",
      "target": "token_bucket",
      "relation": "implementation"
    },
    {
      "source": "queue",
      "target": "leaky_bucket",
      "relation": "conceptual"
    },
    {
      "source": "circular_buffer",
      "target": "leaky_bucket",
      "relation": "implementation"
    },
    {
      "source": "array",
      "target": "time_series_db",
      "relation": "base_storage"
    },
    {
      "source": "lsm_tree",
      "target": "time_series_db",
      "relation": "common_backend"
    },
    {
      "source": "hashing",
      "target": "geohash",
      "relation": "encoding"
    },
    {
      "source": "kd_tree",
      "target": "geohash",
      "relation": "alternative"
    },
    {
      "source": "r_tree",
      "target": "geohash",
      "relation": "alternative"
    },
    {
      "source": "memory",
      "target": "binary",
      "relation": "foundation"
    },
    {
      "source": "memory",
      "target": "math",
      "relation": "foundation"
    },
    {
      "source": "memory",
      "target": "big_o",
      "relation": "analysis"
    },
    {
      "source": "memory",
      "target": "memory_model",
      "relation": "deep_dive"
    },
    {
      "source": "memory",
      "target": "functions",
      "relation": "execution"
    },
    {
      "source": "dp",
      "target": "memoization",
      "relation": "technique"
    },
    {
      "source": "dp",
      "target": "tabulation",
      "relation": "technique"
    },
    {
      "source": "dp",
      "target": "dp_patterns",
      "relation": "patterns"
    },
    {
      "source": "dp",
      "target": "subset_sum",
      "relation": "classic_problem"
    },
    {
      "source": "dp",
      "target": "stock_problems",
      "relation": "pattern"
    },
    {
      "source": "bits",
      "target": "xor_tricks",
      "relation": "advanced"
    },
    {
      "source": "two_pointers",
      "target": "three_sum",
      "relation": "pattern"
    },
    {
      "source": "sliding_window",
      "target": "sliding_window_max",
      "relation": "advanced"
    },
    {
      "source": "prefix_sum",
      "target": "subarray_sum",
      "relation": "pattern"
    },
    {
      "source": "monotonic_stack",
      "target": "histogram",
      "relation": "pattern"
    },
    {
      "source": "ll",
      "target": "linked_list_techniques",
      "relation": "techniques"
    },
    {
      "source": "binary_search",
      "target": "binary_search_variations",
      "relation": "variations"
    },
    {
      "source": "shortest_path",
      "target": "dijkstra",
      "relation": "algorithm"
    },
    {
      "source": "shortest_path",
      "target": "bidirectional_bfs",
      "relation": "optimization"
    },
    {
      "source": "shortest_path",
      "target": "shortest_path_dag",
      "relation": "variant"
    },
    {
      "source": "heap",
      "target": "top_k",
      "relation": "pattern"
    },
    {
      "source": "heap",
      "target": "median_finder",
      "relation": "pattern"
    },
    {
      "source": "topo_sort",
      "target": "critical_path",
      "relation": "application"
    },
    {
      "source": "trie",
      "target": "radix_tree",
      "relation": "variant"
    },
    {
      "source": "union_find",
      "target": "percolation",
      "relation": "application"
    },
    {
      "source": "backtracking",
      "target": "constraint_satisfaction",
      "relation": "advanced"
    },
    {
      "source": "backtracking",
      "target": "branch_bound",
      "relation": "optimization"
    }
  ],
  "interviewSources": {
    "leetcode": {
      "name": "LeetCode",
      "url": "https://leetcode.com/problemset/",
      "note": "Problem difficulty and company tags from LeetCode Premium"
    },
    "blind75": {
      "name": "Blind 75",
      "url": "https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions",
      "note": "Curated list by a Facebook engineer - most essential interview problems"
    },
    "neetcode150": {
      "name": "NeetCode 150",
      "url": "https://neetcode.io/practice",
      "note": "Extended Blind 75 with video explanations"
    },
    "grind75": {
      "name": "Grind 75",
      "url": "https://www.techinterviewhandbook.org/grind75",
      "note": "Customizable study plan by Yangshun (ex-Meta)"
    },
    "seanprashad": {
      "name": "Sean Prashad's Patterns",
      "url": "https://seanprashad.com/leetcode-patterns/",
      "note": "Pattern-based problem categorization"
    },
    "teamblind": {
      "name": "Blind (Teamblind)",
      "url": "https://www.teamblind.com/",
      "note": "Crowdsourced interview experiences from FAANG employees"
    },
    "glassdoor": {
      "name": "Glassdoor",
      "url": "https://www.glassdoor.com/Interview/",
      "note": "Interview reports with actual questions asked"
    },
    "interviewbit": {
      "name": "InterviewBit",
      "url": "https://www.interviewbit.com/",
      "note": "Structured interview prep with company-wise questions"
    }
  }
};